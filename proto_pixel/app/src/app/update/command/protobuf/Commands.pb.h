// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Commands.proto

#ifndef PROTOBUF_Commands_2eproto__INCLUDED
#define PROTOBUF_Commands_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace ea {
namespace eamobile {
namespace nfsmw {
namespace protoc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Commands_2eproto();
void protobuf_AssignDesc_Commands_2eproto();
void protobuf_ShutdownFile_Commands_2eproto();

class UserViewInfo;
class MissionInfo;
class Reward;
class RewardN;
class RewardList;
class Prop;
class FleetRace;
class Leaderboard;
class LeaderboardProfile;
class ModeInfo;
class TrackInfo;
class CheckPointInfo;
class NewbieTierCheckList;
class TierInfo;
class GPSInfo;
class RequestResourceCommand;
class ResourceItemInfo;
class ResponseResourceCommand;
class RequestTrackCommand;
class ResponseTrackCommand;
class RequestUserInfoCommand;
class ResponseWeiboShareLocksCommand;
class UserWeiboInfo;
class UserInfo;
class RequestModifyUserInfoCommand;
class ResponseModifyUserInfoCommand;
class ResponseUserInfoCommand;
class GhostInfo;
class RacerInfo;
class RequestModeInfoCommand;
class ResponseRacerForGhostCommand;
class ResponseModeInfoCommand;
class RequestRaceResultCommand;
class RPMessage;
class UnlockInfoMessage;
class ResponseRaceResultCommand;
class ResponseTournamentRaceResultCommand;
class TournamentMessage;
class TournamentRankingListMessage;
class TournamentRewardListMessage;
class TournamentRewardDetailMessage;
class TournamentDetailMessage;
class TournamentDetailRewardMessage;
class RequestTournamentCommand;
class ResponseTournamentCommand;
class RequestTournamentRewardDetailCommand;
class ResponseTournamentRewardDetailCommand;
class responseTournamentRewardCommand;
class RequestTournamentSignUpCommand;
class ResponseTournamentSignUpCommand;
class RequestTournamentDetailCommand;
class ResponseTournamentDetailCommand;
class RequestGetRewardCommand;
class ResponseGetRewardCommand;
class HeadInfo;
class RequestRaceStartCommand;
class ResponseRaceStartCommand;
class ResponseTournamentRaceStartCommand;
class AccountInfo;
class RequestBindingStartCommand;
class ResponseBindingStartCommand;
class RequestBindingTokenCommand;
class ResponseBindingTokenCommand;
class RequestBindingInfoCommand;
class ResponseBindingInfoCommand;
class RequestBindingResultCommand;
class ResponseBindingResultCommand;
class RequestBindingConfirmCommand;
class ResponseBindingConfirmCommand;
class ResponseBindingPopupCommand;
class ErrorCommand;
class CarData;
class GotchaExpense;
class ChartletInfo;
class CarSlotInfo;
class ConsumableData;
class RequestGarageCommand;
class ResponseGarageCommand;
class RequestBuyCarCommand;
class ResponseBuyCarCommand;
class RequestCarDataCommand;
class ResponseCarDataCommand;
class RequestUpgradeSlotCommand;
class ResponseUpgradeSlotCommand;
class RequestUseChartletCommand;
class ResponseUseChartletCommand;
class RequestChallengeMathInfoCommand;
class ResponseChallengeMatchInfoCommand;
class ResponseFeedCommand;
class ItemMessage;
class RequestStoreDetailCommand;
class ResponseStoreDetailCommand;
class RequestBuyItemCommand;
class ResponseBuyItemCommand;
class RequestSystemCommand;
class ResponseSystemCommand;
class EventOptionMessage;
class CashRewardMessage;
class MedalPositionMessage;
class MedalScoreMessage;
class MedalTimeMessage;
class CountdownInitialTimeMessage;
class PenaltyTimeMessage;
class OpponentCollectionMessage;
class OpponentMessage;
class AiSettingsMessage;
class RaceEventMessage;
class TrafficFlowMessage;
class RaceTrafficCongestionMessage;
class TrafficCarSpawnDescsMessage;
class RequestRegistJaguarCommand;
class ResponseRegistJaguarCommand;
class RequestRpLeaderboardCommand;
class ResponseRpLeaderboardCommand;
class RpLeaderboardMessage;
class ProfileCarInfo;
class RequestProfileUserDataCommand;
class ResponseProfileUserDataCommand;
class RequestProfileNextCarCommand;
class ResponseProfileNextCarCommand;
class RequestProfileLikeCommand;
class ResponseProfileLikeCommand;
class RequestProfileReportCommand;
class ResponseProfileReportCommand;
class UserVSProfile;
class RequestProfileVSCommand;
class ResponseProfileVSCommand;
class RequestRecordUserRaceActionCommand;
class RequestQuickRaceCommand;
class ResponseQuickRaceCommand;
class ResponseNotificationCommand;
class RequestGhostRecordCommand;
class ResponseGhostRecordCommand;
class RequestIapCheckCommand;
class ResponseIapCheckCommand;
class ResponseTournamentNotificationCommand;
class RequestTutorialRewardCommand;
class ResponseTutorialRewardCommand;
class ResponsePopupCommand;
class ResponsePopupListCommand;
class ResponseTournamentRewardNumCommand;
class RequestGotchaCommand;
class ResponseGotchaCommand;
class GotchaItemInfo;
class RequestCheatInfoCommand;
class LeaderboardClass;
class LeaderboardItem;
class RequestLeaderboardClass;
class ResponseLeaderboardClass;
class LeaderboardHeadInfo;
class RequestLeaderboard;
class ResponseLeaderboard;
class RequestTournamentNum;
class ResponseTournamentNum;
class RequestCollectEnergyCommand;
class RequestEnergyTimeCommand;
class ResponseEnergyTimeCommand;
class RequestFansRewardCommand;
class ResponseFansRewardTimeCommand;
class RequestPropPurchaseCommand;
class RequestMissionRewardCommand;
class RequestMissionFinishCommand;
class ResponseMissionListCommand;
class RequestLotteryCommand;
class ResponseLotteryCommand;
class RequestFleetRaceCommand;
class ResponseFleetRaceCommand;
class RequestFleetStartCommand;
class ResponseFleetStartCommand;
class RequestFleetEndCommand;
class ResponseFleetEndCommand;
class RequestFleetDoubleCommand;
class ResponseFleetDoubleCommand;
class RequestFixCarLimitCommand;
class ResponseFixCarLimitCommand;
class RequestCommand;
class ResponseCommand;
class LocalUserinfo;

enum RequestSystemCommand_SystemConfigType {
  RequestSystemCommand_SystemConfigType_UserLanguage = 0,
  RequestSystemCommand_SystemConfigType_SynergyUID = 1
};
bool RequestSystemCommand_SystemConfigType_IsValid(int value);
const RequestSystemCommand_SystemConfigType RequestSystemCommand_SystemConfigType_SystemConfigType_MIN = RequestSystemCommand_SystemConfigType_UserLanguage;
const RequestSystemCommand_SystemConfigType RequestSystemCommand_SystemConfigType_SystemConfigType_MAX = RequestSystemCommand_SystemConfigType_SynergyUID;
const int RequestSystemCommand_SystemConfigType_SystemConfigType_ARRAYSIZE = RequestSystemCommand_SystemConfigType_SystemConfigType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestSystemCommand_SystemConfigType_descriptor();
inline const ::std::string& RequestSystemCommand_SystemConfigType_Name(RequestSystemCommand_SystemConfigType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestSystemCommand_SystemConfigType_descriptor(), value);
}
inline bool RequestSystemCommand_SystemConfigType_Parse(
    const ::std::string& name, RequestSystemCommand_SystemConfigType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestSystemCommand_SystemConfigType>(
    RequestSystemCommand_SystemConfigType_descriptor(), name, value);
}
// ===================================================================

class UserViewInfo : public ::google::protobuf::Message {
 public:
  UserViewInfo();
  virtual ~UserViewInfo();
  
  UserViewInfo(const UserViewInfo& from);
  
  inline UserViewInfo& operator=(const UserViewInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserViewInfo& default_instance();
  
  void Swap(UserViewInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserViewInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserViewInfo& from);
  void MergeFrom(const UserViewInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // required string headUrl = 2;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 2;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string email = 4;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 4;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  
  // required string mobile = 5;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 5;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  
  // required int32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // required int32 money = 7;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 7;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);
  
  // required int64 createTime = 8;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 8;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);
  
  // required int64 loginTime = 9;
  inline bool has_logintime() const;
  inline void clear_logintime();
  static const int kLoginTimeFieldNumber = 9;
  inline ::google::protobuf::int64 logintime() const;
  inline void set_logintime(::google::protobuf::int64 value);
  
  // optional bool isNameChanged = 10;
  inline bool has_isnamechanged() const;
  inline void clear_isnamechanged();
  static const int kIsNameChangedFieldNumber = 10;
  inline bool isnamechanged() const;
  inline void set_isnamechanged(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.UserViewInfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_logintime();
  inline void clear_has_logintime();
  inline void set_has_isnamechanged();
  inline void clear_has_isnamechanged();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 userid_;
  ::std::string* headurl_;
  ::std::string* name_;
  ::std::string* email_;
  ::std::string* mobile_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::int64 logintime_;
  bool isnamechanged_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static UserViewInfo* default_instance_;
};
// -------------------------------------------------------------------

class MissionInfo : public ::google::protobuf::Message {
 public:
  MissionInfo();
  virtual ~MissionInfo();
  
  MissionInfo(const MissionInfo& from);
  
  inline MissionInfo& operator=(const MissionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MissionInfo& default_instance();
  
  void Swap(MissionInfo* other);
  
  // implements Message ----------------------------------------------
  
  MissionInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MissionInfo& from);
  void MergeFrom(const MissionInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string des = 3;
  inline bool has_des() const;
  inline void clear_des();
  static const int kDesFieldNumber = 3;
  inline const ::std::string& des() const;
  inline void set_des(const ::std::string& value);
  inline void set_des(const char* value);
  inline void set_des(const char* value, size_t size);
  inline ::std::string* mutable_des();
  inline ::std::string* release_des();
  
  // repeated int32 rewardCount = 4;
  inline int rewardcount_size() const;
  inline void clear_rewardcount();
  static const int kRewardCountFieldNumber = 4;
  inline ::google::protobuf::int32 rewardcount(int index) const;
  inline void set_rewardcount(int index, ::google::protobuf::int32 value);
  inline void add_rewardcount(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      rewardcount() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_rewardcount();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.MissionInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_des();
  inline void clear_has_des();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* des_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > rewardcount_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static MissionInfo* default_instance_;
};
// -------------------------------------------------------------------

class Reward : public ::google::protobuf::Message {
 public:
  Reward();
  virtual ~Reward();
  
  Reward(const Reward& from);
  
  inline Reward& operator=(const Reward& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Reward& default_instance();
  
  void Swap(Reward* other);
  
  // implements Message ----------------------------------------------
  
  Reward* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reward& from);
  void MergeFrom(const Reward& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 rmb = 1;
  inline bool has_rmb() const;
  inline void clear_rmb();
  static const int kRmbFieldNumber = 1;
  inline ::google::protobuf::int32 rmb() const;
  inline void set_rmb(::google::protobuf::int32 value);
  
  // optional int32 money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);
  
  // optional int32 rpNum = 3;
  inline bool has_rpnum() const;
  inline void clear_rpnum();
  static const int kRpNumFieldNumber = 3;
  inline ::google::protobuf::int32 rpnum() const;
  inline void set_rpnum(::google::protobuf::int32 value);
  
  // optional int32 mostwantedNum = 4;
  inline bool has_mostwantednum() const;
  inline void clear_mostwantednum();
  static const int kMostwantedNumFieldNumber = 4;
  inline ::google::protobuf::int32 mostwantednum() const;
  inline void set_mostwantednum(::google::protobuf::int32 value);
  
  // optional int32 finishRatio = 5;
  inline bool has_finishratio() const;
  inline void clear_finishratio();
  static const int kFinishRatioFieldNumber = 5;
  inline ::google::protobuf::int32 finishratio() const;
  inline void set_finishratio(::google::protobuf::int32 value);
  
  // optional string displayStrings = 6;
  inline bool has_displaystrings() const;
  inline void clear_displaystrings();
  static const int kDisplayStringsFieldNumber = 6;
  inline const ::std::string& displaystrings() const;
  inline void set_displaystrings(const ::std::string& value);
  inline void set_displaystrings(const char* value);
  inline void set_displaystrings(const char* value, size_t size);
  inline ::std::string* mutable_displaystrings();
  inline ::std::string* release_displaystrings();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.Reward)
 private:
  inline void set_has_rmb();
  inline void clear_has_rmb();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_rpnum();
  inline void clear_has_rpnum();
  inline void set_has_mostwantednum();
  inline void clear_has_mostwantednum();
  inline void set_has_finishratio();
  inline void clear_has_finishratio();
  inline void set_has_displaystrings();
  inline void clear_has_displaystrings();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 rmb_;
  ::google::protobuf::int32 money_;
  ::google::protobuf::int32 rpnum_;
  ::google::protobuf::int32 mostwantednum_;
  ::std::string* displaystrings_;
  ::google::protobuf::int32 finishratio_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static Reward* default_instance_;
};
// -------------------------------------------------------------------

class RewardN : public ::google::protobuf::Message {
 public:
  RewardN();
  virtual ~RewardN();
  
  RewardN(const RewardN& from);
  
  inline RewardN& operator=(const RewardN& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardN& default_instance();
  
  void Swap(RewardN* other);
  
  // implements Message ----------------------------------------------
  
  RewardN* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RewardN& from);
  void MergeFrom(const RewardN& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RewardN)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RewardN* default_instance_;
};
// -------------------------------------------------------------------

class RewardList : public ::google::protobuf::Message {
 public:
  RewardList();
  virtual ~RewardList();
  
  RewardList(const RewardList& from);
  
  inline RewardList& operator=(const RewardList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RewardList& default_instance();
  
  void Swap(RewardList* other);
  
  // implements Message ----------------------------------------------
  
  RewardList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RewardList& from);
  void MergeFrom(const RewardList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RewardN rewards = 1;
  inline int rewards_size() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::RewardN& rewards(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RewardN* mutable_rewards(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RewardN* add_rewards();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardN >&
      rewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardN >*
      mutable_rewards();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RewardList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardN > rewards_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RewardList* default_instance_;
};
// -------------------------------------------------------------------

class Prop : public ::google::protobuf::Message {
 public:
  Prop();
  virtual ~Prop();
  
  Prop(const Prop& from);
  
  inline Prop& operator=(const Prop& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Prop& default_instance();
  
  void Swap(Prop* other);
  
  // implements Message ----------------------------------------------
  
  Prop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Prop& from);
  void MergeFrom(const Prop& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.Prop)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static Prop* default_instance_;
};
// -------------------------------------------------------------------

class FleetRace : public ::google::protobuf::Message {
 public:
  FleetRace();
  virtual ~FleetRace();
  
  FleetRace(const FleetRace& from);
  
  inline FleetRace& operator=(const FleetRace& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FleetRace& default_instance();
  
  void Swap(FleetRace* other);
  
  // implements Message ----------------------------------------------
  
  FleetRace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FleetRace& from);
  void MergeFrom(const FleetRace& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required int32 name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline ::google::protobuf::int32 name() const;
  inline void set_name(::google::protobuf::int32 value);
  
  // required string carid = 4;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCaridFieldNumber = 4;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // required int32 time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // required int32 points = 6;
  inline bool has_points() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 6;
  inline ::google::protobuf::int32 points() const;
  inline void set_points(::google::protobuf::int32 value);
  
  // required int32 limitCost = 7;
  inline bool has_limitcost() const;
  inline void clear_limitcost();
  static const int kLimitCostFieldNumber = 7;
  inline ::google::protobuf::int32 limitcost() const;
  inline void set_limitcost(::google::protobuf::int32 value);
  
  // required int32 energyCost = 8;
  inline bool has_energycost() const;
  inline void clear_energycost();
  static const int kEnergyCostFieldNumber = 8;
  inline ::google::protobuf::int32 energycost() const;
  inline void set_energycost(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RewardList rewards = 9;
  inline int rewards_size() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 9;
  inline const ::com::ea::eamobile::nfsmw::protoc::RewardList& rewards(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RewardList* mutable_rewards(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RewardList* add_rewards();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >&
      rewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >*
      mutable_rewards();
  
  // required int32 count = 10;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 10;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // required int32 state = 11;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 11;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);
  
  // required int32 tier = 12;
  inline bool has_tier() const;
  inline void clear_tier();
  static const int kTierFieldNumber = 12;
  inline ::google::protobuf::int32 tier() const;
  inline void set_tier(::google::protobuf::int32 value);
  
  // required int32 cartype = 13;
  inline bool has_cartype() const;
  inline void clear_cartype();
  static const int kCartypeFieldNumber = 13;
  inline ::google::protobuf::int32 cartype() const;
  inline void set_cartype(::google::protobuf::int32 value);
  
  // required int32 ramainTime = 14;
  inline bool has_ramaintime() const;
  inline void clear_ramaintime();
  static const int kRamainTimeFieldNumber = 14;
  inline ::google::protobuf::int32 ramaintime() const;
  inline void set_ramaintime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.FleetRace)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_carid();
  inline void clear_has_carid();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_points();
  inline void clear_has_points();
  inline void set_has_limitcost();
  inline void clear_has_limitcost();
  inline void set_has_energycost();
  inline void clear_has_energycost();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_tier();
  inline void clear_has_tier();
  inline void set_has_cartype();
  inline void clear_has_cartype();
  inline void set_has_ramaintime();
  inline void clear_has_ramaintime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::std::string* carid_;
  ::google::protobuf::int32 name_;
  ::google::protobuf::int32 time_;
  ::google::protobuf::int32 points_;
  ::google::protobuf::int32 limitcost_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList > rewards_;
  ::google::protobuf::int32 energycost_;
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 state_;
  ::google::protobuf::int32 tier_;
  ::google::protobuf::int32 cartype_;
  ::google::protobuf::int32 ramaintime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static FleetRace* default_instance_;
};
// -------------------------------------------------------------------

class Leaderboard : public ::google::protobuf::Message {
 public:
  Leaderboard();
  virtual ~Leaderboard();
  
  Leaderboard(const Leaderboard& from);
  
  inline Leaderboard& operator=(const Leaderboard& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Leaderboard& default_instance();
  
  void Swap(Leaderboard* other);
  
  // implements Message ----------------------------------------------
  
  Leaderboard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Leaderboard& from);
  void MergeFrom(const Leaderboard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required float raceResult = 2;
  inline bool has_raceresult() const;
  inline void clear_raceresult();
  static const int kRaceResultFieldNumber = 2;
  inline float raceresult() const;
  inline void set_raceresult(float value);
  
  // optional int32 headIndex = 3;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 3;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // optional string headUrl = 4;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 4;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // optional int32 rank = 5;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 5;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // optional bool isMyself = 6;
  inline bool has_ismyself() const;
  inline void clear_ismyself();
  static const int kIsMyselfFieldNumber = 6;
  inline bool ismyself() const;
  inline void set_ismyself(bool value);
  
  // optional int64 userId = 7;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 7;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.Leaderboard)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_raceresult();
  inline void clear_has_raceresult();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_ismyself();
  inline void clear_has_ismyself();
  inline void set_has_userid();
  inline void clear_has_userid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  float raceresult_;
  ::google::protobuf::int32 headindex_;
  ::std::string* headurl_;
  ::google::protobuf::int32 rank_;
  bool ismyself_;
  ::google::protobuf::int64 userid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static Leaderboard* default_instance_;
};
// -------------------------------------------------------------------

class LeaderboardProfile : public ::google::protobuf::Message {
 public:
  LeaderboardProfile();
  virtual ~LeaderboardProfile();
  
  LeaderboardProfile(const LeaderboardProfile& from);
  
  inline LeaderboardProfile& operator=(const LeaderboardProfile& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderboardProfile& default_instance();
  
  void Swap(LeaderboardProfile* other);
  
  // implements Message ----------------------------------------------
  
  LeaderboardProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderboardProfile& from);
  void MergeFrom(const LeaderboardProfile& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required float raceResult = 2;
  inline bool has_raceresult() const;
  inline void clear_raceresult();
  static const int kRaceResultFieldNumber = 2;
  inline float raceresult() const;
  inline void set_raceresult(float value);
  
  // optional int32 headIndex = 3;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 3;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // optional string headUrl = 4;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 4;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // optional int32 rank = 5;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 5;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // optional bool isMyself = 6;
  inline bool has_ismyself() const;
  inline void clear_ismyself();
  static const int kIsMyselfFieldNumber = 6;
  inline bool ismyself() const;
  inline void set_ismyself(bool value);
  
  // optional string carID = 7;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIDFieldNumber = 7;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // optional int32 carColorIndex = 8;
  inline bool has_carcolorindex() const;
  inline void clear_carcolorindex();
  static const int kCarColorIndexFieldNumber = 8;
  inline ::google::protobuf::int32 carcolorindex() const;
  inline void set_carcolorindex(::google::protobuf::int32 value);
  
  // repeated int32 carModType = 9;
  inline int carmodtype_size() const;
  inline void clear_carmodtype();
  static const int kCarModTypeFieldNumber = 9;
  inline ::google::protobuf::int32 carmodtype(int index) const;
  inline void set_carmodtype(int index, ::google::protobuf::int32 value);
  inline void add_carmodtype(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodtype() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodtype();
  
  // repeated float carModValue = 10;
  inline int carmodvalue_size() const;
  inline void clear_carmodvalue();
  static const int kCarModValueFieldNumber = 10;
  inline float carmodvalue(int index) const;
  inline void set_carmodvalue(int index, float value);
  inline void add_carmodvalue(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      carmodvalue() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_carmodvalue();
  
  // optional int32 carScore = 11;
  inline bool has_carscore() const;
  inline void clear_carscore();
  static const int kCarScoreFieldNumber = 11;
  inline ::google::protobuf::int32 carscore() const;
  inline void set_carscore(::google::protobuf::int32 value);
  
  // repeated int32 carModId = 12;
  inline int carmodid_size() const;
  inline void clear_carmodid();
  static const int kCarModIdFieldNumber = 12;
  inline ::google::protobuf::int32 carmodid(int index) const;
  inline void set_carmodid(int index, ::google::protobuf::int32 value);
  inline void add_carmodid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodid();
  
  // repeated int32 carModLevel = 13;
  inline int carmodlevel_size() const;
  inline void clear_carmodlevel();
  static const int kCarModLevelFieldNumber = 13;
  inline ::google::protobuf::int32 carmodlevel(int index) const;
  inline void set_carmodlevel(int index, ::google::protobuf::int32 value);
  inline void add_carmodlevel(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodlevel() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodlevel();
  
  // optional int64 userid = 14;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 14;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.LeaderboardProfile)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_raceresult();
  inline void clear_has_raceresult();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_ismyself();
  inline void clear_has_ismyself();
  inline void set_has_carid();
  inline void clear_has_carid();
  inline void set_has_carcolorindex();
  inline void clear_has_carcolorindex();
  inline void set_has_carscore();
  inline void clear_has_carscore();
  inline void set_has_userid();
  inline void clear_has_userid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  float raceresult_;
  ::google::protobuf::int32 headindex_;
  ::std::string* headurl_;
  ::google::protobuf::int32 rank_;
  bool ismyself_;
  ::std::string* carid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodtype_;
  ::google::protobuf::int32 carcolorindex_;
  ::google::protobuf::int32 carscore_;
  ::google::protobuf::RepeatedField< float > carmodvalue_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodlevel_;
  ::google::protobuf::int64 userid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static LeaderboardProfile* default_instance_;
};
// -------------------------------------------------------------------

class ModeInfo : public ::google::protobuf::Message {
 public:
  ModeInfo();
  virtual ~ModeInfo();
  
  ModeInfo(const ModeInfo& from);
  
  inline ModeInfo& operator=(const ModeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModeInfo& default_instance();
  
  void Swap(ModeInfo* other);
  
  // implements Message ----------------------------------------------
  
  ModeInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModeInfo& from);
  void MergeFrom(const ModeInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 modeId = 1;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 1;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // required string modeName = 2;
  inline bool has_modename() const;
  inline void clear_modename();
  static const int kModeNameFieldNumber = 2;
  inline const ::std::string& modename() const;
  inline void set_modename(const ::std::string& value);
  inline void set_modename(const char* value);
  inline void set_modename(const char* value, size_t size);
  inline ::std::string* mutable_modename();
  inline ::std::string* release_modename();
  
  // required int32 modeType = 3;
  inline bool has_modetype() const;
  inline void clear_modetype();
  static const int kModeTypeFieldNumber = 3;
  inline ::google::protobuf::int32 modetype() const;
  inline void set_modetype(::google::protobuf::int32 value);
  
  // required int32 finishRatio = 4;
  inline bool has_finishratio() const;
  inline void clear_finishratio();
  static const int kFinishRatioFieldNumber = 4;
  inline ::google::protobuf::int32 finishratio() const;
  inline void set_finishratio(::google::protobuf::int32 value);
  
  // required int32 mostwantedNum = 5;
  inline bool has_mostwantednum() const;
  inline void clear_mostwantednum();
  static const int kMostwantedNumFieldNumber = 5;
  inline ::google::protobuf::int32 mostwantednum() const;
  inline void set_mostwantednum(::google::protobuf::int32 value);
  
  // required bool isNew = 6;
  inline bool has_isnew() const;
  inline void clear_isnew();
  static const int kIsNewFieldNumber = 6;
  inline bool isnew() const;
  inline void set_isnew(bool value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard leaderboard = 7;
  inline int leaderboard_size() const;
  inline void clear_leaderboard();
  static const int kLeaderboardFieldNumber = 7;
  inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& leaderboard(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* mutable_leaderboard(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* add_leaderboard();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
      leaderboard() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
      mutable_leaderboard();
  
  // optional int32 realTrackIndex = 8;
  inline bool has_realtrackindex() const;
  inline void clear_realtrackindex();
  static const int kRealTrackIndexFieldNumber = 8;
  inline ::google::protobuf::int32 realtrackindex() const;
  inline void set_realtrackindex(::google::protobuf::int32 value);
  
  // optional int32 energyCost = 9;
  inline bool has_energycost() const;
  inline void clear_energycost();
  static const int kEnergyCostFieldNumber = 9;
  inline ::google::protobuf::int32 energycost() const;
  inline void set_energycost(::google::protobuf::int32 value);
  
  // optional string carLimitDisplayString = 10;
  inline bool has_carlimitdisplaystring() const;
  inline void clear_carlimitdisplaystring();
  static const int kCarLimitDisplayStringFieldNumber = 10;
  inline const ::std::string& carlimitdisplaystring() const;
  inline void set_carlimitdisplaystring(const ::std::string& value);
  inline void set_carlimitdisplaystring(const char* value);
  inline void set_carlimitdisplaystring(const char* value, size_t size);
  inline ::std::string* mutable_carlimitdisplaystring();
  inline ::std::string* release_carlimitdisplaystring();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.LeaderboardProfile leaderboard2 = 11;
  inline int leaderboard2_size() const;
  inline void clear_leaderboard2();
  static const int kLeaderboard2FieldNumber = 11;
  inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile& leaderboard2(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile* mutable_leaderboard2(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile* add_leaderboard2();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile >&
      leaderboard2() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile >*
      mutable_leaderboard2();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ModeInfo)
 private:
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_modename();
  inline void clear_has_modename();
  inline void set_has_modetype();
  inline void clear_has_modetype();
  inline void set_has_finishratio();
  inline void clear_has_finishratio();
  inline void set_has_mostwantednum();
  inline void clear_has_mostwantednum();
  inline void set_has_isnew();
  inline void clear_has_isnew();
  inline void set_has_realtrackindex();
  inline void clear_has_realtrackindex();
  inline void set_has_energycost();
  inline void clear_has_energycost();
  inline void set_has_carlimitdisplaystring();
  inline void clear_has_carlimitdisplaystring();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* modename_;
  ::google::protobuf::int32 modeid_;
  ::google::protobuf::int32 modetype_;
  ::google::protobuf::int32 finishratio_;
  ::google::protobuf::int32 mostwantednum_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard > leaderboard_;
  bool isnew_;
  ::google::protobuf::int32 realtrackindex_;
  ::std::string* carlimitdisplaystring_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile > leaderboard2_;
  ::google::protobuf::int32 energycost_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ModeInfo* default_instance_;
};
// -------------------------------------------------------------------

class TrackInfo : public ::google::protobuf::Message {
 public:
  TrackInfo();
  virtual ~TrackInfo();
  
  TrackInfo(const TrackInfo& from);
  
  inline TrackInfo& operator=(const TrackInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackInfo& default_instance();
  
  void Swap(TrackInfo* other);
  
  // implements Message ----------------------------------------------
  
  TrackInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackInfo& from);
  void MergeFrom(const TrackInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string trackId = 1;
  inline bool has_trackid() const;
  inline void clear_trackid();
  static const int kTrackIdFieldNumber = 1;
  inline const ::std::string& trackid() const;
  inline void set_trackid(const ::std::string& value);
  inline void set_trackid(const char* value);
  inline void set_trackid(const char* value, size_t size);
  inline ::std::string* mutable_trackid();
  inline ::std::string* release_trackid();
  
  // required int32 finishRatio = 2;
  inline bool has_finishratio() const;
  inline void clear_finishratio();
  static const int kFinishRatioFieldNumber = 2;
  inline ::google::protobuf::int32 finishratio() const;
  inline void set_finishratio(::google::protobuf::int32 value);
  
  // repeated int32 carTypes = 3;
  inline int cartypes_size() const;
  inline void clear_cartypes();
  static const int kCarTypesFieldNumber = 3;
  inline ::google::protobuf::int32 cartypes(int index) const;
  inline void set_cartypes(int index, ::google::protobuf::int32 value);
  inline void add_cartypes(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      cartypes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_cartypes();
  
  // required int32 difficulty = 4;
  inline bool has_difficulty() const;
  inline void clear_difficulty();
  static const int kDifficultyFieldNumber = 4;
  inline ::google::protobuf::int32 difficulty() const;
  inline void set_difficulty(::google::protobuf::int32 value);
  
  // required bool unlock = 5;
  inline bool has_unlock() const;
  inline void clear_unlock();
  static const int kUnlockFieldNumber = 5;
  inline bool unlock() const;
  inline void set_unlock(bool value);
  
  // optional int32 userMostwantedNum = 6;
  inline bool has_usermostwantednum() const;
  inline void clear_usermostwantednum();
  static const int kUserMostwantedNumFieldNumber = 6;
  inline ::google::protobuf::int32 usermostwantednum() const;
  inline void set_usermostwantednum(::google::protobuf::int32 value);
  
  // optional bool isNew = 7;
  inline bool has_isnew() const;
  inline void clear_isnew();
  static const int kIsNewFieldNumber = 7;
  inline bool isnew() const;
  inline void set_isnew(bool value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.ModeInfo modes = 8;
  inline int modes_size() const;
  inline void clear_modes();
  static const int kModesFieldNumber = 8;
  inline const ::com::ea::eamobile::nfsmw::protoc::ModeInfo& modes(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::ModeInfo* mutable_modes(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::ModeInfo* add_modes();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ModeInfo >&
      modes() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ModeInfo >*
      mutable_modes();
  
  // required string trackName = 9;
  inline bool has_trackname() const;
  inline void clear_trackname();
  static const int kTrackNameFieldNumber = 9;
  inline const ::std::string& trackname() const;
  inline void set_trackname(const ::std::string& value);
  inline void set_trackname(const char* value);
  inline void set_trackname(const char* value, size_t size);
  inline ::std::string* mutable_trackname();
  inline ::std::string* release_trackname();
  
  // optional string carTypeForDisplay = 10;
  inline bool has_cartypefordisplay() const;
  inline void clear_cartypefordisplay();
  static const int kCarTypeForDisplayFieldNumber = 10;
  inline const ::std::string& cartypefordisplay() const;
  inline void set_cartypefordisplay(const ::std::string& value);
  inline void set_cartypefordisplay(const char* value);
  inline void set_cartypefordisplay(const char* value, size_t size);
  inline ::std::string* mutable_cartypefordisplay();
  inline ::std::string* release_cartypefordisplay();
  
  // optional bool trackStatusUpdated = 11;
  inline bool has_trackstatusupdated() const;
  inline void clear_trackstatusupdated();
  static const int kTrackStatusUpdatedFieldNumber = 11;
  inline bool trackstatusupdated() const;
  inline void set_trackstatusupdated(bool value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.Reward reward = 12;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 12;
  inline const ::com::ea::eamobile::nfsmw::protoc::Reward& reward() const;
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* mutable_reward();
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* release_reward();
  
  // optional bool isHasNewMode = 13;
  inline bool has_ishasnewmode() const;
  inline void clear_ishasnewmode();
  static const int kIsHasNewModeFieldNumber = 13;
  inline bool ishasnewmode() const;
  inline void set_ishasnewmode(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TrackInfo)
 private:
  inline void set_has_trackid();
  inline void clear_has_trackid();
  inline void set_has_finishratio();
  inline void clear_has_finishratio();
  inline void set_has_difficulty();
  inline void clear_has_difficulty();
  inline void set_has_unlock();
  inline void clear_has_unlock();
  inline void set_has_usermostwantednum();
  inline void clear_has_usermostwantednum();
  inline void set_has_isnew();
  inline void clear_has_isnew();
  inline void set_has_trackname();
  inline void clear_has_trackname();
  inline void set_has_cartypefordisplay();
  inline void clear_has_cartypefordisplay();
  inline void set_has_trackstatusupdated();
  inline void clear_has_trackstatusupdated();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_ishasnewmode();
  inline void clear_has_ishasnewmode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* trackid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > cartypes_;
  ::google::protobuf::int32 finishratio_;
  ::google::protobuf::int32 difficulty_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ModeInfo > modes_;
  ::google::protobuf::int32 usermostwantednum_;
  bool unlock_;
  bool isnew_;
  bool trackstatusupdated_;
  bool ishasnewmode_;
  ::std::string* trackname_;
  ::std::string* cartypefordisplay_;
  ::com::ea::eamobile::nfsmw::protoc::Reward* reward_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TrackInfo* default_instance_;
};
// -------------------------------------------------------------------

class CheckPointInfo : public ::google::protobuf::Message {
 public:
  CheckPointInfo();
  virtual ~CheckPointInfo();
  
  CheckPointInfo(const CheckPointInfo& from);
  
  inline CheckPointInfo& operator=(const CheckPointInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckPointInfo& default_instance();
  
  void Swap(CheckPointInfo* other);
  
  // implements Message ----------------------------------------------
  
  CheckPointInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckPointInfo& from);
  void MergeFrom(const CheckPointInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 modeId = 1;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 1;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // required int32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // required int32 unlockMostwantedNum = 3;
  inline bool has_unlockmostwantednum() const;
  inline void clear_unlockmostwantednum();
  static const int kUnlockMostwantedNumFieldNumber = 3;
  inline ::google::protobuf::int32 unlockmostwantednum() const;
  inline void set_unlockmostwantednum(::google::protobuf::int32 value);
  
  // required string eventName = 4;
  inline bool has_eventname() const;
  inline void clear_eventname();
  static const int kEventNameFieldNumber = 4;
  inline const ::std::string& eventname() const;
  inline void set_eventname(const ::std::string& value);
  inline void set_eventname(const char* value);
  inline void set_eventname(const char* value, size_t size);
  inline ::std::string* mutable_eventname();
  inline ::std::string* release_eventname();
  
  // repeated string acceptableCarIDs = 5;
  inline int acceptablecarids_size() const;
  inline void clear_acceptablecarids();
  static const int kAcceptableCarIDsFieldNumber = 5;
  inline const ::std::string& acceptablecarids(int index) const;
  inline ::std::string* mutable_acceptablecarids(int index);
  inline void set_acceptablecarids(int index, const ::std::string& value);
  inline void set_acceptablecarids(int index, const char* value);
  inline void set_acceptablecarids(int index, const char* value, size_t size);
  inline ::std::string* add_acceptablecarids();
  inline void add_acceptablecarids(const ::std::string& value);
  inline void add_acceptablecarids(const char* value);
  inline void add_acceptablecarids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& acceptablecarids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_acceptablecarids();
  
  // required string carLimitDisplayString = 6;
  inline bool has_carlimitdisplaystring() const;
  inline void clear_carlimitdisplaystring();
  static const int kCarLimitDisplayStringFieldNumber = 6;
  inline const ::std::string& carlimitdisplaystring() const;
  inline void set_carlimitdisplaystring(const ::std::string& value);
  inline void set_carlimitdisplaystring(const char* value);
  inline void set_carlimitdisplaystring(const char* value, size_t size);
  inline ::std::string* mutable_carlimitdisplaystring();
  inline ::std::string* release_carlimitdisplaystring();
  
  // required int32 staminaCost = 7;
  inline bool has_staminacost() const;
  inline void clear_staminacost();
  static const int kStaminaCostFieldNumber = 7;
  inline ::google::protobuf::int32 staminacost() const;
  inline void set_staminacost(::google::protobuf::int32 value);
  
  // required .com.ea.eamobile.nfsmw.protoc.Reward reward = 8;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 8;
  inline const ::com::ea::eamobile::nfsmw::protoc::Reward& reward() const;
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* mutable_reward();
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* release_reward();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.CheckPointInfo)
 private:
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_unlockmostwantednum();
  inline void clear_has_unlockmostwantednum();
  inline void set_has_eventname();
  inline void clear_has_eventname();
  inline void set_has_carlimitdisplaystring();
  inline void clear_has_carlimitdisplaystring();
  inline void set_has_staminacost();
  inline void clear_has_staminacost();
  inline void set_has_reward();
  inline void clear_has_reward();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 modeid_;
  ::google::protobuf::int32 status_;
  ::std::string* eventname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> acceptablecarids_;
  ::google::protobuf::int32 unlockmostwantednum_;
  ::google::protobuf::int32 staminacost_;
  ::std::string* carlimitdisplaystring_;
  ::com::ea::eamobile::nfsmw::protoc::Reward* reward_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static CheckPointInfo* default_instance_;
};
// -------------------------------------------------------------------

class NewbieTierCheckList : public ::google::protobuf::Message {
 public:
  NewbieTierCheckList();
  virtual ~NewbieTierCheckList();
  
  NewbieTierCheckList(const NewbieTierCheckList& from);
  
  inline NewbieTierCheckList& operator=(const NewbieTierCheckList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewbieTierCheckList& default_instance();
  
  void Swap(NewbieTierCheckList* other);
  
  // implements Message ----------------------------------------------
  
  NewbieTierCheckList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewbieTierCheckList& from);
  void MergeFrom(const NewbieTierCheckList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // required bool isFinished = 2;
  inline bool has_isfinished() const;
  inline void clear_isfinished();
  static const int kIsFinishedFieldNumber = 2;
  inline bool isfinished() const;
  inline void set_isfinished(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.NewbieTierCheckList)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_isfinished();
  inline void clear_has_isfinished();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* text_;
  bool isfinished_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static NewbieTierCheckList* default_instance_;
};
// -------------------------------------------------------------------

class TierInfo : public ::google::protobuf::Message {
 public:
  TierInfo();
  virtual ~TierInfo();
  
  TierInfo(const TierInfo& from);
  
  inline TierInfo& operator=(const TierInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TierInfo& default_instance();
  
  void Swap(TierInfo* other);
  
  // implements Message ----------------------------------------------
  
  TierInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TierInfo& from);
  void MergeFrom(const TierInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 tierIndex = 1;
  inline bool has_tierindex() const;
  inline void clear_tierindex();
  static const int kTierIndexFieldNumber = 1;
  inline ::google::protobuf::int32 tierindex() const;
  inline void set_tierindex(::google::protobuf::int32 value);
  
  // required int32 tierAmount = 2;
  inline bool has_tieramount() const;
  inline void clear_tieramount();
  static const int kTierAmountFieldNumber = 2;
  inline ::google::protobuf::int32 tieramount() const;
  inline void set_tieramount(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.NewbieTierCheckList newbieTierCheckList = 3;
  inline int newbietierchecklist_size() const;
  inline void clear_newbietierchecklist();
  static const int kNewbieTierCheckListFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList& newbietierchecklist(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList* mutable_newbietierchecklist(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList* add_newbietierchecklist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList >&
      newbietierchecklist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList >*
      mutable_newbietierchecklist();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TierInfo)
 private:
  inline void set_has_tierindex();
  inline void clear_has_tierindex();
  inline void set_has_tieramount();
  inline void clear_has_tieramount();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 tierindex_;
  ::google::protobuf::int32 tieramount_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList > newbietierchecklist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TierInfo* default_instance_;
};
// -------------------------------------------------------------------

class GPSInfo : public ::google::protobuf::Message {
 public:
  GPSInfo();
  virtual ~GPSInfo();
  
  GPSInfo(const GPSInfo& from);
  
  inline GPSInfo& operator=(const GPSInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSInfo& default_instance();
  
  void Swap(GPSInfo* other);
  
  // implements Message ----------------------------------------------
  
  GPSInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSInfo& from);
  void MergeFrom(const GPSInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required double latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline double latitude() const;
  inline void set_latitude(double value);
  
  // required double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);
  
  // required string country = 3;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 3;
  inline const ::std::string& country() const;
  inline void set_country(const ::std::string& value);
  inline void set_country(const char* value);
  inline void set_country(const char* value, size_t size);
  inline ::std::string* mutable_country();
  inline ::std::string* release_country();
  
  // required string locality = 4;
  inline bool has_locality() const;
  inline void clear_locality();
  static const int kLocalityFieldNumber = 4;
  inline const ::std::string& locality() const;
  inline void set_locality(const ::std::string& value);
  inline void set_locality(const char* value);
  inline void set_locality(const char* value, size_t size);
  inline ::std::string* mutable_locality();
  inline ::std::string* release_locality();
  
  // required string subLocality = 5;
  inline bool has_sublocality() const;
  inline void clear_sublocality();
  static const int kSubLocalityFieldNumber = 5;
  inline const ::std::string& sublocality() const;
  inline void set_sublocality(const ::std::string& value);
  inline void set_sublocality(const char* value);
  inline void set_sublocality(const char* value, size_t size);
  inline ::std::string* mutable_sublocality();
  inline ::std::string* release_sublocality();
  
  // required string thoroughfare = 6;
  inline bool has_thoroughfare() const;
  inline void clear_thoroughfare();
  static const int kThoroughfareFieldNumber = 6;
  inline const ::std::string& thoroughfare() const;
  inline void set_thoroughfare(const ::std::string& value);
  inline void set_thoroughfare(const char* value);
  inline void set_thoroughfare(const char* value, size_t size);
  inline ::std::string* mutable_thoroughfare();
  inline ::std::string* release_thoroughfare();
  
  // required string subThoroughfare = 7;
  inline bool has_subthoroughfare() const;
  inline void clear_subthoroughfare();
  static const int kSubThoroughfareFieldNumber = 7;
  inline const ::std::string& subthoroughfare() const;
  inline void set_subthoroughfare(const ::std::string& value);
  inline void set_subthoroughfare(const char* value);
  inline void set_subthoroughfare(const char* value, size_t size);
  inline ::std::string* mutable_subthoroughfare();
  inline ::std::string* release_subthoroughfare();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.GPSInfo)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_country();
  inline void clear_has_country();
  inline void set_has_locality();
  inline void clear_has_locality();
  inline void set_has_sublocality();
  inline void clear_has_sublocality();
  inline void set_has_thoroughfare();
  inline void clear_has_thoroughfare();
  inline void set_has_subthoroughfare();
  inline void clear_has_subthoroughfare();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double latitude_;
  double longitude_;
  ::std::string* country_;
  ::std::string* locality_;
  ::std::string* sublocality_;
  ::std::string* thoroughfare_;
  ::std::string* subthoroughfare_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static GPSInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestResourceCommand : public ::google::protobuf::Message {
 public:
  RequestResourceCommand();
  virtual ~RequestResourceCommand();
  
  RequestResourceCommand(const RequestResourceCommand& from);
  
  inline RequestResourceCommand& operator=(const RequestResourceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestResourceCommand& default_instance();
  
  void Swap(RequestResourceCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestResourceCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestResourceCommand& from);
  void MergeFrom(const RequestResourceCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 clientVersion = 1;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 1;
  inline ::google::protobuf::int32 clientversion() const;
  inline void set_clientversion(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestResourceCommand)
 private:
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 clientversion_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestResourceCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResourceItemInfo : public ::google::protobuf::Message {
 public:
  ResourceItemInfo();
  virtual ~ResourceItemInfo();
  
  ResourceItemInfo(const ResourceItemInfo& from);
  
  inline ResourceItemInfo& operator=(const ResourceItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceItemInfo& default_instance();
  
  void Swap(ResourceItemInfo* other);
  
  // implements Message ----------------------------------------------
  
  ResourceItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceItemInfo& from);
  void MergeFrom(const ResourceItemInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  
  // required int32 size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);
  
  // required string md5 = 3;
  inline bool has_md5() const;
  inline void clear_md5();
  static const int kMd5FieldNumber = 3;
  inline const ::std::string& md5() const;
  inline void set_md5(const ::std::string& value);
  inline void set_md5(const char* value);
  inline void set_md5(const char* value, size_t size);
  inline ::std::string* mutable_md5();
  inline ::std::string* release_md5();
  
  // required int32 action = 4;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 4;
  inline ::google::protobuf::int32 action() const;
  inline void set_action(::google::protobuf::int32 value);
  
  // optional int32 version = 5;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 5;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResourceItemInfo)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_md5();
  inline void clear_has_md5();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* path_;
  ::std::string* md5_;
  ::google::protobuf::int32 size_;
  ::google::protobuf::int32 action_;
  ::google::protobuf::int32 version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResourceItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResponseResourceCommand : public ::google::protobuf::Message {
 public:
  ResponseResourceCommand();
  virtual ~ResponseResourceCommand();
  
  ResponseResourceCommand(const ResponseResourceCommand& from);
  
  inline ResponseResourceCommand& operator=(const ResponseResourceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseResourceCommand& default_instance();
  
  void Swap(ResponseResourceCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseResourceCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseResourceCommand& from);
  void MergeFrom(const ResponseResourceCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string rootPath = 1;
  inline bool has_rootpath() const;
  inline void clear_rootpath();
  static const int kRootPathFieldNumber = 1;
  inline const ::std::string& rootpath() const;
  inline void set_rootpath(const ::std::string& value);
  inline void set_rootpath(const char* value);
  inline void set_rootpath(const char* value, size_t size);
  inline ::std::string* mutable_rootpath();
  inline ::std::string* release_rootpath();
  
  // required int32 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.ResourceItemInfo items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo& items(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo* mutable_items(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo >*
      mutable_items();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseResourceCommand)
 private:
  inline void set_has_rootpath();
  inline void clear_has_rootpath();
  inline void set_has_version();
  inline void clear_has_version();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rootpath_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo > items_;
  ::google::protobuf::int32 version_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseResourceCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestTrackCommand : public ::google::protobuf::Message {
 public:
  RequestTrackCommand();
  virtual ~RequestTrackCommand();
  
  RequestTrackCommand(const RequestTrackCommand& from);
  
  inline RequestTrackCommand& operator=(const RequestTrackCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestTrackCommand& default_instance();
  
  void Swap(RequestTrackCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestTrackCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestTrackCommand& from);
  void MergeFrom(const RequestTrackCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 requestTier = 2;
  inline bool has_requesttier() const;
  inline void clear_requesttier();
  static const int kRequestTierFieldNumber = 2;
  inline ::google::protobuf::int32 requesttier() const;
  inline void set_requesttier(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestTrackCommand)
 private:
  inline void set_has_requesttier();
  inline void clear_has_requesttier();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 requesttier_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestTrackCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTrackCommand : public ::google::protobuf::Message {
 public:
  ResponseTrackCommand();
  virtual ~ResponseTrackCommand();
  
  ResponseTrackCommand(const ResponseTrackCommand& from);
  
  inline ResponseTrackCommand& operator=(const ResponseTrackCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTrackCommand& default_instance();
  
  void Swap(ResponseTrackCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTrackCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTrackCommand& from);
  void MergeFrom(const ResponseTrackCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .com.ea.eamobile.nfsmw.protoc.TierInfo tier = 1;
  inline bool has_tier() const;
  inline void clear_tier();
  static const int kTierFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::TierInfo& tier() const;
  inline ::com::ea::eamobile::nfsmw::protoc::TierInfo* mutable_tier();
  inline ::com::ea::eamobile::nfsmw::protoc::TierInfo* release_tier();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.TrackInfo tracks = 2;
  inline int tracks_size() const;
  inline void clear_tracks();
  static const int kTracksFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::TrackInfo& tracks(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::TrackInfo* mutable_tracks(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::TrackInfo* add_tracks();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TrackInfo >&
      tracks() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TrackInfo >*
      mutable_tracks();
  
  // optional .com.ea.eamobile.nfsmw.protoc.CheckPointInfo checkPointInfo = 3;
  inline bool has_checkpointinfo() const;
  inline void clear_checkpointinfo();
  static const int kCheckPointInfoFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo& checkpointinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* mutable_checkpointinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* release_checkpointinfo();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTrackCommand)
 private:
  inline void set_has_tier();
  inline void clear_has_tier();
  inline void set_has_checkpointinfo();
  inline void clear_has_checkpointinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::TierInfo* tier_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TrackInfo > tracks_;
  ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* checkpointinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTrackCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestUserInfoCommand : public ::google::protobuf::Message {
 public:
  RequestUserInfoCommand();
  virtual ~RequestUserInfoCommand();
  
  RequestUserInfoCommand(const RequestUserInfoCommand& from);
  
  inline RequestUserInfoCommand& operator=(const RequestUserInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUserInfoCommand& default_instance();
  
  void Swap(RequestUserInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestUserInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUserInfoCommand& from);
  void MergeFrom(const RequestUserInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string mac = 1;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMacFieldNumber = 1;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  
  // optional string deviceName = 2;
  inline bool has_devicename() const;
  inline void clear_devicename();
  static const int kDeviceNameFieldNumber = 2;
  inline const ::std::string& devicename() const;
  inline void set_devicename(const ::std::string& value);
  inline void set_devicename(const char* value);
  inline void set_devicename(const char* value, size_t size);
  inline ::std::string* mutable_devicename();
  inline ::std::string* release_devicename();
  
  // required string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional .com.ea.eamobile.nfsmw.protoc.GPSInfo gpsInfo = 4;
  inline bool has_gpsinfo() const;
  inline void clear_gpsinfo();
  static const int kGpsInfoFieldNumber = 4;
  inline const ::com::ea::eamobile::nfsmw::protoc::GPSInfo& gpsinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::GPSInfo* mutable_gpsinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::GPSInfo* release_gpsinfo();
  
  // optional bool isOld = 5;
  inline bool has_isold() const;
  inline void clear_isold();
  static const int kIsOldFieldNumber = 5;
  inline bool isold() const;
  inline void set_isold(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestUserInfoCommand)
 private:
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_devicename();
  inline void clear_has_devicename();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_gpsinfo();
  inline void clear_has_gpsinfo();
  inline void set_has_isold();
  inline void clear_has_isold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* mac_;
  ::std::string* devicename_;
  ::std::string* token_;
  ::com::ea::eamobile::nfsmw::protoc::GPSInfo* gpsinfo_;
  bool isold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestUserInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseWeiboShareLocksCommand : public ::google::protobuf::Message {
 public:
  ResponseWeiboShareLocksCommand();
  virtual ~ResponseWeiboShareLocksCommand();
  
  ResponseWeiboShareLocksCommand(const ResponseWeiboShareLocksCommand& from);
  
  inline ResponseWeiboShareLocksCommand& operator=(const ResponseWeiboShareLocksCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseWeiboShareLocksCommand& default_instance();
  
  void Swap(ResponseWeiboShareLocksCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseWeiboShareLocksCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseWeiboShareLocksCommand& from);
  void MergeFrom(const ResponseWeiboShareLocksCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool isRaceRewardShareOpen = 1;
  inline bool has_isracerewardshareopen() const;
  inline void clear_isracerewardshareopen();
  static const int kIsRaceRewardShareOpenFieldNumber = 1;
  inline bool isracerewardshareopen() const;
  inline void set_isracerewardshareopen(bool value);
  
  // required bool isTrackUnlockInfoShareOpen = 2;
  inline bool has_istrackunlockinfoshareopen() const;
  inline void clear_istrackunlockinfoshareopen();
  static const int kIsTrackUnlockInfoShareOpenFieldNumber = 2;
  inline bool istrackunlockinfoshareopen() const;
  inline void set_istrackunlockinfoshareopen(bool value);
  
  // required bool isCarUnlockInfoShareOpen = 3;
  inline bool has_iscarunlockinfoshareopen() const;
  inline void clear_iscarunlockinfoshareopen();
  static const int kIsCarUnlockInfoShareOpenFieldNumber = 3;
  inline bool iscarunlockinfoshareopen() const;
  inline void set_iscarunlockinfoshareopen(bool value);
  
  // required bool isSpeedWallShareOpen = 4;
  inline bool has_isspeedwallshareopen() const;
  inline void clear_isspeedwallshareopen();
  static const int kIsSpeedWallShareOpenFieldNumber = 4;
  inline bool isspeedwallshareopen() const;
  inline void set_isspeedwallshareopen(bool value);
  
  // required bool isBindingWeiboShareOpen = 5;
  inline bool has_isbindingweiboshareopen() const;
  inline void clear_isbindingweiboshareopen();
  static const int kIsBindingWeiboShareOpenFieldNumber = 5;
  inline bool isbindingweiboshareopen() const;
  inline void set_isbindingweiboshareopen(bool value);
  
  // required bool isTournamentRewardShareOpen = 6;
  inline bool has_istournamentrewardshareopen() const;
  inline void clear_istournamentrewardshareopen();
  static const int kIsTournamentRewardShareOpenFieldNumber = 6;
  inline bool istournamentrewardshareopen() const;
  inline void set_istournamentrewardshareopen(bool value);
  
  // required bool isBuyCarShareOpen = 7;
  inline bool has_isbuycarshareopen() const;
  inline void clear_isbuycarshareopen();
  static const int kIsBuyCarShareOpenFieldNumber = 7;
  inline bool isbuycarshareopen() const;
  inline void set_isbuycarshareopen(bool value);
  
  // required bool isUpdateConsumableShareOpen = 8;
  inline bool has_isupdateconsumableshareopen() const;
  inline void clear_isupdateconsumableshareopen();
  static const int kIsUpdateConsumableShareOpenFieldNumber = 8;
  inline bool isupdateconsumableshareopen() const;
  inline void set_isupdateconsumableshareopen(bool value);
  
  // optional bool isJaguarShareOpen = 9;
  inline bool has_isjaguarshareopen() const;
  inline void clear_isjaguarshareopen();
  static const int kIsJaguarShareOpenFieldNumber = 9;
  inline bool isjaguarshareopen() const;
  inline void set_isjaguarshareopen(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseWeiboShareLocksCommand)
 private:
  inline void set_has_isracerewardshareopen();
  inline void clear_has_isracerewardshareopen();
  inline void set_has_istrackunlockinfoshareopen();
  inline void clear_has_istrackunlockinfoshareopen();
  inline void set_has_iscarunlockinfoshareopen();
  inline void clear_has_iscarunlockinfoshareopen();
  inline void set_has_isspeedwallshareopen();
  inline void clear_has_isspeedwallshareopen();
  inline void set_has_isbindingweiboshareopen();
  inline void clear_has_isbindingweiboshareopen();
  inline void set_has_istournamentrewardshareopen();
  inline void clear_has_istournamentrewardshareopen();
  inline void set_has_isbuycarshareopen();
  inline void clear_has_isbuycarshareopen();
  inline void set_has_isupdateconsumableshareopen();
  inline void clear_has_isupdateconsumableshareopen();
  inline void set_has_isjaguarshareopen();
  inline void clear_has_isjaguarshareopen();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool isracerewardshareopen_;
  bool istrackunlockinfoshareopen_;
  bool iscarunlockinfoshareopen_;
  bool isspeedwallshareopen_;
  bool isbindingweiboshareopen_;
  bool istournamentrewardshareopen_;
  bool isbuycarshareopen_;
  bool isupdateconsumableshareopen_;
  bool isjaguarshareopen_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseWeiboShareLocksCommand* default_instance_;
};
// -------------------------------------------------------------------

class UserWeiboInfo : public ::google::protobuf::Message {
 public:
  UserWeiboInfo();
  virtual ~UserWeiboInfo();
  
  UserWeiboInfo(const UserWeiboInfo& from);
  
  inline UserWeiboInfo& operator=(const UserWeiboInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserWeiboInfo& default_instance();
  
  void Swap(UserWeiboInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserWeiboInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserWeiboInfo& from);
  void MergeFrom(const UserWeiboInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  
  // required string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.UserWeiboInfo)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_uid();
  inline void clear_has_uid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* access_token_;
  ::std::string* uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static UserWeiboInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();
  
  UserInfo(const UserInfo& from);
  
  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();
  
  void Swap(UserInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // required string headUrl = 2;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 2;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // required int32 headIndex = 3;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 3;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // required int32 tier = 4;
  inline bool has_tier() const;
  inline void clear_tier();
  static const int kTierFieldNumber = 4;
  inline ::google::protobuf::int32 tier() const;
  inline void set_tier(::google::protobuf::int32 value);
  
  // required int32 rpLevel = 5;
  inline bool has_rplevel() const;
  inline void clear_rplevel();
  static const int kRpLevelFieldNumber = 5;
  inline ::google::protobuf::int32 rplevel() const;
  inline void set_rplevel(::google::protobuf::int32 value);
  
  // required int32 rpExp = 6;
  inline bool has_rpexp() const;
  inline void clear_rpexp();
  static const int kRpExpFieldNumber = 6;
  inline ::google::protobuf::int32 rpexp() const;
  inline void set_rpexp(::google::protobuf::int32 value);
  
  // required int32 mostwantedNum = 7;
  inline bool has_mostwantednum() const;
  inline void clear_mostwantednum();
  static const int kMostwantedNumFieldNumber = 7;
  inline ::google::protobuf::int32 mostwantednum() const;
  inline void set_mostwantednum(::google::protobuf::int32 value);
  
  // required int32 currency = 8;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 8;
  inline ::google::protobuf::int32 currency() const;
  inline void set_currency(::google::protobuf::int32 value);
  
  // required int32 rmb = 9;
  inline bool has_rmb() const;
  inline void clear_rmb();
  static const int kRmbFieldNumber = 9;
  inline ::google::protobuf::int32 rmb() const;
  inline void set_rmb(::google::protobuf::int32 value);
  
  // required int32 energy = 10;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 10;
  inline ::google::protobuf::int32 energy() const;
  inline void set_energy(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.AccountInfo accountInfos = 11;
  inline int accountinfos_size() const;
  inline void clear_accountinfos();
  static const int kAccountInfosFieldNumber = 11;
  inline const ::com::ea::eamobile::nfsmw::protoc::AccountInfo& accountinfos(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::AccountInfo* mutable_accountinfos(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::AccountInfo* add_accountinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::AccountInfo >&
      accountinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::AccountInfo >*
      mutable_accountinfos();
  
  // optional int32 expMax = 12;
  inline bool has_expmax() const;
  inline void clear_expmax();
  static const int kExpMaxFieldNumber = 12;
  inline ::google::protobuf::int32 expmax() const;
  inline void set_expmax(::google::protobuf::int32 value);
  
  // optional int32 expMin = 13;
  inline bool has_expmin() const;
  inline void clear_expmin();
  static const int kExpMinFieldNumber = 13;
  inline ::google::protobuf::int32 expmin() const;
  inline void set_expmin(::google::protobuf::int32 value);
  
  // optional bool finishedFirstRace = 14;
  inline bool has_finishedfirstrace() const;
  inline void clear_finishedfirstrace();
  static const int kFinishedFirstRaceFieldNumber = 14;
  inline bool finishedfirstrace() const;
  inline void set_finishedfirstrace(bool value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.UserWeiboInfo weiboInfo = 15;
  inline bool has_weiboinfo() const;
  inline void clear_weiboinfo();
  static const int kWeiboInfoFieldNumber = 15;
  inline const ::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo& weiboinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo* mutable_weiboinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo* release_weiboinfo();
  
  // optional bool tutorialRewardIsGiven = 16;
  inline bool has_tutorialrewardisgiven() const;
  inline void clear_tutorialrewardisgiven();
  static const int kTutorialRewardIsGivenFieldNumber = 16;
  inline bool tutorialrewardisgiven() const;
  inline void set_tutorialrewardisgiven(bool value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.RPMessage rpMessage = 17;
  inline bool has_rpmessage() const;
  inline void clear_rpmessage();
  static const int kRpMessageFieldNumber = 17;
  inline const ::com::ea::eamobile::nfsmw::protoc::RPMessage& rpmessage() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* mutable_rpmessage();
  inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* release_rpmessage();
  
  // optional bool isNameChanged = 18;
  inline bool has_isnamechanged() const;
  inline void clear_isnamechanged();
  static const int kIsNameChangedFieldNumber = 18;
  inline bool isnamechanged() const;
  inline void set_isnamechanged(bool value);
  
  // optional string access_token = 19;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 19;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  
  // optional string uid = 20;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 20;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional int32 energytime = 21;
  inline bool has_energytime() const;
  inline void clear_energytime();
  static const int kEnergytimeFieldNumber = 21;
  inline ::google::protobuf::int32 energytime() const;
  inline void set_energytime(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Prop propnum = 22;
  inline int propnum_size() const;
  inline void clear_propnum();
  static const int kPropnumFieldNumber = 22;
  inline const ::com::ea::eamobile::nfsmw::protoc::Prop& propnum(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Prop* mutable_propnum(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Prop* add_propnum();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop >&
      propnum() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop >*
      mutable_propnum();
  
  // optional int32 packageStatus = 23;
  inline bool has_packagestatus() const;
  inline void clear_packagestatus();
  static const int kPackageStatusFieldNumber = 23;
  inline ::google::protobuf::int32 packagestatus() const;
  inline void set_packagestatus(::google::protobuf::int32 value);
  
  // optional bool isNoble = 24;
  inline bool has_isnoble() const;
  inline void clear_isnoble();
  static const int kIsNobleFieldNumber = 24;
  inline bool isnoble() const;
  inline void set_isnoble(bool value);
  
  // optional int32 leftNobleTime = 25;
  inline bool has_leftnobletime() const;
  inline void clear_leftnobletime();
  static const int kLeftNobleTimeFieldNumber = 25;
  inline ::google::protobuf::int32 leftnobletime() const;
  inline void set_leftnobletime(::google::protobuf::int32 value);
  
  // optional int32 leftGoldTime = 26;
  inline bool has_leftgoldtime() const;
  inline void clear_leftgoldtime();
  static const int kLeftGoldTimeFieldNumber = 26;
  inline ::google::protobuf::int32 leftgoldtime() const;
  inline void set_leftgoldtime(::google::protobuf::int32 value);
  
  // optional bool isGoldUnlocked = 27;
  inline bool has_isgoldunlocked() const;
  inline void clear_isgoldunlocked();
  static const int kIsGoldUnlockedFieldNumber = 27;
  inline bool isgoldunlocked() const;
  inline void set_isgoldunlocked(bool value);
  
  // optional int32 fansRewardStatus = 28;
  inline bool has_fansrewardstatus() const;
  inline void clear_fansrewardstatus();
  static const int kFansRewardStatusFieldNumber = 28;
  inline ::google::protobuf::int32 fansrewardstatus() const;
  inline void set_fansrewardstatus(::google::protobuf::int32 value);
  
  // optional int32 fansRewardLastTime = 29;
  inline bool has_fansrewardlasttime() const;
  inline void clear_fansrewardlasttime();
  static const int kFansRewardLastTimeFieldNumber = 29;
  inline ::google::protobuf::int32 fansrewardlasttime() const;
  inline void set_fansrewardlasttime(::google::protobuf::int32 value);
  
  // optional int32 missionRewardStatus = 30;
  inline bool has_missionrewardstatus() const;
  inline void clear_missionrewardstatus();
  static const int kMissionRewardStatusFieldNumber = 30;
  inline ::google::protobuf::int32 missionrewardstatus() const;
  inline void set_missionrewardstatus(::google::protobuf::int32 value);
  
  // optional int32 missionFinishStatus = 31;
  inline bool has_missionfinishstatus() const;
  inline void clear_missionfinishstatus();
  static const int kMissionFinishStatusFieldNumber = 31;
  inline ::google::protobuf::int32 missionfinishstatus() const;
  inline void set_missionfinishstatus(::google::protobuf::int32 value);
  
  // optional int32 raceTimes = 32;
  inline bool has_racetimes() const;
  inline void clear_racetimes();
  static const int kRaceTimesFieldNumber = 32;
  inline ::google::protobuf::int32 racetimes() const;
  inline void set_racetimes(::google::protobuf::int32 value);
  
  // optional bool isNewUser = 33;
  inline bool has_isnewuser() const;
  inline void clear_isnewuser();
  static const int kIsNewUserFieldNumber = 33;
  inline bool isnewuser() const;
  inline void set_isnewuser(bool value);
  
  // optional int32 lotteryTimes = 34;
  inline bool has_lotterytimes() const;
  inline void clear_lotterytimes();
  static const int kLotteryTimesFieldNumber = 34;
  inline ::google::protobuf::int32 lotterytimes() const;
  inline void set_lotterytimes(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.UserInfo)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_tier();
  inline void clear_has_tier();
  inline void set_has_rplevel();
  inline void clear_has_rplevel();
  inline void set_has_rpexp();
  inline void clear_has_rpexp();
  inline void set_has_mostwantednum();
  inline void clear_has_mostwantednum();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_rmb();
  inline void clear_has_rmb();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_expmax();
  inline void clear_has_expmax();
  inline void set_has_expmin();
  inline void clear_has_expmin();
  inline void set_has_finishedfirstrace();
  inline void clear_has_finishedfirstrace();
  inline void set_has_weiboinfo();
  inline void clear_has_weiboinfo();
  inline void set_has_tutorialrewardisgiven();
  inline void clear_has_tutorialrewardisgiven();
  inline void set_has_rpmessage();
  inline void clear_has_rpmessage();
  inline void set_has_isnamechanged();
  inline void clear_has_isnamechanged();
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_energytime();
  inline void clear_has_energytime();
  inline void set_has_packagestatus();
  inline void clear_has_packagestatus();
  inline void set_has_isnoble();
  inline void clear_has_isnoble();
  inline void set_has_leftnobletime();
  inline void clear_has_leftnobletime();
  inline void set_has_leftgoldtime();
  inline void clear_has_leftgoldtime();
  inline void set_has_isgoldunlocked();
  inline void clear_has_isgoldunlocked();
  inline void set_has_fansrewardstatus();
  inline void clear_has_fansrewardstatus();
  inline void set_has_fansrewardlasttime();
  inline void clear_has_fansrewardlasttime();
  inline void set_has_missionrewardstatus();
  inline void clear_has_missionrewardstatus();
  inline void set_has_missionfinishstatus();
  inline void clear_has_missionfinishstatus();
  inline void set_has_racetimes();
  inline void clear_has_racetimes();
  inline void set_has_isnewuser();
  inline void clear_has_isnewuser();
  inline void set_has_lotterytimes();
  inline void clear_has_lotterytimes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nickname_;
  ::std::string* headurl_;
  ::google::protobuf::int32 headindex_;
  ::google::protobuf::int32 tier_;
  ::google::protobuf::int32 rplevel_;
  ::google::protobuf::int32 rpexp_;
  ::google::protobuf::int32 mostwantednum_;
  ::google::protobuf::int32 currency_;
  ::google::protobuf::int32 rmb_;
  ::google::protobuf::int32 energy_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::AccountInfo > accountinfos_;
  ::google::protobuf::int32 expmax_;
  ::google::protobuf::int32 expmin_;
  ::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo* weiboinfo_;
  ::com::ea::eamobile::nfsmw::protoc::RPMessage* rpmessage_;
  bool finishedfirstrace_;
  bool tutorialrewardisgiven_;
  bool isnamechanged_;
  bool isnoble_;
  ::google::protobuf::int32 energytime_;
  ::std::string* access_token_;
  ::std::string* uid_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop > propnum_;
  ::google::protobuf::int32 packagestatus_;
  ::google::protobuf::int32 leftnobletime_;
  ::google::protobuf::int32 leftgoldtime_;
  ::google::protobuf::int32 fansrewardstatus_;
  ::google::protobuf::int32 fansrewardlasttime_;
  bool isgoldunlocked_;
  bool isnewuser_;
  ::google::protobuf::int32 missionrewardstatus_;
  ::google::protobuf::int32 missionfinishstatus_;
  ::google::protobuf::int32 racetimes_;
  ::google::protobuf::int32 lotterytimes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(34 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestModifyUserInfoCommand : public ::google::protobuf::Message {
 public:
  RequestModifyUserInfoCommand();
  virtual ~RequestModifyUserInfoCommand();
  
  RequestModifyUserInfoCommand(const RequestModifyUserInfoCommand& from);
  
  inline RequestModifyUserInfoCommand& operator=(const RequestModifyUserInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestModifyUserInfoCommand& default_instance();
  
  void Swap(RequestModifyUserInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestModifyUserInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestModifyUserInfoCommand& from);
  void MergeFrom(const RequestModifyUserInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 headIndex = 1;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 1;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestModifyUserInfoCommand)
 private:
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nickname_;
  ::google::protobuf::int32 headindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestModifyUserInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseModifyUserInfoCommand : public ::google::protobuf::Message {
 public:
  ResponseModifyUserInfoCommand();
  virtual ~ResponseModifyUserInfoCommand();
  
  ResponseModifyUserInfoCommand(const ResponseModifyUserInfoCommand& from);
  
  inline ResponseModifyUserInfoCommand& operator=(const ResponseModifyUserInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseModifyUserInfoCommand& default_instance();
  
  void Swap(ResponseModifyUserInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseModifyUserInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseModifyUserInfoCommand& from);
  void MergeFrom(const ResponseModifyUserInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .com.ea.eamobile.nfsmw.protoc.ErrorCommand result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::ErrorCommand& result() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* mutable_result();
  inline ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* release_result();
  
  // optional .com.ea.eamobile.nfsmw.protoc.UserInfo userinfo = 2;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::UserInfo& userinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* mutable_userinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* release_userinfo();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseModifyUserInfoCommand)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* result_;
  ::com::ea::eamobile::nfsmw::protoc::UserInfo* userinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseModifyUserInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUserInfoCommand : public ::google::protobuf::Message {
 public:
  ResponseUserInfoCommand();
  virtual ~ResponseUserInfoCommand();
  
  ResponseUserInfoCommand(const ResponseUserInfoCommand& from);
  
  inline ResponseUserInfoCommand& operator=(const ResponseUserInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseUserInfoCommand& default_instance();
  
  void Swap(ResponseUserInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseUserInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseUserInfoCommand& from);
  void MergeFrom(const ResponseUserInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.ea.eamobile.nfsmw.protoc.UserInfo userInfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::UserInfo& userinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* mutable_userinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* release_userinfo();
  
  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // optional string defaultHint = 3;
  inline bool has_defaulthint() const;
  inline void clear_defaulthint();
  static const int kDefaultHintFieldNumber = 3;
  inline const ::std::string& defaulthint() const;
  inline void set_defaulthint(const ::std::string& value);
  inline void set_defaulthint(const char* value);
  inline void set_defaulthint(const char* value, size_t size);
  inline ::std::string* mutable_defaulthint();
  inline ::std::string* release_defaulthint();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseUserInfoCommand)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_defaulthint();
  inline void clear_has_defaulthint();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::UserInfo* userinfo_;
  ::std::string* token_;
  ::std::string* defaulthint_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseUserInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class GhostInfo : public ::google::protobuf::Message {
 public:
  GhostInfo();
  virtual ~GhostInfo();
  
  GhostInfo(const GhostInfo& from);
  
  inline GhostInfo& operator=(const GhostInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GhostInfo& default_instance();
  
  void Swap(GhostInfo* other);
  
  // implements Message ----------------------------------------------
  
  GhostInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GhostInfo& from);
  void MergeFrom(const GhostInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required float raceTime = 2;
  inline bool has_racetime() const;
  inline void clear_racetime();
  static const int kRaceTimeFieldNumber = 2;
  inline float racetime() const;
  inline void set_racetime(float value);
  
  // required float averageSpd = 3;
  inline bool has_averagespd() const;
  inline void clear_averagespd();
  static const int kAverageSpdFieldNumber = 3;
  inline float averagespd() const;
  inline void set_averagespd(float value);
  
  // required int32 position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline ::google::protobuf::int32 position() const;
  inline void set_position(::google::protobuf::int32 value);
  
  // required int32 modeId = 5;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 5;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // required string raceEventName = 6;
  inline bool has_raceeventname() const;
  inline void clear_raceeventname();
  static const int kRaceEventNameFieldNumber = 6;
  inline const ::std::string& raceeventname() const;
  inline void set_raceeventname(const ::std::string& value);
  inline void set_raceeventname(const char* value);
  inline void set_raceeventname(const char* value, size_t size);
  inline ::std::string* mutable_raceeventname();
  inline ::std::string* release_raceeventname();
  
  // required string carID = 7;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIDFieldNumber = 7;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // required int32 carColorIndex = 8;
  inline bool has_carcolorindex() const;
  inline void clear_carcolorindex();
  static const int kCarColorIndexFieldNumber = 8;
  inline ::google::protobuf::int32 carcolorindex() const;
  inline void set_carcolorindex(::google::protobuf::int32 value);
  
  // repeated int32 carModType = 9;
  inline int carmodtype_size() const;
  inline void clear_carmodtype();
  static const int kCarModTypeFieldNumber = 9;
  inline ::google::protobuf::int32 carmodtype(int index) const;
  inline void set_carmodtype(int index, ::google::protobuf::int32 value);
  inline void add_carmodtype(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodtype() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodtype();
  
  // repeated float carModValue = 10;
  inline int carmodvalue_size() const;
  inline void clear_carmodvalue();
  static const int kCarModValueFieldNumber = 10;
  inline float carmodvalue(int index) const;
  inline void set_carmodvalue(int index, float value);
  inline void add_carmodvalue(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      carmodvalue() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_carmodvalue();
  
  // optional int32 carScore = 11;
  inline bool has_carscore() const;
  inline void clear_carscore();
  static const int kCarScoreFieldNumber = 11;
  inline ::google::protobuf::int32 carscore() const;
  inline void set_carscore(::google::protobuf::int32 value);
  
  // repeated int32 carModId = 12;
  inline int carmodid_size() const;
  inline void clear_carmodid();
  static const int kCarModIdFieldNumber = 12;
  inline ::google::protobuf::int32 carmodid(int index) const;
  inline void set_carmodid(int index, ::google::protobuf::int32 value);
  inline void add_carmodid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodid();
  
  // repeated int32 carModLevel = 13;
  inline int carmodlevel_size() const;
  inline void clear_carmodlevel();
  static const int kCarModLevelFieldNumber = 13;
  inline ::google::protobuf::int32 carmodlevel(int index) const;
  inline void set_carmodlevel(int index, ::google::protobuf::int32 value);
  inline void add_carmodlevel(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodlevel() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodlevel();
  
  // optional int32 raceResultState = 14;
  inline bool has_raceresultstate() const;
  inline void clear_raceresultstate();
  static const int kRaceResultStateFieldNumber = 14;
  inline ::google::protobuf::int32 raceresultstate() const;
  inline void set_raceresultstate(::google::protobuf::int32 value);
  
  // optional string carPrefabFile = 15;
  inline bool has_carprefabfile() const;
  inline void clear_carprefabfile();
  static const int kCarPrefabFileFieldNumber = 15;
  inline const ::std::string& carprefabfile() const;
  inline void set_carprefabfile(const ::std::string& value);
  inline void set_carprefabfile(const char* value);
  inline void set_carprefabfile(const char* value, size_t size);
  inline ::std::string* mutable_carprefabfile();
  inline ::std::string* release_carprefabfile();
  
  // optional int32 carTopSpd = 16;
  inline bool has_cartopspd() const;
  inline void clear_cartopspd();
  static const int kCarTopSpdFieldNumber = 16;
  inline ::google::protobuf::int32 cartopspd() const;
  inline void set_cartopspd(::google::protobuf::int32 value);
  
  // optional int32 carMidSpd = 17;
  inline bool has_carmidspd() const;
  inline void clear_carmidspd();
  static const int kCarMidSpdFieldNumber = 17;
  inline ::google::protobuf::int32 carmidspd() const;
  inline void set_carmidspd(::google::protobuf::int32 value);
  
  // optional float trackLength = 18;
  inline bool has_tracklength() const;
  inline void clear_tracklength();
  static const int kTrackLengthFieldNumber = 18;
  inline float tracklength() const;
  inline void set_tracklength(float value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.GhostInfo)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_racetime();
  inline void clear_has_racetime();
  inline void set_has_averagespd();
  inline void clear_has_averagespd();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_raceeventname();
  inline void clear_has_raceeventname();
  inline void set_has_carid();
  inline void clear_has_carid();
  inline void set_has_carcolorindex();
  inline void clear_has_carcolorindex();
  inline void set_has_carscore();
  inline void clear_has_carscore();
  inline void set_has_raceresultstate();
  inline void clear_has_raceresultstate();
  inline void set_has_carprefabfile();
  inline void clear_has_carprefabfile();
  inline void set_has_cartopspd();
  inline void clear_has_cartopspd();
  inline void set_has_carmidspd();
  inline void clear_has_carmidspd();
  inline void set_has_tracklength();
  inline void clear_has_tracklength();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool success_;
  float racetime_;
  float averagespd_;
  ::google::protobuf::int32 position_;
  ::std::string* raceeventname_;
  ::google::protobuf::int32 modeid_;
  ::google::protobuf::int32 carcolorindex_;
  ::std::string* carid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodtype_;
  ::google::protobuf::RepeatedField< float > carmodvalue_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodid_;
  ::google::protobuf::int32 carscore_;
  ::google::protobuf::int32 raceresultstate_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodlevel_;
  ::std::string* carprefabfile_;
  ::google::protobuf::int32 cartopspd_;
  ::google::protobuf::int32 carmidspd_;
  float tracklength_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static GhostInfo* default_instance_;
};
// -------------------------------------------------------------------

class RacerInfo : public ::google::protobuf::Message {
 public:
  RacerInfo();
  virtual ~RacerInfo();
  
  RacerInfo(const RacerInfo& from);
  
  inline RacerInfo& operator=(const RacerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RacerInfo& default_instance();
  
  void Swap(RacerInfo* other);
  
  // implements Message ----------------------------------------------
  
  RacerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RacerInfo& from);
  void MergeFrom(const RacerInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 headIndex = 2;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 2;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // optional string headUrl = 3;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 3;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // required .com.ea.eamobile.nfsmw.protoc.GhostInfo ghost = 4;
  inline bool has_ghost() const;
  inline void clear_ghost();
  static const int kGhostFieldNumber = 4;
  inline const ::com::ea::eamobile::nfsmw::protoc::GhostInfo& ghost() const;
  inline ::com::ea::eamobile::nfsmw::protoc::GhostInfo* mutable_ghost();
  inline ::com::ea::eamobile::nfsmw::protoc::GhostInfo* release_ghost();
  
  // optional int32 rpLv = 5;
  inline bool has_rplv() const;
  inline void clear_rplv();
  static const int kRpLvFieldNumber = 5;
  inline ::google::protobuf::int32 rplv() const;
  inline void set_rplv(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RacerInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_ghost();
  inline void clear_has_ghost();
  inline void set_has_rplv();
  inline void clear_has_rplv();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* headurl_;
  ::google::protobuf::int32 headindex_;
  ::google::protobuf::int32 rplv_;
  ::com::ea::eamobile::nfsmw::protoc::GhostInfo* ghost_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RacerInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestModeInfoCommand : public ::google::protobuf::Message {
 public:
  RequestModeInfoCommand();
  virtual ~RequestModeInfoCommand();
  
  RequestModeInfoCommand(const RequestModeInfoCommand& from);
  
  inline RequestModeInfoCommand& operator=(const RequestModeInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestModeInfoCommand& default_instance();
  
  void Swap(RequestModeInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestModeInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestModeInfoCommand& from);
  void MergeFrom(const RequestModeInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameMode = 1;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 1;
  inline ::google::protobuf::int32 gamemode() const;
  inline void set_gamemode(::google::protobuf::int32 value);
  
  // required int32 modeId = 2;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 2;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // required int32 raceType = 3;
  inline bool has_racetype() const;
  inline void clear_racetype();
  static const int kRaceTypeFieldNumber = 3;
  inline ::google::protobuf::int32 racetype() const;
  inline void set_racetype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestModeInfoCommand)
 private:
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_racetype();
  inline void clear_has_racetype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 gamemode_;
  ::google::protobuf::int32 modeid_;
  ::google::protobuf::int32 racetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestModeInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRacerForGhostCommand : public ::google::protobuf::Message {
 public:
  ResponseRacerForGhostCommand();
  virtual ~ResponseRacerForGhostCommand();
  
  ResponseRacerForGhostCommand(const ResponseRacerForGhostCommand& from);
  
  inline ResponseRacerForGhostCommand& operator=(const ResponseRacerForGhostCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRacerForGhostCommand& default_instance();
  
  void Swap(ResponseRacerForGhostCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseRacerForGhostCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseRacerForGhostCommand& from);
  void MergeFrom(const ResponseRacerForGhostCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RacerInfo racers = 1;
  inline int racers_size() const;
  inline void clear_racers();
  static const int kRacersFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::RacerInfo& racers(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RacerInfo* mutable_racers(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RacerInfo* add_racers();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RacerInfo >&
      racers() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RacerInfo >*
      mutable_racers();
  
  // optional int32 ghostAvergeEol = 2;
  inline bool has_ghostavergeeol() const;
  inline void clear_ghostavergeeol();
  static const int kGhostAvergeEolFieldNumber = 2;
  inline ::google::protobuf::int32 ghostavergeeol() const;
  inline void set_ghostavergeeol(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseRacerForGhostCommand)
 private:
  inline void set_has_ghostavergeeol();
  inline void clear_has_ghostavergeeol();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RacerInfo > racers_;
  ::google::protobuf::int32 ghostavergeeol_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseRacerForGhostCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseModeInfoCommand : public ::google::protobuf::Message {
 public:
  ResponseModeInfoCommand();
  virtual ~ResponseModeInfoCommand();
  
  ResponseModeInfoCommand(const ResponseModeInfoCommand& from);
  
  inline ResponseModeInfoCommand& operator=(const ResponseModeInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseModeInfoCommand& default_instance();
  
  void Swap(ResponseModeInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseModeInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseModeInfoCommand& from);
  void MergeFrom(const ResponseModeInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 energyCost = 1;
  inline bool has_energycost() const;
  inline void clear_energycost();
  static const int kEnergyCostFieldNumber = 1;
  inline ::google::protobuf::int32 energycost() const;
  inline void set_energycost(::google::protobuf::int32 value);
  
  // required .com.ea.eamobile.nfsmw.protoc.Reward reward = 2;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::Reward& reward() const;
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* mutable_reward();
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* release_reward();
  
  // required string carLimitDisplayString = 3;
  inline bool has_carlimitdisplaystring() const;
  inline void clear_carlimitdisplaystring();
  static const int kCarLimitDisplayStringFieldNumber = 3;
  inline const ::std::string& carlimitdisplaystring() const;
  inline void set_carlimitdisplaystring(const ::std::string& value);
  inline void set_carlimitdisplaystring(const char* value);
  inline void set_carlimitdisplaystring(const char* value, size_t size);
  inline ::std::string* mutable_carlimitdisplaystring();
  inline ::std::string* release_carlimitdisplaystring();
  
  // repeated string acceptableCarIDs = 4;
  inline int acceptablecarids_size() const;
  inline void clear_acceptablecarids();
  static const int kAcceptableCarIDsFieldNumber = 4;
  inline const ::std::string& acceptablecarids(int index) const;
  inline ::std::string* mutable_acceptablecarids(int index);
  inline void set_acceptablecarids(int index, const ::std::string& value);
  inline void set_acceptablecarids(int index, const char* value);
  inline void set_acceptablecarids(int index, const char* value, size_t size);
  inline ::std::string* add_acceptablecarids();
  inline void add_acceptablecarids(const ::std::string& value);
  inline void add_acceptablecarids(const char* value);
  inline void add_acceptablecarids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& acceptablecarids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_acceptablecarids();
  
  // optional int32 personalRank = 5;
  inline bool has_personalrank() const;
  inline void clear_personalrank();
  static const int kPersonalRankFieldNumber = 5;
  inline ::google::protobuf::int32 personalrank() const;
  inline void set_personalrank(::google::protobuf::int32 value);
  
  // optional int32 currentEnergy = 6;
  inline bool has_currentenergy() const;
  inline void clear_currentenergy();
  static const int kCurrentEnergyFieldNumber = 6;
  inline ::google::protobuf::int32 currentenergy() const;
  inline void set_currentenergy(::google::protobuf::int32 value);
  
  // optional float personalBestTime = 7;
  inline bool has_personalbesttime() const;
  inline void clear_personalbesttime();
  static const int kPersonalBestTimeFieldNumber = 7;
  inline float personalbesttime() const;
  inline void set_personalbesttime(float value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 8;
  inline int friendleaderboard_size() const;
  inline void clear_friendleaderboard();
  static const int kFriendLeaderboardFieldNumber = 8;
  inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& friendleaderboard(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* mutable_friendleaderboard(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* add_friendleaderboard();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
      friendleaderboard() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
      mutable_friendleaderboard();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Reward rewards = 9;
  inline int rewards_size() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 9;
  inline const ::com::ea::eamobile::nfsmw::protoc::Reward& rewards(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* mutable_rewards(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* add_rewards();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward >&
      rewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward >*
      mutable_rewards();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.LeaderboardProfile friendLeaderboard2 = 10;
  inline int friendleaderboard2_size() const;
  inline void clear_friendleaderboard2();
  static const int kFriendLeaderboard2FieldNumber = 10;
  inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile& friendleaderboard2(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile* mutable_friendleaderboard2(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile* add_friendleaderboard2();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile >&
      friendleaderboard2() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile >*
      mutable_friendleaderboard2();
  
  // optional int64 userId = 11;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 11;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseModeInfoCommand)
 private:
  inline void set_has_energycost();
  inline void clear_has_energycost();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_carlimitdisplaystring();
  inline void clear_has_carlimitdisplaystring();
  inline void set_has_personalrank();
  inline void clear_has_personalrank();
  inline void set_has_currentenergy();
  inline void clear_has_currentenergy();
  inline void set_has_personalbesttime();
  inline void clear_has_personalbesttime();
  inline void set_has_userid();
  inline void clear_has_userid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::Reward* reward_;
  ::std::string* carlimitdisplaystring_;
  ::google::protobuf::int32 energycost_;
  ::google::protobuf::int32 personalrank_;
  ::google::protobuf::RepeatedPtrField< ::std::string> acceptablecarids_;
  ::google::protobuf::int32 currentenergy_;
  float personalbesttime_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard > friendleaderboard_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward > rewards_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile > friendleaderboard2_;
  ::google::protobuf::int64 userid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseModeInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestRaceResultCommand : public ::google::protobuf::Message {
 public:
  RequestRaceResultCommand();
  virtual ~RequestRaceResultCommand();
  
  RequestRaceResultCommand(const RequestRaceResultCommand& from);
  
  inline RequestRaceResultCommand& operator=(const RequestRaceResultCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRaceResultCommand& default_instance();
  
  void Swap(RequestRaceResultCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestRaceResultCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRaceResultCommand& from);
  void MergeFrom(const RequestRaceResultCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 gameMode = 1;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 1;
  inline ::google::protobuf::int32 gamemode() const;
  inline void set_gamemode(::google::protobuf::int32 value);
  
  // required string trackId = 2;
  inline bool has_trackid() const;
  inline void clear_trackid();
  static const int kTrackIdFieldNumber = 2;
  inline const ::std::string& trackid() const;
  inline void set_trackid(const ::std::string& value);
  inline void set_trackid(const char* value);
  inline void set_trackid(const char* value, size_t size);
  inline ::std::string* mutable_trackid();
  inline ::std::string* release_trackid();
  
  // required int32 modeId = 3;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 3;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // required int32 rank = 4;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 4;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // required .com.ea.eamobile.nfsmw.protoc.GhostInfo ghosts = 5;
  inline bool has_ghosts() const;
  inline void clear_ghosts();
  static const int kGhostsFieldNumber = 5;
  inline const ::com::ea::eamobile::nfsmw::protoc::GhostInfo& ghosts() const;
  inline ::com::ea::eamobile::nfsmw::protoc::GhostInfo* mutable_ghosts();
  inline ::com::ea::eamobile::nfsmw::protoc::GhostInfo* release_ghosts();
  
  // required int32 raceType = 6;
  inline bool has_racetype() const;
  inline void clear_racetype();
  static const int kRaceTypeFieldNumber = 6;
  inline ::google::protobuf::int32 racetype() const;
  inline void set_racetype(::google::protobuf::int32 value);
  
  // optional int32 ghostAvergeEol = 7;
  inline bool has_ghostavergeeol() const;
  inline void clear_ghostavergeeol();
  static const int kGhostAvergeEolFieldNumber = 7;
  inline ::google::protobuf::int32 ghostavergeeol() const;
  inline void set_ghostavergeeol(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Prop propnum = 8;
  inline int propnum_size() const;
  inline void clear_propnum();
  static const int kPropnumFieldNumber = 8;
  inline const ::com::ea::eamobile::nfsmw::protoc::Prop& propnum(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Prop* mutable_propnum(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Prop* add_propnum();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop >&
      propnum() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop >*
      mutable_propnum();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestRaceResultCommand)
 private:
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  inline void set_has_trackid();
  inline void clear_has_trackid();
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_ghosts();
  inline void clear_has_ghosts();
  inline void set_has_racetype();
  inline void clear_has_racetype();
  inline void set_has_ghostavergeeol();
  inline void clear_has_ghostavergeeol();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* trackid_;
  ::google::protobuf::int32 gamemode_;
  ::google::protobuf::int32 modeid_;
  ::com::ea::eamobile::nfsmw::protoc::GhostInfo* ghosts_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 racetype_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop > propnum_;
  ::google::protobuf::int32 ghostavergeeol_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestRaceResultCommand* default_instance_;
};
// -------------------------------------------------------------------

class RPMessage : public ::google::protobuf::Message {
 public:
  RPMessage();
  virtual ~RPMessage();
  
  RPMessage(const RPMessage& from);
  
  inline RPMessage& operator=(const RPMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RPMessage& default_instance();
  
  void Swap(RPMessage* other);
  
  // implements Message ----------------------------------------------
  
  RPMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPMessage& from);
  void MergeFrom(const RPMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // optional string iconname = 2;
  inline bool has_iconname() const;
  inline void clear_iconname();
  static const int kIconnameFieldNumber = 2;
  inline const ::std::string& iconname() const;
  inline void set_iconname(const ::std::string& value);
  inline void set_iconname(const char* value);
  inline void set_iconname(const char* value, size_t size);
  inline ::std::string* mutable_iconname();
  inline ::std::string* release_iconname();
  
  // required string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional float percentage = 4;
  inline bool has_percentage() const;
  inline void clear_percentage();
  static const int kPercentageFieldNumber = 4;
  inline float percentage() const;
  inline void set_percentage(float value);
  
  // optional int32 currentExp = 5;
  inline bool has_currentexp() const;
  inline void clear_currentexp();
  static const int kCurrentExpFieldNumber = 5;
  inline ::google::protobuf::int32 currentexp() const;
  inline void set_currentexp(::google::protobuf::int32 value);
  
  // optional int32 minExp = 6;
  inline bool has_minexp() const;
  inline void clear_minexp();
  static const int kMinExpFieldNumber = 6;
  inline ::google::protobuf::int32 minexp() const;
  inline void set_minexp(::google::protobuf::int32 value);
  
  // optional int32 maxExp = 7;
  inline bool has_maxexp() const;
  inline void clear_maxexp();
  static const int kMaxExpFieldNumber = 7;
  inline ::google::protobuf::int32 maxexp() const;
  inline void set_maxexp(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RPMessage)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_iconname();
  inline void clear_has_iconname();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_percentage();
  inline void clear_has_percentage();
  inline void set_has_currentexp();
  inline void clear_has_currentexp();
  inline void set_has_minexp();
  inline void clear_has_minexp();
  inline void set_has_maxexp();
  inline void clear_has_maxexp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* iconname_;
  ::google::protobuf::int32 level_;
  float percentage_;
  ::std::string* title_;
  ::google::protobuf::int32 currentexp_;
  ::google::protobuf::int32 minexp_;
  ::google::protobuf::int32 maxexp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RPMessage* default_instance_;
};
// -------------------------------------------------------------------

class UnlockInfoMessage : public ::google::protobuf::Message {
 public:
  UnlockInfoMessage();
  virtual ~UnlockInfoMessage();
  
  UnlockInfoMessage(const UnlockInfoMessage& from);
  
  inline UnlockInfoMessage& operator=(const UnlockInfoMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockInfoMessage& default_instance();
  
  void Swap(UnlockInfoMessage* other);
  
  // implements Message ----------------------------------------------
  
  UnlockInfoMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnlockInfoMessage& from);
  void MergeFrom(const UnlockInfoMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 tierUnlocked = 1;
  inline bool has_tierunlocked() const;
  inline void clear_tierunlocked();
  static const int kTierUnlockedFieldNumber = 1;
  inline ::google::protobuf::int32 tierunlocked() const;
  inline void set_tierunlocked(::google::protobuf::int32 value);
  
  // optional bool isTrackUnlocked = 2;
  inline bool has_istrackunlocked() const;
  inline void clear_istrackunlocked();
  static const int kIsTrackUnlockedFieldNumber = 2;
  inline bool istrackunlocked() const;
  inline void set_istrackunlocked(bool value);
  
  // optional bool isModeUnlocked = 3;
  inline bool has_ismodeunlocked() const;
  inline void clear_ismodeunlocked();
  static const int kIsModeUnlockedFieldNumber = 3;
  inline bool ismodeunlocked() const;
  inline void set_ismodeunlocked(bool value);
  
  // repeated string unlockedCar = 4;
  inline int unlockedcar_size() const;
  inline void clear_unlockedcar();
  static const int kUnlockedCarFieldNumber = 4;
  inline const ::std::string& unlockedcar(int index) const;
  inline ::std::string* mutable_unlockedcar(int index);
  inline void set_unlockedcar(int index, const ::std::string& value);
  inline void set_unlockedcar(int index, const char* value);
  inline void set_unlockedcar(int index, const char* value, size_t size);
  inline ::std::string* add_unlockedcar();
  inline void add_unlockedcar(const ::std::string& value);
  inline void add_unlockedcar(const char* value);
  inline void add_unlockedcar(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unlockedcar() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unlockedcar();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.UnlockInfoMessage)
 private:
  inline void set_has_tierunlocked();
  inline void clear_has_tierunlocked();
  inline void set_has_istrackunlocked();
  inline void clear_has_istrackunlocked();
  inline void set_has_ismodeunlocked();
  inline void clear_has_ismodeunlocked();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 tierunlocked_;
  bool istrackunlocked_;
  bool ismodeunlocked_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unlockedcar_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static UnlockInfoMessage* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRaceResultCommand : public ::google::protobuf::Message {
 public:
  ResponseRaceResultCommand();
  virtual ~ResponseRaceResultCommand();
  
  ResponseRaceResultCommand(const ResponseRaceResultCommand& from);
  
  inline ResponseRaceResultCommand& operator=(const ResponseRaceResultCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRaceResultCommand& default_instance();
  
  void Swap(ResponseRaceResultCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseRaceResultCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseRaceResultCommand& from);
  void MergeFrom(const ResponseRaceResultCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 trackFinishRatio = 1;
  inline bool has_trackfinishratio() const;
  inline void clear_trackfinishratio();
  static const int kTrackFinishRatioFieldNumber = 1;
  inline ::google::protobuf::int32 trackfinishratio() const;
  inline void set_trackfinishratio(::google::protobuf::int32 value);
  
  // required int32 modeFinishRatio = 2;
  inline bool has_modefinishratio() const;
  inline void clear_modefinishratio();
  static const int kModeFinishRatioFieldNumber = 2;
  inline ::google::protobuf::int32 modefinishratio() const;
  inline void set_modefinishratio(::google::protobuf::int32 value);
  
  // required int32 gainMostWantedNum = 3;
  inline bool has_gainmostwantednum() const;
  inline void clear_gainmostwantednum();
  static const int kGainMostWantedNumFieldNumber = 3;
  inline ::google::protobuf::int32 gainmostwantednum() const;
  inline void set_gainmostwantednum(::google::protobuf::int32 value);
  
  // repeated string unlockTracks = 4;
  inline int unlocktracks_size() const;
  inline void clear_unlocktracks();
  static const int kUnlockTracksFieldNumber = 4;
  inline const ::std::string& unlocktracks(int index) const;
  inline ::std::string* mutable_unlocktracks(int index);
  inline void set_unlocktracks(int index, const ::std::string& value);
  inline void set_unlocktracks(int index, const char* value);
  inline void set_unlocktracks(int index, const char* value, size_t size);
  inline ::std::string* add_unlocktracks();
  inline void add_unlocktracks(const ::std::string& value);
  inline void add_unlocktracks(const char* value);
  inline void add_unlocktracks(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& unlocktracks() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_unlocktracks();
  
  // repeated int32 unlockModes = 5;
  inline int unlockmodes_size() const;
  inline void clear_unlockmodes();
  static const int kUnlockModesFieldNumber = 5;
  inline ::google::protobuf::int32 unlockmodes(int index) const;
  inline void set_unlockmodes(int index, ::google::protobuf::int32 value);
  inline void add_unlockmodes(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      unlockmodes() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_unlockmodes();
  
  // optional .com.ea.eamobile.nfsmw.protoc.Reward rewards = 6;
  inline bool has_rewards() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 6;
  inline const ::com::ea::eamobile::nfsmw::protoc::Reward& rewards() const;
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* mutable_rewards();
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* release_rewards();
  
  // optional bool isNewRecord = 7;
  inline bool has_isnewrecord() const;
  inline void clear_isnewrecord();
  static const int kIsNewRecordFieldNumber = 7;
  inline bool isnewrecord() const;
  inline void set_isnewrecord(bool value);
  
  // optional int32 newRank = 8;
  inline bool has_newrank() const;
  inline void clear_newrank();
  static const int kNewRankFieldNumber = 8;
  inline ::google::protobuf::int32 newrank() const;
  inline void set_newrank(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard leaderBoard = 9;
  inline int leaderboard_size() const;
  inline void clear_leaderboard();
  static const int kLeaderBoardFieldNumber = 9;
  inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& leaderboard(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* mutable_leaderboard(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* add_leaderboard();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
      leaderboard() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
      mutable_leaderboard();
  
  // optional .com.ea.eamobile.nfsmw.protoc.TierInfo tier = 10;
  inline bool has_tier() const;
  inline void clear_tier();
  static const int kTierFieldNumber = 10;
  inline const ::com::ea::eamobile::nfsmw::protoc::TierInfo& tier() const;
  inline ::com::ea::eamobile::nfsmw::protoc::TierInfo* mutable_tier();
  inline ::com::ea::eamobile::nfsmw::protoc::TierInfo* release_tier();
  
  // optional float personalBestTime = 11;
  inline bool has_personalbesttime() const;
  inline void clear_personalbesttime();
  static const int kPersonalBestTimeFieldNumber = 11;
  inline float personalbesttime() const;
  inline void set_personalbesttime(float value);
  
  // optional int32 bestRank = 12;
  inline bool has_bestrank() const;
  inline void clear_bestrank();
  static const int kBestRankFieldNumber = 12;
  inline ::google::protobuf::int32 bestrank() const;
  inline void set_bestrank(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RPMessage rpmessages = 13;
  inline int rpmessages_size() const;
  inline void clear_rpmessages();
  static const int kRpmessagesFieldNumber = 13;
  inline const ::com::ea::eamobile::nfsmw::protoc::RPMessage& rpmessages(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* mutable_rpmessages(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* add_rpmessages();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage >&
      rpmessages() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage >*
      mutable_rpmessages();
  
  // optional .com.ea.eamobile.nfsmw.protoc.UnlockInfoMessage unlockInfo = 14;
  inline bool has_unlockinfo() const;
  inline void clear_unlockinfo();
  static const int kUnlockInfoFieldNumber = 14;
  inline const ::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage& unlockinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage* mutable_unlockinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage* release_unlockinfo();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 15;
  inline int friendleaderboard_size() const;
  inline void clear_friendleaderboard();
  static const int kFriendLeaderboardFieldNumber = 15;
  inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& friendleaderboard(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* mutable_friendleaderboard(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* add_friendleaderboard();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
      friendleaderboard() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
      mutable_friendleaderboard();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseRaceResultCommand)
 private:
  inline void set_has_trackfinishratio();
  inline void clear_has_trackfinishratio();
  inline void set_has_modefinishratio();
  inline void clear_has_modefinishratio();
  inline void set_has_gainmostwantednum();
  inline void clear_has_gainmostwantednum();
  inline void set_has_rewards();
  inline void clear_has_rewards();
  inline void set_has_isnewrecord();
  inline void clear_has_isnewrecord();
  inline void set_has_newrank();
  inline void clear_has_newrank();
  inline void set_has_tier();
  inline void clear_has_tier();
  inline void set_has_personalbesttime();
  inline void clear_has_personalbesttime();
  inline void set_has_bestrank();
  inline void clear_has_bestrank();
  inline void set_has_unlockinfo();
  inline void clear_has_unlockinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 trackfinishratio_;
  ::google::protobuf::int32 modefinishratio_;
  ::google::protobuf::RepeatedPtrField< ::std::string> unlocktracks_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > unlockmodes_;
  ::google::protobuf::int32 gainmostwantednum_;
  bool isnewrecord_;
  ::com::ea::eamobile::nfsmw::protoc::Reward* rewards_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard > leaderboard_;
  ::google::protobuf::int32 newrank_;
  float personalbesttime_;
  ::com::ea::eamobile::nfsmw::protoc::TierInfo* tier_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage > rpmessages_;
  ::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage* unlockinfo_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard > friendleaderboard_;
  ::google::protobuf::int32 bestrank_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseRaceResultCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTournamentRaceResultCommand : public ::google::protobuf::Message {
 public:
  ResponseTournamentRaceResultCommand();
  virtual ~ResponseTournamentRaceResultCommand();
  
  ResponseTournamentRaceResultCommand(const ResponseTournamentRaceResultCommand& from);
  
  inline ResponseTournamentRaceResultCommand& operator=(const ResponseTournamentRaceResultCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTournamentRaceResultCommand& default_instance();
  
  void Swap(ResponseTournamentRaceResultCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTournamentRaceResultCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTournamentRaceResultCommand& from);
  void MergeFrom(const ResponseTournamentRaceResultCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .com.ea.eamobile.nfsmw.protoc.Reward rewards = 6;
  inline bool has_rewards() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 6;
  inline const ::com::ea::eamobile::nfsmw::protoc::Reward& rewards() const;
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* mutable_rewards();
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* release_rewards();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RPMessage rpmessages = 13;
  inline int rpmessages_size() const;
  inline void clear_rpmessages();
  static const int kRpmessagesFieldNumber = 13;
  inline const ::com::ea::eamobile::nfsmw::protoc::RPMessage& rpmessages(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* mutable_rpmessages(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* add_rpmessages();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage >&
      rpmessages() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage >*
      mutable_rpmessages();
  
  // optional float tournamentRemainTime = 15;
  inline bool has_tournamentremaintime() const;
  inline void clear_tournamentremaintime();
  static const int kTournamentRemainTimeFieldNumber = 15;
  inline float tournamentremaintime() const;
  inline void set_tournamentremaintime(float value);
  
  // optional int32 tournamentLeftTimes = 16;
  inline bool has_tournamentlefttimes() const;
  inline void clear_tournamentlefttimes();
  static const int kTournamentLeftTimesFieldNumber = 16;
  inline ::google::protobuf::int32 tournamentlefttimes() const;
  inline void set_tournamentlefttimes(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard board = 17;
  inline int board_size() const;
  inline void clear_board();
  static const int kBoardFieldNumber = 17;
  inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& board(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* mutable_board(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* add_board();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
      board() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
      mutable_board();
  
  // required int32 selfRank = 18;
  inline bool has_selfrank() const;
  inline void clear_selfrank();
  static const int kSelfRankFieldNumber = 18;
  inline ::google::protobuf::int32 selfrank() const;
  inline void set_selfrank(::google::protobuf::int32 value);
  
  // required string selfName = 19;
  inline bool has_selfname() const;
  inline void clear_selfname();
  static const int kSelfNameFieldNumber = 19;
  inline const ::std::string& selfname() const;
  inline void set_selfname(const ::std::string& value);
  inline void set_selfname(const char* value);
  inline void set_selfname(const char* value, size_t size);
  inline ::std::string* mutable_selfname();
  inline ::std::string* release_selfname();
  
  // required float selfRaceResult = 20;
  inline bool has_selfraceresult() const;
  inline void clear_selfraceresult();
  static const int kSelfRaceResultFieldNumber = 20;
  inline float selfraceresult() const;
  inline void set_selfraceresult(float value);
  
  // optional int32 upRank = 21;
  inline bool has_uprank() const;
  inline void clear_uprank();
  static const int kUpRankFieldNumber = 21;
  inline ::google::protobuf::int32 uprank() const;
  inline void set_uprank(::google::protobuf::int32 value);
  
  // optional bool isNewRecode = 22;
  inline bool has_isnewrecode() const;
  inline void clear_isnewrecode();
  static const int kIsNewRecodeFieldNumber = 22;
  inline bool isnewrecode() const;
  inline void set_isnewrecode(bool value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 23;
  inline int friendleaderboard_size() const;
  inline void clear_friendleaderboard();
  static const int kFriendLeaderboardFieldNumber = 23;
  inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& friendleaderboard(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* mutable_friendleaderboard(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* add_friendleaderboard();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
      friendleaderboard() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
      mutable_friendleaderboard();
  
  // optional int32 tournamentOnlineId = 24;
  inline bool has_tournamentonlineid() const;
  inline void clear_tournamentonlineid();
  static const int kTournamentOnlineIdFieldNumber = 24;
  inline ::google::protobuf::int32 tournamentonlineid() const;
  inline void set_tournamentonlineid(::google::protobuf::int32 value);
  
  // optional bool isTournamentOnlineFinish = 25;
  inline bool has_istournamentonlinefinish() const;
  inline void clear_istournamentonlinefinish();
  static const int kIsTournamentOnlineFinishFieldNumber = 25;
  inline bool istournamentonlinefinish() const;
  inline void set_istournamentonlinefinish(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTournamentRaceResultCommand)
 private:
  inline void set_has_rewards();
  inline void clear_has_rewards();
  inline void set_has_tournamentremaintime();
  inline void clear_has_tournamentremaintime();
  inline void set_has_tournamentlefttimes();
  inline void clear_has_tournamentlefttimes();
  inline void set_has_selfrank();
  inline void clear_has_selfrank();
  inline void set_has_selfname();
  inline void clear_has_selfname();
  inline void set_has_selfraceresult();
  inline void clear_has_selfraceresult();
  inline void set_has_uprank();
  inline void clear_has_uprank();
  inline void set_has_isnewrecode();
  inline void clear_has_isnewrecode();
  inline void set_has_tournamentonlineid();
  inline void clear_has_tournamentonlineid();
  inline void set_has_istournamentonlinefinish();
  inline void clear_has_istournamentonlinefinish();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::Reward* rewards_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage > rpmessages_;
  float tournamentremaintime_;
  ::google::protobuf::int32 tournamentlefttimes_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard > board_;
  ::std::string* selfname_;
  ::google::protobuf::int32 selfrank_;
  float selfraceresult_;
  ::google::protobuf::int32 uprank_;
  bool isnewrecode_;
  bool istournamentonlinefinish_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard > friendleaderboard_;
  ::google::protobuf::int32 tournamentonlineid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTournamentRaceResultCommand* default_instance_;
};
// -------------------------------------------------------------------

class TournamentMessage : public ::google::protobuf::Message {
 public:
  TournamentMessage();
  virtual ~TournamentMessage();
  
  TournamentMessage(const TournamentMessage& from);
  
  inline TournamentMessage& operator=(const TournamentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TournamentMessage& default_instance();
  
  void Swap(TournamentMessage* other);
  
  // implements Message ----------------------------------------------
  
  TournamentMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TournamentMessage& from);
  void MergeFrom(const TournamentMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int64 startTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);
  
  // optional int64 remainTime = 4;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 4;
  inline ::google::protobuf::int64 remaintime() const;
  inline void set_remaintime(::google::protobuf::int64 value);
  
  // optional int32 signUpType = 5;
  inline bool has_signuptype() const;
  inline void clear_signuptype();
  static const int kSignUpTypeFieldNumber = 5;
  inline ::google::protobuf::int32 signuptype() const;
  inline void set_signuptype(::google::protobuf::int32 value);
  
  // optional int32 signUp = 6;
  inline bool has_signup() const;
  inline void clear_signup();
  static const int kSignUpFieldNumber = 6;
  inline ::google::protobuf::int32 signup() const;
  inline void set_signup(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.TournamentRankingListMessage rankList = 7;
  inline int ranklist_size() const;
  inline void clear_ranklist();
  static const int kRankListFieldNumber = 7;
  inline const ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage& ranklist(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage* mutable_ranklist(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage* add_ranklist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage >&
      ranklist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage >*
      mutable_ranklist();
  
  // optional int32 rankingHighLight = 13;
  inline bool has_rankinghighlight() const;
  inline void clear_rankinghighlight();
  static const int kRankingHighLightFieldNumber = 13;
  inline ::google::protobuf::int32 rankinghighlight() const;
  inline void set_rankinghighlight(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.TournamentRewardListMessage rewardList = 14;
  inline int rewardlist_size() const;
  inline void clear_rewardlist();
  static const int kRewardListFieldNumber = 14;
  inline const ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage& rewardlist(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage* mutable_rewardlist(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage* add_rewardlist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage >&
      rewardlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage >*
      mutable_rewardlist();
  
  // optional int32 leftTimes = 17;
  inline bool has_lefttimes() const;
  inline void clear_lefttimes();
  static const int kLeftTimesFieldNumber = 17;
  inline ::google::protobuf::int32 lefttimes() const;
  inline void set_lefttimes(::google::protobuf::int32 value);
  
  // required string id = 18;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 18;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  
  // required int32 energy = 22;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 22;
  inline ::google::protobuf::int32 energy() const;
  inline void set_energy(::google::protobuf::int32 value);
  
  // required int32 onlineId = 23;
  inline bool has_onlineid() const;
  inline void clear_onlineid();
  static const int kOnlineIdFieldNumber = 23;
  inline ::google::protobuf::int32 onlineid() const;
  inline void set_onlineid(::google::protobuf::int32 value);
  
  // required int32 eventId = 24;
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIdFieldNumber = 24;
  inline ::google::protobuf::int32 eventid() const;
  inline void set_eventid(::google::protobuf::int32 value);
  
  // optional int32 signUpPrice = 25;
  inline bool has_signupprice() const;
  inline void clear_signupprice();
  static const int kSignUpPriceFieldNumber = 25;
  inline ::google::protobuf::int32 signupprice() const;
  inline void set_signupprice(::google::protobuf::int32 value);
  
  // optional string backgroundPictureId = 26;
  inline bool has_backgroundpictureid() const;
  inline void clear_backgroundpictureid();
  static const int kBackgroundPictureIdFieldNumber = 26;
  inline const ::std::string& backgroundpictureid() const;
  inline void set_backgroundpictureid(const ::std::string& value);
  inline void set_backgroundpictureid(const char* value);
  inline void set_backgroundpictureid(const char* value, size_t size);
  inline ::std::string* mutable_backgroundpictureid();
  inline ::std::string* release_backgroundpictureid();
  
  // optional int32 adId = 27;
  inline bool has_adid() const;
  inline void clear_adid();
  static const int kAdIdFieldNumber = 27;
  inline ::google::protobuf::int32 adid() const;
  inline void set_adid(::google::protobuf::int32 value);
  
  // optional bool isAlreadyGetReward = 28;
  inline bool has_isalreadygetreward() const;
  inline void clear_isalreadygetreward();
  static const int kIsAlreadyGetRewardFieldNumber = 28;
  inline bool isalreadygetreward() const;
  inline void set_isalreadygetreward(bool value);
  
  // optional string tournamentGroup = 29;
  inline bool has_tournamentgroup() const;
  inline void clear_tournamentgroup();
  static const int kTournamentGroupFieldNumber = 29;
  inline const ::std::string& tournamentgroup() const;
  inline void set_tournamentgroup(const ::std::string& value);
  inline void set_tournamentgroup(const char* value);
  inline void set_tournamentgroup(const char* value, size_t size);
  inline ::std::string* mutable_tournamentgroup();
  inline ::std::string* release_tournamentgroup();
  
  // optional string tournamentCarName = 30;
  inline bool has_tournamentcarname() const;
  inline void clear_tournamentcarname();
  static const int kTournamentCarNameFieldNumber = 30;
  inline const ::std::string& tournamentcarname() const;
  inline void set_tournamentcarname(const ::std::string& value);
  inline void set_tournamentcarname(const char* value);
  inline void set_tournamentcarname(const char* value, size_t size);
  inline ::std::string* mutable_tournamentcarname();
  inline ::std::string* release_tournamentcarname();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TournamentMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_signuptype();
  inline void clear_has_signuptype();
  inline void set_has_signup();
  inline void clear_has_signup();
  inline void set_has_rankinghighlight();
  inline void clear_has_rankinghighlight();
  inline void set_has_lefttimes();
  inline void clear_has_lefttimes();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_onlineid();
  inline void clear_has_onlineid();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_signupprice();
  inline void clear_has_signupprice();
  inline void set_has_backgroundpictureid();
  inline void clear_has_backgroundpictureid();
  inline void set_has_adid();
  inline void clear_has_adid();
  inline void set_has_isalreadygetreward();
  inline void clear_has_isalreadygetreward();
  inline void set_has_tournamentgroup();
  inline void clear_has_tournamentgroup();
  inline void set_has_tournamentcarname();
  inline void clear_has_tournamentcarname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 signuptype_;
  ::google::protobuf::int64 remaintime_;
  ::google::protobuf::int32 signup_;
  ::google::protobuf::int32 rankinghighlight_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage > ranklist_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage > rewardlist_;
  ::google::protobuf::int32 lefttimes_;
  ::google::protobuf::int32 energy_;
  ::std::string* id_;
  ::google::protobuf::int32 onlineid_;
  ::google::protobuf::int32 eventid_;
  ::google::protobuf::int32 signupprice_;
  ::google::protobuf::int32 adid_;
  ::std::string* backgroundpictureid_;
  ::std::string* tournamentgroup_;
  ::std::string* tournamentcarname_;
  bool isalreadygetreward_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TournamentMessage* default_instance_;
};
// -------------------------------------------------------------------

class TournamentRankingListMessage : public ::google::protobuf::Message {
 public:
  TournamentRankingListMessage();
  virtual ~TournamentRankingListMessage();
  
  TournamentRankingListMessage(const TournamentRankingListMessage& from);
  
  inline TournamentRankingListMessage& operator=(const TournamentRankingListMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TournamentRankingListMessage& default_instance();
  
  void Swap(TournamentRankingListMessage* other);
  
  // implements Message ----------------------------------------------
  
  TournamentRankingListMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TournamentRankingListMessage& from);
  void MergeFrom(const TournamentRankingListMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline const ::std::string& rank() const;
  inline void set_rank(const ::std::string& value);
  inline void set_rank(const char* value);
  inline void set_rank(const char* value, size_t size);
  inline ::std::string* mutable_rank();
  inline ::std::string* release_rank();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TournamentRankingListMessage)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* rank_;
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TournamentRankingListMessage* default_instance_;
};
// -------------------------------------------------------------------

class TournamentRewardListMessage : public ::google::protobuf::Message {
 public:
  TournamentRewardListMessage();
  virtual ~TournamentRewardListMessage();
  
  TournamentRewardListMessage(const TournamentRewardListMessage& from);
  
  inline TournamentRewardListMessage& operator=(const TournamentRewardListMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TournamentRewardListMessage& default_instance();
  
  void Swap(TournamentRewardListMessage* other);
  
  // implements Message ----------------------------------------------
  
  TournamentRewardListMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TournamentRewardListMessage& from);
  void MergeFrom(const TournamentRewardListMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string num = 1;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 1;
  inline const ::std::string& num() const;
  inline void set_num(const ::std::string& value);
  inline void set_num(const char* value);
  inline void set_num(const char* value, size_t size);
  inline ::std::string* mutable_num();
  inline ::std::string* release_num();
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TournamentRewardListMessage)
 private:
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* num_;
  ::std::string* name_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TournamentRewardListMessage* default_instance_;
};
// -------------------------------------------------------------------

class TournamentRewardDetailMessage : public ::google::protobuf::Message {
 public:
  TournamentRewardDetailMessage();
  virtual ~TournamentRewardDetailMessage();
  
  TournamentRewardDetailMessage(const TournamentRewardDetailMessage& from);
  
  inline TournamentRewardDetailMessage& operator=(const TournamentRewardDetailMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TournamentRewardDetailMessage& default_instance();
  
  void Swap(TournamentRewardDetailMessage* other);
  
  // implements Message ----------------------------------------------
  
  TournamentRewardDetailMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TournamentRewardDetailMessage& from);
  void MergeFrom(const TournamentRewardDetailMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required float raceTime = 3;
  inline bool has_racetime() const;
  inline void clear_racetime();
  static const int kRaceTimeFieldNumber = 3;
  inline float racetime() const;
  inline void set_racetime(float value);
  
  // required string reward = 4;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 4;
  inline const ::std::string& reward() const;
  inline void set_reward(const ::std::string& value);
  inline void set_reward(const char* value);
  inline void set_reward(const char* value, size_t size);
  inline ::std::string* mutable_reward();
  inline ::std::string* release_reward();
  
  // required int32 headIndex = 5;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 5;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // optional string headUrl = 6;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 6;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // optional string displayName = 7;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 7;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TournamentRewardDetailMessage)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_racetime();
  inline void clear_has_racetime();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 rank_;
  float racetime_;
  ::std::string* reward_;
  ::std::string* headurl_;
  ::std::string* displayname_;
  ::google::protobuf::int32 headindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TournamentRewardDetailMessage* default_instance_;
};
// -------------------------------------------------------------------

class TournamentDetailMessage : public ::google::protobuf::Message {
 public:
  TournamentDetailMessage();
  virtual ~TournamentDetailMessage();
  
  TournamentDetailMessage(const TournamentDetailMessage& from);
  
  inline TournamentDetailMessage& operator=(const TournamentDetailMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TournamentDetailMessage& default_instance();
  
  void Swap(TournamentDetailMessage* other);
  
  // implements Message ----------------------------------------------
  
  TournamentDetailMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TournamentDetailMessage& from);
  void MergeFrom(const TournamentDetailMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required float raceTime = 3;
  inline bool has_racetime() const;
  inline void clear_racetime();
  static const int kRaceTimeFieldNumber = 3;
  inline float racetime() const;
  inline void set_racetime(float value);
  
  // required int32 headIndex = 4;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 4;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // optional string headUrl = 5;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 5;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // optional int64 userId = 6;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 6;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TournamentDetailMessage)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_racetime();
  inline void clear_has_racetime();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_userid();
  inline void clear_has_userid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 rank_;
  float racetime_;
  ::std::string* headurl_;
  ::google::protobuf::int64 userid_;
  ::google::protobuf::int32 headindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TournamentDetailMessage* default_instance_;
};
// -------------------------------------------------------------------

class TournamentDetailRewardMessage : public ::google::protobuf::Message {
 public:
  TournamentDetailRewardMessage();
  virtual ~TournamentDetailRewardMessage();
  
  TournamentDetailRewardMessage(const TournamentDetailRewardMessage& from);
  
  inline TournamentDetailRewardMessage& operator=(const TournamentDetailRewardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TournamentDetailRewardMessage& default_instance();
  
  void Swap(TournamentDetailRewardMessage* other);
  
  // implements Message ----------------------------------------------
  
  TournamentDetailRewardMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TournamentDetailRewardMessage& from);
  void MergeFrom(const TournamentDetailRewardMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  
  // optional string money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // optional string rmb = 3;
  inline bool has_rmb() const;
  inline void clear_rmb();
  static const int kRmbFieldNumber = 3;
  inline const ::std::string& rmb() const;
  inline void set_rmb(const ::std::string& value);
  inline void set_rmb(const char* value);
  inline void set_rmb(const char* value, size_t size);
  inline ::std::string* mutable_rmb();
  inline ::std::string* release_rmb();
  
  // optional string displayName = 4;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 4;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TournamentDetailRewardMessage)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_rmb();
  inline void clear_has_rmb();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* title_;
  ::std::string* money_;
  ::std::string* rmb_;
  ::std::string* displayname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TournamentDetailRewardMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestTournamentCommand : public ::google::protobuf::Message {
 public:
  RequestTournamentCommand();
  virtual ~RequestTournamentCommand();
  
  RequestTournamentCommand(const RequestTournamentCommand& from);
  
  inline RequestTournamentCommand& operator=(const RequestTournamentCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestTournamentCommand& default_instance();
  
  void Swap(RequestTournamentCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestTournamentCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestTournamentCommand& from);
  void MergeFrom(const RequestTournamentCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestTournamentCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestTournamentCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTournamentCommand : public ::google::protobuf::Message {
 public:
  ResponseTournamentCommand();
  virtual ~ResponseTournamentCommand();
  
  ResponseTournamentCommand(const ResponseTournamentCommand& from);
  
  inline ResponseTournamentCommand& operator=(const ResponseTournamentCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTournamentCommand& default_instance();
  
  void Swap(ResponseTournamentCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTournamentCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTournamentCommand& from);
  void MergeFrom(const ResponseTournamentCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.TournamentMessage tournament = 1;
  inline int tournament_size() const;
  inline void clear_tournament();
  static const int kTournamentFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::TournamentMessage& tournament(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentMessage* mutable_tournament(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentMessage* add_tournament();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentMessage >&
      tournament() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentMessage >*
      mutable_tournament();
  
  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTournamentCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentMessage > tournament_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTournamentCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestTournamentRewardDetailCommand : public ::google::protobuf::Message {
 public:
  RequestTournamentRewardDetailCommand();
  virtual ~RequestTournamentRewardDetailCommand();
  
  RequestTournamentRewardDetailCommand(const RequestTournamentRewardDetailCommand& from);
  
  inline RequestTournamentRewardDetailCommand& operator=(const RequestTournamentRewardDetailCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestTournamentRewardDetailCommand& default_instance();
  
  void Swap(RequestTournamentRewardDetailCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestTournamentRewardDetailCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestTournamentRewardDetailCommand& from);
  void MergeFrom(const RequestTournamentRewardDetailCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 tournamentOnlineId = 2;
  inline bool has_tournamentonlineid() const;
  inline void clear_tournamentonlineid();
  static const int kTournamentOnlineIdFieldNumber = 2;
  inline ::google::protobuf::int32 tournamentonlineid() const;
  inline void set_tournamentonlineid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestTournamentRewardDetailCommand)
 private:
  inline void set_has_tournamentonlineid();
  inline void clear_has_tournamentonlineid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 tournamentonlineid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestTournamentRewardDetailCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTournamentRewardDetailCommand : public ::google::protobuf::Message {
 public:
  ResponseTournamentRewardDetailCommand();
  virtual ~ResponseTournamentRewardDetailCommand();
  
  ResponseTournamentRewardDetailCommand(const ResponseTournamentRewardDetailCommand& from);
  
  inline ResponseTournamentRewardDetailCommand& operator=(const ResponseTournamentRewardDetailCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTournamentRewardDetailCommand& default_instance();
  
  void Swap(ResponseTournamentRewardDetailCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTournamentRewardDetailCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTournamentRewardDetailCommand& from);
  void MergeFrom(const ResponseTournamentRewardDetailCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.TournamentRewardDetailMessage rewardDetail = 1;
  inline int rewarddetail_size() const;
  inline void clear_rewarddetail();
  static const int kRewardDetailFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage& rewarddetail(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage* mutable_rewarddetail(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage* add_rewarddetail();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage >&
      rewarddetail() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage >*
      mutable_rewarddetail();
  
  // optional int32 selfRank = 2;
  inline bool has_selfrank() const;
  inline void clear_selfrank();
  static const int kSelfRankFieldNumber = 2;
  inline ::google::protobuf::int32 selfrank() const;
  inline void set_selfrank(::google::protobuf::int32 value);
  
  // optional string selfName = 3;
  inline bool has_selfname() const;
  inline void clear_selfname();
  static const int kSelfNameFieldNumber = 3;
  inline const ::std::string& selfname() const;
  inline void set_selfname(const ::std::string& value);
  inline void set_selfname(const char* value);
  inline void set_selfname(const char* value, size_t size);
  inline ::std::string* mutable_selfname();
  inline ::std::string* release_selfname();
  
  // optional float selfRaceTime = 4;
  inline bool has_selfracetime() const;
  inline void clear_selfracetime();
  static const int kSelfRaceTimeFieldNumber = 4;
  inline float selfracetime() const;
  inline void set_selfracetime(float value);
  
  // optional string selfReward = 5;
  inline bool has_selfreward() const;
  inline void clear_selfreward();
  static const int kSelfRewardFieldNumber = 5;
  inline const ::std::string& selfreward() const;
  inline void set_selfreward(const ::std::string& value);
  inline void set_selfreward(const char* value);
  inline void set_selfreward(const char* value, size_t size);
  inline ::std::string* mutable_selfreward();
  inline ::std::string* release_selfreward();
  
  // optional int32 selfHeadIndex = 6;
  inline bool has_selfheadindex() const;
  inline void clear_selfheadindex();
  static const int kSelfHeadIndexFieldNumber = 6;
  inline ::google::protobuf::int32 selfheadindex() const;
  inline void set_selfheadindex(::google::protobuf::int32 value);
  
  // optional string selfHeadUrl = 7;
  inline bool has_selfheadurl() const;
  inline void clear_selfheadurl();
  static const int kSelfHeadUrlFieldNumber = 7;
  inline const ::std::string& selfheadurl() const;
  inline void set_selfheadurl(const ::std::string& value);
  inline void set_selfheadurl(const char* value);
  inline void set_selfheadurl(const char* value, size_t size);
  inline ::std::string* mutable_selfheadurl();
  inline ::std::string* release_selfheadurl();
  
  // required string tournamentName = 8;
  inline bool has_tournamentname() const;
  inline void clear_tournamentname();
  static const int kTournamentNameFieldNumber = 8;
  inline const ::std::string& tournamentname() const;
  inline void set_tournamentname(const ::std::string& value);
  inline void set_tournamentname(const char* value);
  inline void set_tournamentname(const char* value, size_t size);
  inline ::std::string* mutable_tournamentname();
  inline ::std::string* release_tournamentname();
  
  // optional string info = 9;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 9;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 10;
  inline int friendleaderboard_size() const;
  inline void clear_friendleaderboard();
  static const int kFriendLeaderboardFieldNumber = 10;
  inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& friendleaderboard(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* mutable_friendleaderboard(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* add_friendleaderboard();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
      friendleaderboard() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
      mutable_friendleaderboard();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTournamentRewardDetailCommand)
 private:
  inline void set_has_selfrank();
  inline void clear_has_selfrank();
  inline void set_has_selfname();
  inline void clear_has_selfname();
  inline void set_has_selfracetime();
  inline void clear_has_selfracetime();
  inline void set_has_selfreward();
  inline void clear_has_selfreward();
  inline void set_has_selfheadindex();
  inline void clear_has_selfheadindex();
  inline void set_has_selfheadurl();
  inline void clear_has_selfheadurl();
  inline void set_has_tournamentname();
  inline void clear_has_tournamentname();
  inline void set_has_info();
  inline void clear_has_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage > rewarddetail_;
  ::std::string* selfname_;
  ::google::protobuf::int32 selfrank_;
  float selfracetime_;
  ::std::string* selfreward_;
  ::std::string* selfheadurl_;
  ::std::string* tournamentname_;
  ::std::string* info_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard > friendleaderboard_;
  ::google::protobuf::int32 selfheadindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTournamentRewardDetailCommand* default_instance_;
};
// -------------------------------------------------------------------

class responseTournamentRewardCommand : public ::google::protobuf::Message {
 public:
  responseTournamentRewardCommand();
  virtual ~responseTournamentRewardCommand();
  
  responseTournamentRewardCommand(const responseTournamentRewardCommand& from);
  
  inline responseTournamentRewardCommand& operator=(const responseTournamentRewardCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const responseTournamentRewardCommand& default_instance();
  
  void Swap(responseTournamentRewardCommand* other);
  
  // implements Message ----------------------------------------------
  
  responseTournamentRewardCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const responseTournamentRewardCommand& from);
  void MergeFrom(const responseTournamentRewardCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // optional string money = 2;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 2;
  inline const ::std::string& money() const;
  inline void set_money(const ::std::string& value);
  inline void set_money(const char* value);
  inline void set_money(const char* value, size_t size);
  inline ::std::string* mutable_money();
  inline ::std::string* release_money();
  
  // optional int32 moneyIconId = 3;
  inline bool has_moneyiconid() const;
  inline void clear_moneyiconid();
  static const int kMoneyIconIdFieldNumber = 3;
  inline ::google::protobuf::int32 moneyiconid() const;
  inline void set_moneyiconid(::google::protobuf::int32 value);
  
  // optional string rmb = 4;
  inline bool has_rmb() const;
  inline void clear_rmb();
  static const int kRmbFieldNumber = 4;
  inline const ::std::string& rmb() const;
  inline void set_rmb(const ::std::string& value);
  inline void set_rmb(const char* value);
  inline void set_rmb(const char* value, size_t size);
  inline ::std::string* mutable_rmb();
  inline ::std::string* release_rmb();
  
  // optional int32 goldIconId = 5;
  inline bool has_goldiconid() const;
  inline void clear_goldiconid();
  static const int kGoldIconIdFieldNumber = 5;
  inline ::google::protobuf::int32 goldiconid() const;
  inline void set_goldiconid(::google::protobuf::int32 value);
  
  // optional string displayName = 6;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 6;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  
  // optional bool isGet = 7;
  inline bool has_isget() const;
  inline void clear_isget();
  static const int kIsGetFieldNumber = 7;
  inline bool isget() const;
  inline void set_isget(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.responseTournamentRewardCommand)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_moneyiconid();
  inline void clear_has_moneyiconid();
  inline void set_has_rmb();
  inline void clear_has_rmb();
  inline void set_has_goldiconid();
  inline void clear_has_goldiconid();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  inline void set_has_isget();
  inline void clear_has_isget();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* money_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 moneyiconid_;
  ::std::string* rmb_;
  ::std::string* displayname_;
  ::google::protobuf::int32 goldiconid_;
  bool isget_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static responseTournamentRewardCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestTournamentSignUpCommand : public ::google::protobuf::Message {
 public:
  RequestTournamentSignUpCommand();
  virtual ~RequestTournamentSignUpCommand();
  
  RequestTournamentSignUpCommand(const RequestTournamentSignUpCommand& from);
  
  inline RequestTournamentSignUpCommand& operator=(const RequestTournamentSignUpCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestTournamentSignUpCommand& default_instance();
  
  void Swap(RequestTournamentSignUpCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestTournamentSignUpCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestTournamentSignUpCommand& from);
  void MergeFrom(const RequestTournamentSignUpCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 tournamentOnlineId = 1;
  inline bool has_tournamentonlineid() const;
  inline void clear_tournamentonlineid();
  static const int kTournamentOnlineIdFieldNumber = 1;
  inline ::google::protobuf::int32 tournamentonlineid() const;
  inline void set_tournamentonlineid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestTournamentSignUpCommand)
 private:
  inline void set_has_tournamentonlineid();
  inline void clear_has_tournamentonlineid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 tournamentonlineid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestTournamentSignUpCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTournamentSignUpCommand : public ::google::protobuf::Message {
 public:
  ResponseTournamentSignUpCommand();
  virtual ~ResponseTournamentSignUpCommand();
  
  ResponseTournamentSignUpCommand(const ResponseTournamentSignUpCommand& from);
  
  inline ResponseTournamentSignUpCommand& operator=(const ResponseTournamentSignUpCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTournamentSignUpCommand& default_instance();
  
  void Swap(ResponseTournamentSignUpCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTournamentSignUpCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTournamentSignUpCommand& from);
  void MergeFrom(const ResponseTournamentSignUpCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTournamentSignUpCommand)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTournamentSignUpCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestTournamentDetailCommand : public ::google::protobuf::Message {
 public:
  RequestTournamentDetailCommand();
  virtual ~RequestTournamentDetailCommand();
  
  RequestTournamentDetailCommand(const RequestTournamentDetailCommand& from);
  
  inline RequestTournamentDetailCommand& operator=(const RequestTournamentDetailCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestTournamentDetailCommand& default_instance();
  
  void Swap(RequestTournamentDetailCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestTournamentDetailCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestTournamentDetailCommand& from);
  void MergeFrom(const RequestTournamentDetailCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 tournamentOnlineId = 2;
  inline bool has_tournamentonlineid() const;
  inline void clear_tournamentonlineid();
  static const int kTournamentOnlineIdFieldNumber = 2;
  inline ::google::protobuf::int32 tournamentonlineid() const;
  inline void set_tournamentonlineid(::google::protobuf::int32 value);
  
  // optional int32 raceType = 3;
  inline bool has_racetype() const;
  inline void clear_racetype();
  static const int kRaceTypeFieldNumber = 3;
  inline ::google::protobuf::int32 racetype() const;
  inline void set_racetype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestTournamentDetailCommand)
 private:
  inline void set_has_tournamentonlineid();
  inline void clear_has_tournamentonlineid();
  inline void set_has_racetype();
  inline void clear_has_racetype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 tournamentonlineid_;
  ::google::protobuf::int32 racetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestTournamentDetailCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTournamentDetailCommand : public ::google::protobuf::Message {
 public:
  ResponseTournamentDetailCommand();
  virtual ~ResponseTournamentDetailCommand();
  
  ResponseTournamentDetailCommand(const ResponseTournamentDetailCommand& from);
  
  inline ResponseTournamentDetailCommand& operator=(const ResponseTournamentDetailCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTournamentDetailCommand& default_instance();
  
  void Swap(ResponseTournamentDetailCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTournamentDetailCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTournamentDetailCommand& from);
  void MergeFrom(const ResponseTournamentDetailCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.TournamentDetailMessage tournamentDetail = 1;
  inline int tournamentdetail_size() const;
  inline void clear_tournamentdetail();
  static const int kTournamentDetailFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage& tournamentdetail(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage* mutable_tournamentdetail(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage* add_tournamentdetail();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage >&
      tournamentdetail() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage >*
      mutable_tournamentdetail();
  
  // optional int32 selfRank = 2;
  inline bool has_selfrank() const;
  inline void clear_selfrank();
  static const int kSelfRankFieldNumber = 2;
  inline ::google::protobuf::int32 selfrank() const;
  inline void set_selfrank(::google::protobuf::int32 value);
  
  // optional string selfName = 3;
  inline bool has_selfname() const;
  inline void clear_selfname();
  static const int kSelfNameFieldNumber = 3;
  inline const ::std::string& selfname() const;
  inline void set_selfname(const ::std::string& value);
  inline void set_selfname(const char* value);
  inline void set_selfname(const char* value, size_t size);
  inline ::std::string* mutable_selfname();
  inline ::std::string* release_selfname();
  
  // optional float selfRaceTime = 4;
  inline bool has_selfracetime() const;
  inline void clear_selfracetime();
  static const int kSelfRaceTimeFieldNumber = 4;
  inline float selfracetime() const;
  inline void set_selfracetime(float value);
  
  // optional int32 selfHeadIndex = 6;
  inline bool has_selfheadindex() const;
  inline void clear_selfheadindex();
  static const int kSelfHeadIndexFieldNumber = 6;
  inline ::google::protobuf::int32 selfheadindex() const;
  inline void set_selfheadindex(::google::protobuf::int32 value);
  
  // optional string selfHeadUrl = 7;
  inline bool has_selfheadurl() const;
  inline void clear_selfheadurl();
  static const int kSelfHeadUrlFieldNumber = 7;
  inline const ::std::string& selfheadurl() const;
  inline void set_selfheadurl(const ::std::string& value);
  inline void set_selfheadurl(const char* value);
  inline void set_selfheadurl(const char* value, size_t size);
  inline ::std::string* mutable_selfheadurl();
  inline ::std::string* release_selfheadurl();
  
  // required int32 tournamentSignUpPrice = 11;
  inline bool has_tournamentsignupprice() const;
  inline void clear_tournamentsignupprice();
  static const int kTournamentSignUpPriceFieldNumber = 11;
  inline ::google::protobuf::int32 tournamentsignupprice() const;
  inline void set_tournamentsignupprice(::google::protobuf::int32 value);
  
  // required string tournamentGroup = 12;
  inline bool has_tournamentgroup() const;
  inline void clear_tournamentgroup();
  static const int kTournamentGroupFieldNumber = 12;
  inline const ::std::string& tournamentgroup() const;
  inline void set_tournamentgroup(const ::std::string& value);
  inline void set_tournamentgroup(const char* value);
  inline void set_tournamentgroup(const char* value, size_t size);
  inline ::std::string* mutable_tournamentgroup();
  inline ::std::string* release_tournamentgroup();
  
  // required string tournamentDescription = 13;
  inline bool has_tournamentdescription() const;
  inline void clear_tournamentdescription();
  static const int kTournamentDescriptionFieldNumber = 13;
  inline const ::std::string& tournamentdescription() const;
  inline void set_tournamentdescription(const ::std::string& value);
  inline void set_tournamentdescription(const char* value);
  inline void set_tournamentdescription(const char* value, size_t size);
  inline ::std::string* mutable_tournamentdescription();
  inline ::std::string* release_tournamentdescription();
  
  // repeated string tournamentCarName = 14;
  inline int tournamentcarname_size() const;
  inline void clear_tournamentcarname();
  static const int kTournamentCarNameFieldNumber = 14;
  inline const ::std::string& tournamentcarname(int index) const;
  inline ::std::string* mutable_tournamentcarname(int index);
  inline void set_tournamentcarname(int index, const ::std::string& value);
  inline void set_tournamentcarname(int index, const char* value);
  inline void set_tournamentcarname(int index, const char* value, size_t size);
  inline ::std::string* add_tournamentcarname();
  inline void add_tournamentcarname(const ::std::string& value);
  inline void add_tournamentcarname(const char* value);
  inline void add_tournamentcarname(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tournamentcarname() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tournamentcarname();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.TournamentDetailRewardMessage detailReward = 15;
  inline int detailreward_size() const;
  inline void clear_detailreward();
  static const int kDetailRewardFieldNumber = 15;
  inline const ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage& detailreward(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage* mutable_detailreward(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage* add_detailreward();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage >&
      detailreward() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage >*
      mutable_detailreward();
  
  // required int32 ishasCar = 16;
  inline bool has_ishascar() const;
  inline void clear_ishascar();
  static const int kIshasCarFieldNumber = 16;
  inline ::google::protobuf::int32 ishascar() const;
  inline void set_ishascar(::google::protobuf::int32 value);
  
  // repeated string carIDs = 17;
  inline int carids_size() const;
  inline void clear_carids();
  static const int kCarIDsFieldNumber = 17;
  inline const ::std::string& carids(int index) const;
  inline ::std::string* mutable_carids(int index);
  inline void set_carids(int index, const ::std::string& value);
  inline void set_carids(int index, const char* value);
  inline void set_carids(int index, const char* value, size_t size);
  inline ::std::string* add_carids();
  inline void add_carids(const ::std::string& value);
  inline void add_carids(const char* value);
  inline void add_carids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& carids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_carids();
  
  // optional string hotRideCarId = 18;
  inline bool has_hotridecarid() const;
  inline void clear_hotridecarid();
  static const int kHotRideCarIdFieldNumber = 18;
  inline const ::std::string& hotridecarid() const;
  inline void set_hotridecarid(const ::std::string& value);
  inline void set_hotridecarid(const char* value);
  inline void set_hotridecarid(const char* value, size_t size);
  inline ::std::string* mutable_hotridecarid();
  inline ::std::string* release_hotridecarid();
  
  // optional bool isNotConsumable = 19;
  inline bool has_isnotconsumable() const;
  inline void clear_isnotconsumable();
  static const int kIsNotConsumableFieldNumber = 19;
  inline bool isnotconsumable() const;
  inline void set_isnotconsumable(bool value);
  
  // optional string weiboContent = 20;
  inline bool has_weibocontent() const;
  inline void clear_weibocontent();
  static const int kWeiboContentFieldNumber = 20;
  inline const ::std::string& weibocontent() const;
  inline void set_weibocontent(const ::std::string& value);
  inline void set_weibocontent(const char* value);
  inline void set_weibocontent(const char* value, size_t size);
  inline ::std::string* mutable_weibocontent();
  inline ::std::string* release_weibocontent();
  
  // optional string hint = 21;
  inline bool has_hint() const;
  inline void clear_hint();
  static const int kHintFieldNumber = 21;
  inline const ::std::string& hint() const;
  inline void set_hint(const ::std::string& value);
  inline void set_hint(const char* value);
  inline void set_hint(const char* value, size_t size);
  inline ::std::string* mutable_hint();
  inline ::std::string* release_hint();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 22;
  inline int friendleaderboard_size() const;
  inline void clear_friendleaderboard();
  static const int kFriendLeaderboardFieldNumber = 22;
  inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& friendleaderboard(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* mutable_friendleaderboard(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* add_friendleaderboard();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
      friendleaderboard() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
      mutable_friendleaderboard();
  
  // optional string startContent = 23;
  inline bool has_startcontent() const;
  inline void clear_startcontent();
  static const int kStartContentFieldNumber = 23;
  inline const ::std::string& startcontent() const;
  inline void set_startcontent(const ::std::string& value);
  inline void set_startcontent(const char* value);
  inline void set_startcontent(const char* value, size_t size);
  inline ::std::string* mutable_startcontent();
  inline ::std::string* release_startcontent();
  
  // optional string endContent = 24;
  inline bool has_endcontent() const;
  inline void clear_endcontent();
  static const int kEndContentFieldNumber = 24;
  inline const ::std::string& endcontent() const;
  inline void set_endcontent(const ::std::string& value);
  inline void set_endcontent(const char* value);
  inline void set_endcontent(const char* value, size_t size);
  inline ::std::string* mutable_endcontent();
  inline ::std::string* release_endcontent();
  
  // optional string weiboShareContent = 25;
  inline bool has_weibosharecontent() const;
  inline void clear_weibosharecontent();
  static const int kWeiboShareContentFieldNumber = 25;
  inline const ::std::string& weibosharecontent() const;
  inline void set_weibosharecontent(const ::std::string& value);
  inline void set_weibosharecontent(const char* value);
  inline void set_weibosharecontent(const char* value, size_t size);
  inline ::std::string* mutable_weibosharecontent();
  inline ::std::string* release_weibosharecontent();
  
  // optional int32 tournamentOnlineId = 26;
  inline bool has_tournamentonlineid() const;
  inline void clear_tournamentonlineid();
  static const int kTournamentOnlineIdFieldNumber = 26;
  inline ::google::protobuf::int32 tournamentonlineid() const;
  inline void set_tournamentonlineid(::google::protobuf::int32 value);
  
  // optional int32 tournamentGroupId = 27;
  inline bool has_tournamentgroupid() const;
  inline void clear_tournamentgroupid();
  static const int kTournamentGroupIdFieldNumber = 27;
  inline ::google::protobuf::int32 tournamentgroupid() const;
  inline void set_tournamentgroupid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTournamentDetailCommand)
 private:
  inline void set_has_selfrank();
  inline void clear_has_selfrank();
  inline void set_has_selfname();
  inline void clear_has_selfname();
  inline void set_has_selfracetime();
  inline void clear_has_selfracetime();
  inline void set_has_selfheadindex();
  inline void clear_has_selfheadindex();
  inline void set_has_selfheadurl();
  inline void clear_has_selfheadurl();
  inline void set_has_tournamentsignupprice();
  inline void clear_has_tournamentsignupprice();
  inline void set_has_tournamentgroup();
  inline void clear_has_tournamentgroup();
  inline void set_has_tournamentdescription();
  inline void clear_has_tournamentdescription();
  inline void set_has_ishascar();
  inline void clear_has_ishascar();
  inline void set_has_hotridecarid();
  inline void clear_has_hotridecarid();
  inline void set_has_isnotconsumable();
  inline void clear_has_isnotconsumable();
  inline void set_has_weibocontent();
  inline void clear_has_weibocontent();
  inline void set_has_hint();
  inline void clear_has_hint();
  inline void set_has_startcontent();
  inline void clear_has_startcontent();
  inline void set_has_endcontent();
  inline void clear_has_endcontent();
  inline void set_has_weibosharecontent();
  inline void clear_has_weibosharecontent();
  inline void set_has_tournamentonlineid();
  inline void clear_has_tournamentonlineid();
  inline void set_has_tournamentgroupid();
  inline void clear_has_tournamentgroupid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage > tournamentdetail_;
  ::std::string* selfname_;
  ::google::protobuf::int32 selfrank_;
  float selfracetime_;
  ::std::string* selfheadurl_;
  ::google::protobuf::int32 selfheadindex_;
  ::google::protobuf::int32 tournamentsignupprice_;
  ::std::string* tournamentgroup_;
  ::std::string* tournamentdescription_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tournamentcarname_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage > detailreward_;
  ::google::protobuf::RepeatedPtrField< ::std::string> carids_;
  ::google::protobuf::int32 ishascar_;
  bool isnotconsumable_;
  ::std::string* hotridecarid_;
  ::std::string* weibocontent_;
  ::std::string* hint_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard > friendleaderboard_;
  ::std::string* startcontent_;
  ::std::string* endcontent_;
  ::std::string* weibosharecontent_;
  ::google::protobuf::int32 tournamentonlineid_;
  ::google::protobuf::int32 tournamentgroupid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTournamentDetailCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestGetRewardCommand : public ::google::protobuf::Message {
 public:
  RequestGetRewardCommand();
  virtual ~RequestGetRewardCommand();
  
  RequestGetRewardCommand(const RequestGetRewardCommand& from);
  
  inline RequestGetRewardCommand& operator=(const RequestGetRewardCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGetRewardCommand& default_instance();
  
  void Swap(RequestGetRewardCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestGetRewardCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestGetRewardCommand& from);
  void MergeFrom(const RequestGetRewardCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 tournamentOnlineId = 2;
  inline bool has_tournamentonlineid() const;
  inline void clear_tournamentonlineid();
  static const int kTournamentOnlineIdFieldNumber = 2;
  inline ::google::protobuf::int32 tournamentonlineid() const;
  inline void set_tournamentonlineid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestGetRewardCommand)
 private:
  inline void set_has_tournamentonlineid();
  inline void clear_has_tournamentonlineid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 tournamentonlineid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestGetRewardCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGetRewardCommand : public ::google::protobuf::Message {
 public:
  ResponseGetRewardCommand();
  virtual ~ResponseGetRewardCommand();
  
  ResponseGetRewardCommand(const ResponseGetRewardCommand& from);
  
  inline ResponseGetRewardCommand& operator=(const ResponseGetRewardCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseGetRewardCommand& default_instance();
  
  void Swap(ResponseGetRewardCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseGetRewardCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseGetRewardCommand& from);
  void MergeFrom(const ResponseGetRewardCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 success = 2;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline ::google::protobuf::int32 success() const;
  inline void set_success(::google::protobuf::int32 value);
  
  // optional string errorMessage = 3;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 3;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseGetRewardCommand)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* errormessage_;
  ::google::protobuf::int32 success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseGetRewardCommand* default_instance_;
};
// -------------------------------------------------------------------

class HeadInfo : public ::google::protobuf::Message {
 public:
  HeadInfo();
  virtual ~HeadInfo();
  
  HeadInfo(const HeadInfo& from);
  
  inline HeadInfo& operator=(const HeadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeadInfo& default_instance();
  
  void Swap(HeadInfo* other);
  
  // implements Message ----------------------------------------------
  
  HeadInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeadInfo& from);
  void MergeFrom(const HeadInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);
  
  // required int64 datetime = 2;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDatetimeFieldNumber = 2;
  inline ::google::protobuf::int64 datetime() const;
  inline void set_datetime(::google::protobuf::int64 value);
  
  // required string session = 4;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 4;
  inline const ::std::string& session() const;
  inline void set_session(const ::std::string& value);
  inline void set_session(const char* value);
  inline void set_session(const char* value, size_t size);
  inline ::std::string* mutable_session();
  inline ::std::string* release_session();
  
  // required int32 gameVersion = 5;
  inline bool has_gameversion() const;
  inline void clear_gameversion();
  static const int kGameVersionFieldNumber = 5;
  inline ::google::protobuf::int32 gameversion() const;
  inline void set_gameversion(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.HeadInfo)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_gameversion();
  inline void clear_has_gameversion();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 datetime_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 gameversion_;
  ::std::string* session_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static HeadInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestRaceStartCommand : public ::google::protobuf::Message {
 public:
  RequestRaceStartCommand();
  virtual ~RequestRaceStartCommand();
  
  RequestRaceStartCommand(const RequestRaceStartCommand& from);
  
  inline RequestRaceStartCommand& operator=(const RequestRaceStartCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRaceStartCommand& default_instance();
  
  void Swap(RequestRaceStartCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestRaceStartCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRaceStartCommand& from);
  void MergeFrom(const RequestRaceStartCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 modeId = 1;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 1;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // required int32 gameMode = 2;
  inline bool has_gamemode() const;
  inline void clear_gamemode();
  static const int kGameModeFieldNumber = 2;
  inline ::google::protobuf::int32 gamemode() const;
  inline void set_gamemode(::google::protobuf::int32 value);
  
  // optional int32 raceType = 3;
  inline bool has_racetype() const;
  inline void clear_racetype();
  static const int kRaceTypeFieldNumber = 3;
  inline ::google::protobuf::int32 racetype() const;
  inline void set_racetype(::google::protobuf::int32 value);
  
  // optional int32 tournamentOnlineId = 4;
  inline bool has_tournamentonlineid() const;
  inline void clear_tournamentonlineid();
  static const int kTournamentOnlineIdFieldNumber = 4;
  inline ::google::protobuf::int32 tournamentonlineid() const;
  inline void set_tournamentonlineid(::google::protobuf::int32 value);
  
  // repeated int32 carModType = 5;
  inline int carmodtype_size() const;
  inline void clear_carmodtype();
  static const int kCarModTypeFieldNumber = 5;
  inline ::google::protobuf::int32 carmodtype(int index) const;
  inline void set_carmodtype(int index, ::google::protobuf::int32 value);
  inline void add_carmodtype(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodtype() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodtype();
  
  // repeated int32 carModSlotID = 6;
  inline int carmodslotid_size() const;
  inline void clear_carmodslotid();
  static const int kCarModSlotIDFieldNumber = 6;
  inline ::google::protobuf::int32 carmodslotid(int index) const;
  inline void set_carmodslotid(int index, ::google::protobuf::int32 value);
  inline void add_carmodslotid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodslotid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodslotid();
  
  // optional string carId = 7;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 7;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestRaceStartCommand)
 private:
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_gamemode();
  inline void clear_has_gamemode();
  inline void set_has_racetype();
  inline void clear_has_racetype();
  inline void set_has_tournamentonlineid();
  inline void clear_has_tournamentonlineid();
  inline void set_has_carid();
  inline void clear_has_carid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 modeid_;
  ::google::protobuf::int32 gamemode_;
  ::google::protobuf::int32 racetype_;
  ::google::protobuf::int32 tournamentonlineid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodtype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodslotid_;
  ::std::string* carid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestRaceStartCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRaceStartCommand : public ::google::protobuf::Message {
 public:
  ResponseRaceStartCommand();
  virtual ~ResponseRaceStartCommand();
  
  ResponseRaceStartCommand(const ResponseRaceStartCommand& from);
  
  inline ResponseRaceStartCommand& operator=(const ResponseRaceStartCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRaceStartCommand& default_instance();
  
  void Swap(ResponseRaceStartCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseRaceStartCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseRaceStartCommand& from);
  void MergeFrom(const ResponseRaceStartCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool approved = 1;
  inline bool has_approved() const;
  inline void clear_approved();
  static const int kApprovedFieldNumber = 1;
  inline bool approved() const;
  inline void set_approved(bool value);
  
  // optional int64 stamina = 2;
  inline bool has_stamina() const;
  inline void clear_stamina();
  static const int kStaminaFieldNumber = 2;
  inline ::google::protobuf::int64 stamina() const;
  inline void set_stamina(::google::protobuf::int64 value);
  
  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional string hint = 4;
  inline bool has_hint() const;
  inline void clear_hint();
  static const int kHintFieldNumber = 4;
  inline const ::std::string& hint() const;
  inline void set_hint(const ::std::string& value);
  inline void set_hint(const char* value);
  inline void set_hint(const char* value, size_t size);
  inline ::std::string* mutable_hint();
  inline ::std::string* release_hint();
  
  // optional int32 samplePeriod = 5;
  inline bool has_sampleperiod() const;
  inline void clear_sampleperiod();
  static const int kSamplePeriodFieldNumber = 5;
  inline ::google::protobuf::int32 sampleperiod() const;
  inline void set_sampleperiod(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseRaceStartCommand)
 private:
  inline void set_has_approved();
  inline void clear_has_approved();
  inline void set_has_stamina();
  inline void clear_has_stamina();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_hint();
  inline void clear_has_hint();
  inline void set_has_sampleperiod();
  inline void clear_has_sampleperiod();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 stamina_;
  bool approved_;
  ::google::protobuf::int32 status_;
  ::std::string* hint_;
  ::google::protobuf::int32 sampleperiod_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseRaceStartCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTournamentRaceStartCommand : public ::google::protobuf::Message {
 public:
  ResponseTournamentRaceStartCommand();
  virtual ~ResponseTournamentRaceStartCommand();
  
  ResponseTournamentRaceStartCommand(const ResponseTournamentRaceStartCommand& from);
  
  inline ResponseTournamentRaceStartCommand& operator=(const ResponseTournamentRaceStartCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTournamentRaceStartCommand& default_instance();
  
  void Swap(ResponseTournamentRaceStartCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTournamentRaceStartCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTournamentRaceStartCommand& from);
  void MergeFrom(const ResponseTournamentRaceStartCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string trackName = 1;
  inline bool has_trackname() const;
  inline void clear_trackname();
  static const int kTrackNameFieldNumber = 1;
  inline const ::std::string& trackname() const;
  inline void set_trackname(const ::std::string& value);
  inline void set_trackname(const char* value);
  inline void set_trackname(const char* value, size_t size);
  inline ::std::string* mutable_trackname();
  inline ::std::string* release_trackname();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.Reward reward = 2;
  inline int reward_size() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::Reward& reward(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* mutable_reward(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* add_reward();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward >&
      reward() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward >*
      mutable_reward();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.TournamentDetailRewardMessage detailReward = 3;
  inline int detailreward_size() const;
  inline void clear_detailreward();
  static const int kDetailRewardFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage& detailreward(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage* mutable_detailreward(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage* add_detailreward();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage >&
      detailreward() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage >*
      mutable_detailreward();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTournamentRaceStartCommand)
 private:
  inline void set_has_trackname();
  inline void clear_has_trackname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* trackname_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward > reward_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage > detailreward_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTournamentRaceStartCommand* default_instance_;
};
// -------------------------------------------------------------------

class AccountInfo : public ::google::protobuf::Message {
 public:
  AccountInfo();
  virtual ~AccountInfo();
  
  AccountInfo(const AccountInfo& from);
  
  inline AccountInfo& operator=(const AccountInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountInfo& default_instance();
  
  void Swap(AccountInfo* other);
  
  // implements Message ----------------------------------------------
  
  AccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountInfo& from);
  void MergeFrom(const AccountInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string headUrl = 3;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 3;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // optional bool isExpired = 4;
  inline bool has_isexpired() const;
  inline void clear_isexpired();
  static const int kIsExpiredFieldNumber = 4;
  inline bool isexpired() const;
  inline void set_isexpired(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.AccountInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_isexpired();
  inline void clear_has_isexpired();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 type_;
  bool isexpired_;
  ::std::string* headurl_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static AccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestBindingStartCommand : public ::google::protobuf::Message {
 public:
  RequestBindingStartCommand();
  virtual ~RequestBindingStartCommand();
  
  RequestBindingStartCommand(const RequestBindingStartCommand& from);
  
  inline RequestBindingStartCommand& operator=(const RequestBindingStartCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBindingStartCommand& default_instance();
  
  void Swap(RequestBindingStartCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestBindingStartCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestBindingStartCommand& from);
  void MergeFrom(const RequestBindingStartCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestBindingStartCommand)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* token_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestBindingStartCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBindingStartCommand : public ::google::protobuf::Message {
 public:
  ResponseBindingStartCommand();
  virtual ~ResponseBindingStartCommand();
  
  ResponseBindingStartCommand(const ResponseBindingStartCommand& from);
  
  inline ResponseBindingStartCommand& operator=(const ResponseBindingStartCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBindingStartCommand& default_instance();
  
  void Swap(ResponseBindingStartCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseBindingStartCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseBindingStartCommand& from);
  void MergeFrom(const ResponseBindingStartCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string authUrl = 1;
  inline bool has_authurl() const;
  inline void clear_authurl();
  static const int kAuthUrlFieldNumber = 1;
  inline const ::std::string& authurl() const;
  inline void set_authurl(const ::std::string& value);
  inline void set_authurl(const char* value);
  inline void set_authurl(const char* value, size_t size);
  inline ::std::string* mutable_authurl();
  inline ::std::string* release_authurl();
  
  // optional string closeUrl = 2;
  inline bool has_closeurl() const;
  inline void clear_closeurl();
  static const int kCloseUrlFieldNumber = 2;
  inline const ::std::string& closeurl() const;
  inline void set_closeurl(const ::std::string& value);
  inline void set_closeurl(const char* value);
  inline void set_closeurl(const char* value, size_t size);
  inline ::std::string* mutable_closeurl();
  inline ::std::string* release_closeurl();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseBindingStartCommand)
 private:
  inline void set_has_authurl();
  inline void clear_has_authurl();
  inline void set_has_closeurl();
  inline void clear_has_closeurl();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* authurl_;
  ::std::string* closeurl_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseBindingStartCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestBindingTokenCommand : public ::google::protobuf::Message {
 public:
  RequestBindingTokenCommand();
  virtual ~RequestBindingTokenCommand();
  
  RequestBindingTokenCommand(const RequestBindingTokenCommand& from);
  
  inline RequestBindingTokenCommand& operator=(const RequestBindingTokenCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBindingTokenCommand& default_instance();
  
  void Swap(RequestBindingTokenCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestBindingTokenCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestBindingTokenCommand& from);
  void MergeFrom(const RequestBindingTokenCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool isOverride = 1;
  inline bool has_isoverride() const;
  inline void clear_isoverride();
  static const int kIsOverrideFieldNumber = 1;
  inline bool isoverride() const;
  inline void set_isoverride(bool value);
  
  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // required string access_token = 3;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 3;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  
  // required string uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // optional string nickname = 5;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 5;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestBindingTokenCommand)
 private:
  inline void set_has_isoverride();
  inline void clear_has_isoverride();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* token_;
  ::std::string* access_token_;
  ::std::string* uid_;
  ::std::string* nickname_;
  bool isoverride_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestBindingTokenCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBindingTokenCommand : public ::google::protobuf::Message {
 public:
  ResponseBindingTokenCommand();
  virtual ~ResponseBindingTokenCommand();
  
  ResponseBindingTokenCommand(const ResponseBindingTokenCommand& from);
  
  inline ResponseBindingTokenCommand& operator=(const ResponseBindingTokenCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBindingTokenCommand& default_instance();
  
  void Swap(ResponseBindingTokenCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseBindingTokenCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseBindingTokenCommand& from);
  void MergeFrom(const ResponseBindingTokenCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseBindingTokenCommand)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* token_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseBindingTokenCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestBindingInfoCommand : public ::google::protobuf::Message {
 public:
  RequestBindingInfoCommand();
  virtual ~RequestBindingInfoCommand();
  
  RequestBindingInfoCommand(const RequestBindingInfoCommand& from);
  
  inline RequestBindingInfoCommand& operator=(const RequestBindingInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBindingInfoCommand& default_instance();
  
  void Swap(RequestBindingInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestBindingInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestBindingInfoCommand& from);
  void MergeFrom(const RequestBindingInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string access_token = 1;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 1;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  
  // required string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestBindingInfoCommand)
 private:
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_uid();
  inline void clear_has_uid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* access_token_;
  ::std::string* uid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestBindingInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBindingInfoCommand : public ::google::protobuf::Message {
 public:
  ResponseBindingInfoCommand();
  virtual ~ResponseBindingInfoCommand();
  
  ResponseBindingInfoCommand(const ResponseBindingInfoCommand& from);
  
  inline ResponseBindingInfoCommand& operator=(const ResponseBindingInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBindingInfoCommand& default_instance();
  
  void Swap(ResponseBindingInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseBindingInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseBindingInfoCommand& from);
  void MergeFrom(const ResponseBindingInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool isBinding = 1;
  inline bool has_isbinding() const;
  inline void clear_isbinding();
  static const int kIsBindingFieldNumber = 1;
  inline bool isbinding() const;
  inline void set_isbinding(bool value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingConfirmCommand bindingConfirmCommand = 3;
  inline bool has_bindingconfirmcommand() const;
  inline void clear_bindingconfirmcommand();
  static const int kBindingConfirmCommandFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand& bindingconfirmcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* mutable_bindingconfirmcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* release_bindingconfirmcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.UserInfo userInfo = 4;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 4;
  inline const ::com::ea::eamobile::nfsmw::protoc::UserInfo& userinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* mutable_userinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* release_userinfo();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseBindingInfoCommand)
 private:
  inline void set_has_isbinding();
  inline void clear_has_isbinding();
  inline void set_has_bindingconfirmcommand();
  inline void clear_has_bindingconfirmcommand();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* bindingconfirmcommand_;
  ::com::ea::eamobile::nfsmw::protoc::UserInfo* userinfo_;
  bool isbinding_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseBindingInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestBindingResultCommand : public ::google::protobuf::Message {
 public:
  RequestBindingResultCommand();
  virtual ~RequestBindingResultCommand();
  
  RequestBindingResultCommand(const RequestBindingResultCommand& from);
  
  inline RequestBindingResultCommand& operator=(const RequestBindingResultCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBindingResultCommand& default_instance();
  
  void Swap(RequestBindingResultCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestBindingResultCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestBindingResultCommand& from);
  void MergeFrom(const RequestBindingResultCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestBindingResultCommand)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* token_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestBindingResultCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBindingResultCommand : public ::google::protobuf::Message {
 public:
  ResponseBindingResultCommand();
  virtual ~ResponseBindingResultCommand();
  
  ResponseBindingResultCommand(const ResponseBindingResultCommand& from);
  
  inline ResponseBindingResultCommand& operator=(const ResponseBindingResultCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBindingResultCommand& default_instance();
  
  void Swap(ResponseBindingResultCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseBindingResultCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseBindingResultCommand& from);
  void MergeFrom(const ResponseBindingResultCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool isBinding = 1;
  inline bool has_isbinding() const;
  inline void clear_isbinding();
  static const int kIsBindingFieldNumber = 1;
  inline bool isbinding() const;
  inline void set_isbinding(bool value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingConfirmCommand bindingConfirmCommand = 3;
  inline bool has_bindingconfirmcommand() const;
  inline void clear_bindingconfirmcommand();
  static const int kBindingConfirmCommandFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand& bindingconfirmcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* mutable_bindingconfirmcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* release_bindingconfirmcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.UserInfo userInfo = 4;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 4;
  inline const ::com::ea::eamobile::nfsmw::protoc::UserInfo& userinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* mutable_userinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* release_userinfo();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseBindingResultCommand)
 private:
  inline void set_has_isbinding();
  inline void clear_has_isbinding();
  inline void set_has_bindingconfirmcommand();
  inline void clear_has_bindingconfirmcommand();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* bindingconfirmcommand_;
  ::com::ea::eamobile::nfsmw::protoc::UserInfo* userinfo_;
  bool isbinding_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseBindingResultCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestBindingConfirmCommand : public ::google::protobuf::Message {
 public:
  RequestBindingConfirmCommand();
  virtual ~RequestBindingConfirmCommand();
  
  RequestBindingConfirmCommand(const RequestBindingConfirmCommand& from);
  
  inline RequestBindingConfirmCommand& operator=(const RequestBindingConfirmCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBindingConfirmCommand& default_instance();
  
  void Swap(RequestBindingConfirmCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestBindingConfirmCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestBindingConfirmCommand& from);
  void MergeFrom(const RequestBindingConfirmCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool isOverride = 1;
  inline bool has_isoverride() const;
  inline void clear_isoverride();
  static const int kIsOverrideFieldNumber = 1;
  inline bool isoverride() const;
  inline void set_isoverride(bool value);
  
  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestBindingConfirmCommand)
 private:
  inline void set_has_isoverride();
  inline void clear_has_isoverride();
  inline void set_has_token();
  inline void clear_has_token();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* token_;
  bool isoverride_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestBindingConfirmCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBindingConfirmCommand : public ::google::protobuf::Message {
 public:
  ResponseBindingConfirmCommand();
  virtual ~ResponseBindingConfirmCommand();
  
  ResponseBindingConfirmCommand(const ResponseBindingConfirmCommand& from);
  
  inline ResponseBindingConfirmCommand& operator=(const ResponseBindingConfirmCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBindingConfirmCommand& default_instance();
  
  void Swap(ResponseBindingConfirmCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseBindingConfirmCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseBindingConfirmCommand& from);
  void MergeFrom(const ResponseBindingConfirmCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseBindingConfirmCommand)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* token_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseBindingConfirmCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBindingPopupCommand : public ::google::protobuf::Message {
 public:
  ResponseBindingPopupCommand();
  virtual ~ResponseBindingPopupCommand();
  
  ResponseBindingPopupCommand(const ResponseBindingPopupCommand& from);
  
  inline ResponseBindingPopupCommand& operator=(const ResponseBindingPopupCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBindingPopupCommand& default_instance();
  
  void Swap(ResponseBindingPopupCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseBindingPopupCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseBindingPopupCommand& from);
  void MergeFrom(const ResponseBindingPopupCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool isPopup = 1;
  inline bool has_ispopup() const;
  inline void clear_ispopup();
  static const int kIsPopupFieldNumber = 1;
  inline bool ispopup() const;
  inline void set_ispopup(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseBindingPopupCommand)
 private:
  inline void set_has_ispopup();
  inline void clear_has_ispopup();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool ispopup_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseBindingPopupCommand* default_instance_;
};
// -------------------------------------------------------------------

class ErrorCommand : public ::google::protobuf::Message {
 public:
  ErrorCommand();
  virtual ~ErrorCommand();
  
  ErrorCommand(const ErrorCommand& from);
  
  inline ErrorCommand& operator=(const ErrorCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorCommand& default_instance();
  
  void Swap(ErrorCommand* other);
  
  // implements Message ----------------------------------------------
  
  ErrorCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ErrorCommand& from);
  void MergeFrom(const ErrorCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ErrorCommand)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* code_;
  ::std::string* message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ErrorCommand* default_instance_;
};
// -------------------------------------------------------------------

class CarData : public ::google::protobuf::Message {
 public:
  CarData();
  virtual ~CarData();
  
  CarData(const CarData& from);
  
  inline CarData& operator=(const CarData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CarData& default_instance();
  
  void Swap(CarData* other);
  
  // implements Message ----------------------------------------------
  
  CarData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CarData& from);
  void MergeFrom(const CarData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string carId = 1;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 1;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required int32 tier = 3;
  inline bool has_tier() const;
  inline void clear_tier();
  static const int kTierFieldNumber = 3;
  inline ::google::protobuf::int32 tier() const;
  inline void set_tier(::google::protobuf::int32 value);
  
  // required int32 score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // required int32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.CarSlotInfo slots = 6;
  inline int slots_size() const;
  inline void clear_slots();
  static const int kSlotsFieldNumber = 6;
  inline const ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo& slots(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo* mutable_slots(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo* add_slots();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo >&
      slots() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo >*
      mutable_slots();
  
  // required int32 priceType = 7;
  inline bool has_pricetype() const;
  inline void clear_pricetype();
  static const int kPriceTypeFieldNumber = 7;
  inline ::google::protobuf::int32 pricetype() const;
  inline void set_pricetype(::google::protobuf::int32 value);
  
  // required int32 price = 8;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 8;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);
  
  // required int32 unlockMWLevel = 9;
  inline bool has_unlockmwlevel() const;
  inline void clear_unlockmwlevel();
  static const int kUnlockMWLevelFieldNumber = 9;
  inline ::google::protobuf::int32 unlockmwlevel() const;
  inline void set_unlockmwlevel(::google::protobuf::int32 value);
  
  // required int32 chartletId = 10;
  inline bool has_chartletid() const;
  inline void clear_chartletid();
  static const int kChartletIdFieldNumber = 10;
  inline ::google::protobuf::int32 chartletid() const;
  inline void set_chartletid(::google::protobuf::int32 value);
  
  // optional bool isLock = 11;
  inline bool has_islock() const;
  inline void clear_islock();
  static const int kIsLockFieldNumber = 11;
  inline bool islock() const;
  inline void set_islock(bool value);
  
  // optional int64 remainTime = 13;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 13;
  inline ::google::protobuf::int64 remaintime() const;
  inline void set_remaintime(::google::protobuf::int64 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.ChartletInfo chartletInfos = 14;
  inline int chartletinfos_size() const;
  inline void clear_chartletinfos();
  static const int kChartletInfosFieldNumber = 14;
  inline const ::com::ea::eamobile::nfsmw::protoc::ChartletInfo& chartletinfos(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::ChartletInfo* mutable_chartletinfos(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::ChartletInfo* add_chartletinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ChartletInfo >&
      chartletinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ChartletInfo >*
      mutable_chartletinfos();
  
  // optional int32 sellFlag = 15;
  inline bool has_sellflag() const;
  inline void clear_sellflag();
  static const int kSellFlagFieldNumber = 15;
  inline ::google::protobuf::int32 sellflag() const;
  inline void set_sellflag(::google::protobuf::int32 value);
  
  // optional bool isSpecialCar = 16;
  inline bool has_isspecialcar() const;
  inline void clear_isspecialcar();
  static const int kIsSpecialCarFieldNumber = 16;
  inline bool isspecialcar() const;
  inline void set_isspecialcar(bool value);
  
  // optional int32 fragmentNumber = 17;
  inline bool has_fragmentnumber() const;
  inline void clear_fragmentnumber();
  static const int kFragmentNumberFieldNumber = 17;
  inline ::google::protobuf::int32 fragmentnumber() const;
  inline void set_fragmentnumber(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.GotchaExpense gotchaExpense = 18;
  inline int gotchaexpense_size() const;
  inline void clear_gotchaexpense();
  static const int kGotchaExpenseFieldNumber = 18;
  inline const ::com::ea::eamobile::nfsmw::protoc::GotchaExpense& gotchaexpense(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::GotchaExpense* mutable_gotchaexpense(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::GotchaExpense* add_gotchaexpense();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaExpense >&
      gotchaexpense() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaExpense >*
      mutable_gotchaexpense();
  
  // optional int32 totalFragmentNumber = 19;
  inline bool has_totalfragmentnumber() const;
  inline void clear_totalfragmentnumber();
  static const int kTotalFragmentNumberFieldNumber = 19;
  inline ::google::protobuf::int32 totalfragmentnumber() const;
  inline void set_totalfragmentnumber(::google::protobuf::int32 value);
  
  // optional int32 remainPriceType = 20;
  inline bool has_remainpricetype() const;
  inline void clear_remainpricetype();
  static const int kRemainPriceTypeFieldNumber = 20;
  inline ::google::protobuf::int32 remainpricetype() const;
  inline void set_remainpricetype(::google::protobuf::int32 value);
  
  // optional int32 remainPrice = 21;
  inline bool has_remainprice() const;
  inline void clear_remainprice();
  static const int kRemainPriceFieldNumber = 21;
  inline ::google::protobuf::int32 remainprice() const;
  inline void set_remainprice(::google::protobuf::int32 value);
  
  // optional int32 maxlimit = 22;
  inline bool has_maxlimit() const;
  inline void clear_maxlimit();
  static const int kMaxlimitFieldNumber = 22;
  inline ::google::protobuf::int32 maxlimit() const;
  inline void set_maxlimit(::google::protobuf::int32 value);
  
  // optional int32 limit = 23;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 23;
  inline ::google::protobuf::int32 limit() const;
  inline void set_limit(::google::protobuf::int32 value);
  
  // optional int32 state = 24;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 24;
  inline ::google::protobuf::int32 state() const;
  inline void set_state(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.CarData)
 private:
  inline void set_has_carid();
  inline void clear_has_carid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_tier();
  inline void clear_has_tier();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_pricetype();
  inline void clear_has_pricetype();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_unlockmwlevel();
  inline void clear_has_unlockmwlevel();
  inline void set_has_chartletid();
  inline void clear_has_chartletid();
  inline void set_has_islock();
  inline void clear_has_islock();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_sellflag();
  inline void clear_has_sellflag();
  inline void set_has_isspecialcar();
  inline void clear_has_isspecialcar();
  inline void set_has_fragmentnumber();
  inline void clear_has_fragmentnumber();
  inline void set_has_totalfragmentnumber();
  inline void clear_has_totalfragmentnumber();
  inline void set_has_remainpricetype();
  inline void clear_has_remainpricetype();
  inline void set_has_remainprice();
  inline void clear_has_remainprice();
  inline void set_has_maxlimit();
  inline void clear_has_maxlimit();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_state();
  inline void clear_has_state();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* carid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 tier_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo > slots_;
  ::google::protobuf::int32 pricetype_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 unlockmwlevel_;
  ::google::protobuf::int32 chartletid_;
  ::google::protobuf::int64 remaintime_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ChartletInfo > chartletinfos_;
  bool islock_;
  bool isspecialcar_;
  ::google::protobuf::int32 sellflag_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaExpense > gotchaexpense_;
  ::google::protobuf::int32 fragmentnumber_;
  ::google::protobuf::int32 totalfragmentnumber_;
  ::google::protobuf::int32 remainpricetype_;
  ::google::protobuf::int32 remainprice_;
  ::google::protobuf::int32 maxlimit_;
  ::google::protobuf::int32 limit_;
  ::google::protobuf::int32 state_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static CarData* default_instance_;
};
// -------------------------------------------------------------------

class GotchaExpense : public ::google::protobuf::Message {
 public:
  GotchaExpense();
  virtual ~GotchaExpense();
  
  GotchaExpense(const GotchaExpense& from);
  
  inline GotchaExpense& operator=(const GotchaExpense& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GotchaExpense& default_instance();
  
  void Swap(GotchaExpense* other);
  
  // implements Message ----------------------------------------------
  
  GotchaExpense* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GotchaExpense& from);
  void MergeFrom(const GotchaExpense& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required int32 price = 2;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 2;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);
  
  // required int32 priceType = 3;
  inline bool has_pricetype() const;
  inline void clear_pricetype();
  static const int kPriceTypeFieldNumber = 3;
  inline ::google::protobuf::int32 pricetype() const;
  inline void set_pricetype(::google::protobuf::int32 value);
  
  // required int32 leftFreeTimes = 4;
  inline bool has_leftfreetimes() const;
  inline void clear_leftfreetimes();
  static const int kLeftFreeTimesFieldNumber = 4;
  inline ::google::protobuf::int32 leftfreetimes() const;
  inline void set_leftfreetimes(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.GotchaExpense)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_pricetype();
  inline void clear_has_pricetype();
  inline void set_has_leftfreetimes();
  inline void clear_has_leftfreetimes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 pricetype_;
  ::google::protobuf::int32 leftfreetimes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static GotchaExpense* default_instance_;
};
// -------------------------------------------------------------------

class ChartletInfo : public ::google::protobuf::Message {
 public:
  ChartletInfo();
  virtual ~ChartletInfo();
  
  ChartletInfo(const ChartletInfo& from);
  
  inline ChartletInfo& operator=(const ChartletInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChartletInfo& default_instance();
  
  void Swap(ChartletInfo* other);
  
  // implements Message ----------------------------------------------
  
  ChartletInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChartletInfo& from);
  void MergeFrom(const ChartletInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string diffuseTexturePath = 2;
  inline bool has_diffusetexturepath() const;
  inline void clear_diffusetexturepath();
  static const int kDiffuseTexturePathFieldNumber = 2;
  inline const ::std::string& diffusetexturepath() const;
  inline void set_diffusetexturepath(const ::std::string& value);
  inline void set_diffusetexturepath(const char* value);
  inline void set_diffusetexturepath(const char* value, size_t size);
  inline ::std::string* mutable_diffusetexturepath();
  inline ::std::string* release_diffusetexturepath();
  
  // required string diffuseMaskPath = 3;
  inline bool has_diffusemaskpath() const;
  inline void clear_diffusemaskpath();
  static const int kDiffuseMaskPathFieldNumber = 3;
  inline const ::std::string& diffusemaskpath() const;
  inline void set_diffusemaskpath(const ::std::string& value);
  inline void set_diffusemaskpath(const char* value);
  inline void set_diffusemaskpath(const char* value, size_t size);
  inline ::std::string* mutable_diffusemaskpath();
  inline ::std::string* release_diffusemaskpath();
  
  // required string BRDFPath = 4;
  inline bool has_brdfpath() const;
  inline void clear_brdfpath();
  static const int kBRDFPathFieldNumber = 4;
  inline const ::std::string& brdfpath() const;
  inline void set_brdfpath(const ::std::string& value);
  inline void set_brdfpath(const char* value);
  inline void set_brdfpath(const char* value, size_t size);
  inline ::std::string* mutable_brdfpath();
  inline ::std::string* release_brdfpath();
  
  // required string BRDFSpecularPath = 5;
  inline bool has_brdfspecularpath() const;
  inline void clear_brdfspecularpath();
  static const int kBRDFSpecularPathFieldNumber = 5;
  inline const ::std::string& brdfspecularpath() const;
  inline void set_brdfspecularpath(const ::std::string& value);
  inline void set_brdfspecularpath(const char* value);
  inline void set_brdfspecularpath(const char* value, size_t size);
  inline ::std::string* mutable_brdfspecularpath();
  inline ::std::string* release_brdfspecularpath();
  
  // required string numberPlatePath = 6;
  inline bool has_numberplatepath() const;
  inline void clear_numberplatepath();
  static const int kNumberPlatePathFieldNumber = 6;
  inline const ::std::string& numberplatepath() const;
  inline void set_numberplatepath(const ::std::string& value);
  inline void set_numberplatepath(const char* value);
  inline void set_numberplatepath(const char* value, size_t size);
  inline ::std::string* mutable_numberplatepath();
  inline ::std::string* release_numberplatepath();
  
  // required int64 swatchColor = 7;
  inline bool has_swatchcolor() const;
  inline void clear_swatchcolor();
  static const int kSwatchColorFieldNumber = 7;
  inline ::google::protobuf::int64 swatchcolor() const;
  inline void set_swatchcolor(::google::protobuf::int64 value);
  
  // required int64 swatchColor2 = 8;
  inline bool has_swatchcolor2() const;
  inline void clear_swatchcolor2();
  static const int kSwatchColor2FieldNumber = 8;
  inline ::google::protobuf::int64 swatchcolor2() const;
  inline void set_swatchcolor2(::google::protobuf::int64 value);
  
  // required int32 paintType = 9;
  inline bool has_painttype() const;
  inline void clear_painttype();
  static const int kPaintTypeFieldNumber = 9;
  inline ::google::protobuf::int32 painttype() const;
  inline void set_painttype(::google::protobuf::int32 value);
  
  // required bool useVinylMap = 10;
  inline bool has_usevinylmap() const;
  inline void clear_usevinylmap();
  static const int kUseVinylMapFieldNumber = 10;
  inline bool usevinylmap() const;
  inline void set_usevinylmap(bool value);
  
  // required int32 priceType = 11;
  inline bool has_pricetype() const;
  inline void clear_pricetype();
  static const int kPriceTypeFieldNumber = 11;
  inline ::google::protobuf::int32 pricetype() const;
  inline void set_pricetype(::google::protobuf::int32 value);
  
  // required int32 price = 12;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 12;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);
  
  // required int64 tenancy = 13;
  inline bool has_tenancy() const;
  inline void clear_tenancy();
  static const int kTenancyFieldNumber = 13;
  inline ::google::protobuf::int64 tenancy() const;
  inline void set_tenancy(::google::protobuf::int64 value);
  
  // required bool owned = 14;
  inline bool has_owned() const;
  inline void clear_owned();
  static const int kOwnedFieldNumber = 14;
  inline bool owned() const;
  inline void set_owned(bool value);
  
  // required int64 remainTime = 15;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 15;
  inline ::google::protobuf::int64 remaintime() const;
  inline void set_remaintime(::google::protobuf::int64 value);
  
  // required int32 id = 16;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 16;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 sellFlag = 17;
  inline bool has_sellflag() const;
  inline void clear_sellflag();
  static const int kSellFlagFieldNumber = 17;
  inline ::google::protobuf::int32 sellflag() const;
  inline void set_sellflag(::google::protobuf::int32 value);
  
  // optional int32 orderId = 18;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 18;
  inline ::google::protobuf::int32 orderid() const;
  inline void set_orderid(::google::protobuf::int32 value);
  
  // optional int32 score = 19;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 19;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ChartletInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_diffusetexturepath();
  inline void clear_has_diffusetexturepath();
  inline void set_has_diffusemaskpath();
  inline void clear_has_diffusemaskpath();
  inline void set_has_brdfpath();
  inline void clear_has_brdfpath();
  inline void set_has_brdfspecularpath();
  inline void clear_has_brdfspecularpath();
  inline void set_has_numberplatepath();
  inline void clear_has_numberplatepath();
  inline void set_has_swatchcolor();
  inline void clear_has_swatchcolor();
  inline void set_has_swatchcolor2();
  inline void clear_has_swatchcolor2();
  inline void set_has_painttype();
  inline void clear_has_painttype();
  inline void set_has_usevinylmap();
  inline void clear_has_usevinylmap();
  inline void set_has_pricetype();
  inline void clear_has_pricetype();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_tenancy();
  inline void clear_has_tenancy();
  inline void set_has_owned();
  inline void clear_has_owned();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sellflag();
  inline void clear_has_sellflag();
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_score();
  inline void clear_has_score();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* diffusetexturepath_;
  ::std::string* diffusemaskpath_;
  ::std::string* brdfpath_;
  ::std::string* brdfspecularpath_;
  ::std::string* numberplatepath_;
  ::google::protobuf::int64 swatchcolor_;
  ::google::protobuf::int64 swatchcolor2_;
  ::google::protobuf::int32 painttype_;
  ::google::protobuf::int32 pricetype_;
  ::google::protobuf::int32 price_;
  bool usevinylmap_;
  bool owned_;
  ::google::protobuf::int64 tenancy_;
  ::google::protobuf::int64 remaintime_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 sellflag_;
  ::google::protobuf::int32 orderid_;
  ::google::protobuf::int32 score_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ChartletInfo* default_instance_;
};
// -------------------------------------------------------------------

class CarSlotInfo : public ::google::protobuf::Message {
 public:
  CarSlotInfo();
  virtual ~CarSlotInfo();
  
  CarSlotInfo(const CarSlotInfo& from);
  
  inline CarSlotInfo& operator=(const CarSlotInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CarSlotInfo& default_instance();
  
  void Swap(CarSlotInfo* other);
  
  // implements Message ----------------------------------------------
  
  CarSlotInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CarSlotInfo& from);
  void MergeFrom(const CarSlotInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 slotId = 1;
  inline bool has_slotid() const;
  inline void clear_slotid();
  static const int kSlotIdFieldNumber = 1;
  inline ::google::protobuf::int32 slotid() const;
  inline void set_slotid(::google::protobuf::int32 value);
  
  // required int32 level = 2;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 2;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required bool reachMaxLevel = 3;
  inline bool has_reachmaxlevel() const;
  inline void clear_reachmaxlevel();
  static const int kReachMaxLevelFieldNumber = 3;
  inline bool reachmaxlevel() const;
  inline void set_reachmaxlevel(bool value);
  
  // required int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // optional int32 remainTime = 5;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 5;
  inline ::google::protobuf::int32 remaintime() const;
  inline void set_remaintime(::google::protobuf::int32 value);
  
  // required int32 score = 6;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 6;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // required int32 priceType = 7;
  inline bool has_pricetype() const;
  inline void clear_pricetype();
  static const int kPriceTypeFieldNumber = 7;
  inline ::google::protobuf::int32 pricetype() const;
  inline void set_pricetype(::google::protobuf::int32 value);
  
  // required int32 price = 8;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 8;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);
  
  // required string description = 9;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 9;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.ConsumableData consumble = 10;
  inline int consumble_size() const;
  inline void clear_consumble();
  static const int kConsumbleFieldNumber = 10;
  inline const ::com::ea::eamobile::nfsmw::protoc::ConsumableData& consumble(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::ConsumableData* mutable_consumble(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::ConsumableData* add_consumble();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ConsumableData >&
      consumble() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ConsumableData >*
      mutable_consumble();
  
  // optional int32 nextAddScore = 11;
  inline bool has_nextaddscore() const;
  inline void clear_nextaddscore();
  static const int kNextAddScoreFieldNumber = 11;
  inline ::google::protobuf::int32 nextaddscore() const;
  inline void set_nextaddscore(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.CarSlotInfo)
 private:
  inline void set_has_slotid();
  inline void clear_has_slotid();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_reachmaxlevel();
  inline void clear_has_reachmaxlevel();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_pricetype();
  inline void clear_has_pricetype();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_nextaddscore();
  inline void clear_has_nextaddscore();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 slotid_;
  ::google::protobuf::int32 level_;
  bool reachmaxlevel_;
  ::google::protobuf::int32 status_;
  ::google::protobuf::int32 remaintime_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 pricetype_;
  ::google::protobuf::int32 price_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ConsumableData > consumble_;
  ::google::protobuf::int32 nextaddscore_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static CarSlotInfo* default_instance_;
};
// -------------------------------------------------------------------

class ConsumableData : public ::google::protobuf::Message {
 public:
  ConsumableData();
  virtual ~ConsumableData();
  
  ConsumableData(const ConsumableData& from);
  
  inline ConsumableData& operator=(const ConsumableData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsumableData& default_instance();
  
  void Swap(ConsumableData* other);
  
  // implements Message ----------------------------------------------
  
  ConsumableData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConsumableData& from);
  void MergeFrom(const ConsumableData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required float ratio = 2;
  inline bool has_ratio() const;
  inline void clear_ratio();
  static const int kRatioFieldNumber = 2;
  inline float ratio() const;
  inline void set_ratio(float value);
  
  // required int32 priceType = 3;
  inline bool has_pricetype() const;
  inline void clear_pricetype();
  static const int kPriceTypeFieldNumber = 3;
  inline ::google::protobuf::int32 pricetype() const;
  inline void set_pricetype(::google::protobuf::int32 value);
  
  // required int32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ConsumableData)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ratio();
  inline void clear_has_ratio();
  inline void set_has_pricetype();
  inline void clear_has_pricetype();
  inline void set_has_price();
  inline void clear_has_price();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 type_;
  float ratio_;
  ::google::protobuf::int32 pricetype_;
  ::google::protobuf::int32 price_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ConsumableData* default_instance_;
};
// -------------------------------------------------------------------

class RequestGarageCommand : public ::google::protobuf::Message {
 public:
  RequestGarageCommand();
  virtual ~RequestGarageCommand();
  
  RequestGarageCommand(const RequestGarageCommand& from);
  
  inline RequestGarageCommand& operator=(const RequestGarageCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGarageCommand& default_instance();
  
  void Swap(RequestGarageCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestGarageCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestGarageCommand& from);
  void MergeFrom(const RequestGarageCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestGarageCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestGarageCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGarageCommand : public ::google::protobuf::Message {
 public:
  ResponseGarageCommand();
  virtual ~ResponseGarageCommand();
  
  ResponseGarageCommand(const ResponseGarageCommand& from);
  
  inline ResponseGarageCommand& operator=(const ResponseGarageCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseGarageCommand& default_instance();
  
  void Swap(ResponseGarageCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseGarageCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseGarageCommand& from);
  void MergeFrom(const ResponseGarageCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.CarData carDatas = 1;
  inline int cardatas_size() const;
  inline void clear_cardatas();
  static const int kCarDatasFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::CarData& cardatas(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::CarData* mutable_cardatas(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::CarData* add_cardatas();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarData >&
      cardatas() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarData >*
      mutable_cardatas();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseGarageCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarData > cardatas_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseGarageCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestBuyCarCommand : public ::google::protobuf::Message {
 public:
  RequestBuyCarCommand();
  virtual ~RequestBuyCarCommand();
  
  RequestBuyCarCommand(const RequestBuyCarCommand& from);
  
  inline RequestBuyCarCommand& operator=(const RequestBuyCarCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBuyCarCommand& default_instance();
  
  void Swap(RequestBuyCarCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestBuyCarCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestBuyCarCommand& from);
  void MergeFrom(const RequestBuyCarCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string carId = 1;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 1;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestBuyCarCommand)
 private:
  inline void set_has_carid();
  inline void clear_has_carid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* carid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestBuyCarCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBuyCarCommand : public ::google::protobuf::Message {
 public:
  ResponseBuyCarCommand();
  virtual ~ResponseBuyCarCommand();
  
  ResponseBuyCarCommand(const ResponseBuyCarCommand& from);
  
  inline ResponseBuyCarCommand& operator=(const ResponseBuyCarCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBuyCarCommand& default_instance();
  
  void Swap(ResponseBuyCarCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseBuyCarCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseBuyCarCommand& from);
  void MergeFrom(const ResponseBuyCarCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseBuyCarCommand)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseBuyCarCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestCarDataCommand : public ::google::protobuf::Message {
 public:
  RequestCarDataCommand();
  virtual ~RequestCarDataCommand();
  
  RequestCarDataCommand(const RequestCarDataCommand& from);
  
  inline RequestCarDataCommand& operator=(const RequestCarDataCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCarDataCommand& default_instance();
  
  void Swap(RequestCarDataCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestCarDataCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestCarDataCommand& from);
  void MergeFrom(const RequestCarDataCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string carId = 1;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 1;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestCarDataCommand)
 private:
  inline void set_has_carid();
  inline void clear_has_carid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* carid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestCarDataCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCarDataCommand : public ::google::protobuf::Message {
 public:
  ResponseCarDataCommand();
  virtual ~ResponseCarDataCommand();
  
  ResponseCarDataCommand(const ResponseCarDataCommand& from);
  
  inline ResponseCarDataCommand& operator=(const ResponseCarDataCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCarDataCommand& default_instance();
  
  void Swap(ResponseCarDataCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseCarDataCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseCarDataCommand& from);
  void MergeFrom(const ResponseCarDataCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.ea.eamobile.nfsmw.protoc.CarData carData = 1;
  inline bool has_cardata() const;
  inline void clear_cardata();
  static const int kCarDataFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::CarData& cardata() const;
  inline ::com::ea::eamobile::nfsmw::protoc::CarData* mutable_cardata();
  inline ::com::ea::eamobile::nfsmw::protoc::CarData* release_cardata();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseCarDataCommand)
 private:
  inline void set_has_cardata();
  inline void clear_has_cardata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::CarData* cardata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseCarDataCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestUpgradeSlotCommand : public ::google::protobuf::Message {
 public:
  RequestUpgradeSlotCommand();
  virtual ~RequestUpgradeSlotCommand();
  
  RequestUpgradeSlotCommand(const RequestUpgradeSlotCommand& from);
  
  inline RequestUpgradeSlotCommand& operator=(const RequestUpgradeSlotCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUpgradeSlotCommand& default_instance();
  
  void Swap(RequestUpgradeSlotCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestUpgradeSlotCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUpgradeSlotCommand& from);
  void MergeFrom(const RequestUpgradeSlotCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 slotId = 1;
  inline bool has_slotid() const;
  inline void clear_slotid();
  static const int kSlotIdFieldNumber = 1;
  inline ::google::protobuf::int32 slotid() const;
  inline void set_slotid(::google::protobuf::int32 value);
  
  // required string userCarId = 2;
  inline bool has_usercarid() const;
  inline void clear_usercarid();
  static const int kUserCarIdFieldNumber = 2;
  inline const ::std::string& usercarid() const;
  inline void set_usercarid(const ::std::string& value);
  inline void set_usercarid(const char* value);
  inline void set_usercarid(const char* value, size_t size);
  inline ::std::string* mutable_usercarid();
  inline ::std::string* release_usercarid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestUpgradeSlotCommand)
 private:
  inline void set_has_slotid();
  inline void clear_has_slotid();
  inline void set_has_usercarid();
  inline void clear_has_usercarid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* usercarid_;
  ::google::protobuf::int32 slotid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestUpgradeSlotCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUpgradeSlotCommand : public ::google::protobuf::Message {
 public:
  ResponseUpgradeSlotCommand();
  virtual ~ResponseUpgradeSlotCommand();
  
  ResponseUpgradeSlotCommand(const ResponseUpgradeSlotCommand& from);
  
  inline ResponseUpgradeSlotCommand& operator=(const ResponseUpgradeSlotCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseUpgradeSlotCommand& default_instance();
  
  void Swap(ResponseUpgradeSlotCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseUpgradeSlotCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseUpgradeSlotCommand& from);
  void MergeFrom(const ResponseUpgradeSlotCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // optional int32 remainTime = 3;
  inline bool has_remaintime() const;
  inline void clear_remaintime();
  static const int kRemainTimeFieldNumber = 3;
  inline ::google::protobuf::int32 remaintime() const;
  inline void set_remaintime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseUpgradeSlotCommand)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_remaintime();
  inline void clear_has_remaintime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  bool success_;
  ::google::protobuf::int32 remaintime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseUpgradeSlotCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestUseChartletCommand : public ::google::protobuf::Message {
 public:
  RequestUseChartletCommand();
  virtual ~RequestUseChartletCommand();
  
  RequestUseChartletCommand(const RequestUseChartletCommand& from);
  
  inline RequestUseChartletCommand& operator=(const RequestUseChartletCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestUseChartletCommand& default_instance();
  
  void Swap(RequestUseChartletCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestUseChartletCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestUseChartletCommand& from);
  void MergeFrom(const RequestUseChartletCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 chartletId = 1;
  inline bool has_chartletid() const;
  inline void clear_chartletid();
  static const int kChartletIdFieldNumber = 1;
  inline ::google::protobuf::int32 chartletid() const;
  inline void set_chartletid(::google::protobuf::int32 value);
  
  // required string carId = 2;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 2;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestUseChartletCommand)
 private:
  inline void set_has_chartletid();
  inline void clear_has_chartletid();
  inline void set_has_carid();
  inline void clear_has_carid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* carid_;
  ::google::protobuf::int32 chartletid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestUseChartletCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseUseChartletCommand : public ::google::protobuf::Message {
 public:
  ResponseUseChartletCommand();
  virtual ~ResponseUseChartletCommand();
  
  ResponseUseChartletCommand(const ResponseUseChartletCommand& from);
  
  inline ResponseUseChartletCommand& operator=(const ResponseUseChartletCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseUseChartletCommand& default_instance();
  
  void Swap(ResponseUseChartletCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseUseChartletCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseUseChartletCommand& from);
  void MergeFrom(const ResponseUseChartletCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // required string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseUseChartletCommand)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseUseChartletCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestChallengeMathInfoCommand : public ::google::protobuf::Message {
 public:
  RequestChallengeMathInfoCommand();
  virtual ~RequestChallengeMathInfoCommand();
  
  RequestChallengeMathInfoCommand(const RequestChallengeMathInfoCommand& from);
  
  inline RequestChallengeMathInfoCommand& operator=(const RequestChallengeMathInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestChallengeMathInfoCommand& default_instance();
  
  void Swap(RequestChallengeMathInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestChallengeMathInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestChallengeMathInfoCommand& from);
  void MergeFrom(const RequestChallengeMathInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool request = 1;
  inline bool has_request() const;
  inline void clear_request();
  static const int kRequestFieldNumber = 1;
  inline bool request() const;
  inline void set_request(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestChallengeMathInfoCommand)
 private:
  inline void set_has_request();
  inline void clear_has_request();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool request_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestChallengeMathInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseChallengeMatchInfoCommand : public ::google::protobuf::Message {
 public:
  ResponseChallengeMatchInfoCommand();
  virtual ~ResponseChallengeMatchInfoCommand();
  
  ResponseChallengeMatchInfoCommand(const ResponseChallengeMatchInfoCommand& from);
  
  inline ResponseChallengeMatchInfoCommand& operator=(const ResponseChallengeMatchInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseChallengeMatchInfoCommand& default_instance();
  
  void Swap(ResponseChallengeMatchInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseChallengeMatchInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseChallengeMatchInfoCommand& from);
  void MergeFrom(const ResponseChallengeMatchInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 modeId = 1;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 1;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // required int32 challengeDays = 2;
  inline bool has_challengedays() const;
  inline void clear_challengedays();
  static const int kChallengeDaysFieldNumber = 2;
  inline ::google::protobuf::int32 challengedays() const;
  inline void set_challengedays(::google::protobuf::int32 value);
  
  // required .com.ea.eamobile.nfsmw.protoc.Reward reward = 3;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::Reward& reward() const;
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* mutable_reward();
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* release_reward();
  
  // required string carId = 4;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 4;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // required int32 remainTimes = 5;
  inline bool has_remaintimes() const;
  inline void clear_remaintimes();
  static const int kRemainTimesFieldNumber = 5;
  inline ::google::protobuf::int32 remaintimes() const;
  inline void set_remaintimes(::google::protobuf::int32 value);
  
  // required float passTime = 6;
  inline bool has_passtime() const;
  inline void clear_passtime();
  static const int kPassTimeFieldNumber = 6;
  inline float passtime() const;
  inline void set_passtime(float value);
  
  // required string eventName = 7;
  inline bool has_eventname() const;
  inline void clear_eventname();
  static const int kEventNameFieldNumber = 7;
  inline const ::std::string& eventname() const;
  inline void set_eventname(const ::std::string& value);
  inline void set_eventname(const char* value);
  inline void set_eventname(const char* value, size_t size);
  inline ::std::string* mutable_eventname();
  inline ::std::string* release_eventname();
  
  // required string carLimitDisplayString = 8;
  inline bool has_carlimitdisplaystring() const;
  inline void clear_carlimitdisplaystring();
  static const int kCarLimitDisplayStringFieldNumber = 8;
  inline const ::std::string& carlimitdisplaystring() const;
  inline void set_carlimitdisplaystring(const ::std::string& value);
  inline void set_carlimitdisplaystring(const char* value);
  inline void set_carlimitdisplaystring(const char* value, size_t size);
  inline ::std::string* mutable_carlimitdisplaystring();
  inline ::std::string* release_carlimitdisplaystring();
  
  // optional int32 expireSeconds = 9;
  inline bool has_expireseconds() const;
  inline void clear_expireseconds();
  static const int kExpireSecondsFieldNumber = 9;
  inline ::google::protobuf::int32 expireseconds() const;
  inline void set_expireseconds(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseChallengeMatchInfoCommand)
 private:
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_challengedays();
  inline void clear_has_challengedays();
  inline void set_has_reward();
  inline void clear_has_reward();
  inline void set_has_carid();
  inline void clear_has_carid();
  inline void set_has_remaintimes();
  inline void clear_has_remaintimes();
  inline void set_has_passtime();
  inline void clear_has_passtime();
  inline void set_has_eventname();
  inline void clear_has_eventname();
  inline void set_has_carlimitdisplaystring();
  inline void clear_has_carlimitdisplaystring();
  inline void set_has_expireseconds();
  inline void clear_has_expireseconds();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 modeid_;
  ::google::protobuf::int32 challengedays_;
  ::com::ea::eamobile::nfsmw::protoc::Reward* reward_;
  ::std::string* carid_;
  ::google::protobuf::int32 remaintimes_;
  float passtime_;
  ::std::string* eventname_;
  ::std::string* carlimitdisplaystring_;
  ::google::protobuf::int32 expireseconds_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseChallengeMatchInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseFeedCommand : public ::google::protobuf::Message {
 public:
  ResponseFeedCommand();
  virtual ~ResponseFeedCommand();
  
  ResponseFeedCommand(const ResponseFeedCommand& from);
  
  inline ResponseFeedCommand& operator=(const ResponseFeedCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFeedCommand& default_instance();
  
  void Swap(ResponseFeedCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseFeedCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseFeedCommand& from);
  void MergeFrom(const ResponseFeedCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string feedContent = 1;
  inline int feedcontent_size() const;
  inline void clear_feedcontent();
  static const int kFeedContentFieldNumber = 1;
  inline const ::std::string& feedcontent(int index) const;
  inline ::std::string* mutable_feedcontent(int index);
  inline void set_feedcontent(int index, const ::std::string& value);
  inline void set_feedcontent(int index, const char* value);
  inline void set_feedcontent(int index, const char* value, size_t size);
  inline ::std::string* add_feedcontent();
  inline void add_feedcontent(const ::std::string& value);
  inline void add_feedcontent(const char* value);
  inline void add_feedcontent(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& feedcontent() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_feedcontent();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseFeedCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> feedcontent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseFeedCommand* default_instance_;
};
// -------------------------------------------------------------------

class ItemMessage : public ::google::protobuf::Message {
 public:
  ItemMessage();
  virtual ~ItemMessage();
  
  ItemMessage(const ItemMessage& from);
  
  inline ItemMessage& operator=(const ItemMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemMessage& default_instance();
  
  void Swap(ItemMessage* other);
  
  // implements Message ----------------------------------------------
  
  ItemMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemMessage& from);
  void MergeFrom(const ItemMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 priceType = 2;
  inline bool has_pricetype() const;
  inline void clear_pricetype();
  static const int kPriceTypeFieldNumber = 2;
  inline ::google::protobuf::int32 pricetype() const;
  inline void set_pricetype(::google::protobuf::int32 value);
  
  // required float price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline float price() const;
  inline void set_price(float value);
  
  // required bool discount = 4;
  inline bool has_discount() const;
  inline void clear_discount();
  static const int kDiscountFieldNumber = 4;
  inline bool discount() const;
  inline void set_discount(bool value);
  
  // required string discountNum = 5;
  inline bool has_discountnum() const;
  inline void clear_discountnum();
  static const int kDiscountNumFieldNumber = 5;
  inline const ::std::string& discountnum() const;
  inline void set_discountnum(const ::std::string& value);
  inline void set_discountnum(const char* value);
  inline void set_discountnum(const char* value, size_t size);
  inline ::std::string* mutable_discountnum();
  inline ::std::string* release_discountnum();
  
  // required float discountPrice = 6;
  inline bool has_discountprice() const;
  inline void clear_discountprice();
  static const int kDiscountPriceFieldNumber = 6;
  inline float discountprice() const;
  inline void set_discountprice(float value);
  
  // required int32 buyCount = 7;
  inline bool has_buycount() const;
  inline void clear_buycount();
  static const int kBuyCountFieldNumber = 7;
  inline ::google::protobuf::int32 buycount() const;
  inline void set_buycount(::google::protobuf::int32 value);
  
  // required int64 buyTimeLimit = 8;
  inline bool has_buytimelimit() const;
  inline void clear_buytimelimit();
  static const int kBuyTimeLimitFieldNumber = 8;
  inline ::google::protobuf::int64 buytimelimit() const;
  inline void set_buytimelimit(::google::protobuf::int64 value);
  
  // required int32 itemType = 9;
  inline bool has_itemtype() const;
  inline void clear_itemtype();
  static const int kItemTypeFieldNumber = 9;
  inline ::google::protobuf::int32 itemtype() const;
  inline void set_itemtype(::google::protobuf::int32 value);
  
  // required int32 itemId = 10;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 10;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);
  
  // optional int32 sellFlag = 11;
  inline bool has_sellflag() const;
  inline void clear_sellflag();
  static const int kSellFlagFieldNumber = 11;
  inline ::google::protobuf::int32 sellflag() const;
  inline void set_sellflag(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ItemMessage)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pricetype();
  inline void clear_has_pricetype();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_discount();
  inline void clear_has_discount();
  inline void set_has_discountnum();
  inline void clear_has_discountnum();
  inline void set_has_discountprice();
  inline void clear_has_discountprice();
  inline void set_has_buycount();
  inline void clear_has_buycount();
  inline void set_has_buytimelimit();
  inline void clear_has_buytimelimit();
  inline void set_has_itemtype();
  inline void clear_has_itemtype();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_sellflag();
  inline void clear_has_sellflag();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 pricetype_;
  float price_;
  ::std::string* discountnum_;
  bool discount_;
  float discountprice_;
  ::google::protobuf::int64 buytimelimit_;
  ::google::protobuf::int32 buycount_;
  ::google::protobuf::int32 itemtype_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 sellflag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ItemMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestStoreDetailCommand : public ::google::protobuf::Message {
 public:
  RequestStoreDetailCommand();
  virtual ~RequestStoreDetailCommand();
  
  RequestStoreDetailCommand(const RequestStoreDetailCommand& from);
  
  inline RequestStoreDetailCommand& operator=(const RequestStoreDetailCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestStoreDetailCommand& default_instance();
  
  void Swap(RequestStoreDetailCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestStoreDetailCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestStoreDetailCommand& from);
  void MergeFrom(const RequestStoreDetailCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestStoreDetailCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestStoreDetailCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseStoreDetailCommand : public ::google::protobuf::Message {
 public:
  ResponseStoreDetailCommand();
  virtual ~ResponseStoreDetailCommand();
  
  ResponseStoreDetailCommand(const ResponseStoreDetailCommand& from);
  
  inline ResponseStoreDetailCommand& operator=(const ResponseStoreDetailCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseStoreDetailCommand& default_instance();
  
  void Swap(ResponseStoreDetailCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseStoreDetailCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseStoreDetailCommand& from);
  void MergeFrom(const ResponseStoreDetailCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.ItemMessage items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::ItemMessage& items(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::ItemMessage* mutable_items(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::ItemMessage* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ItemMessage >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ItemMessage >*
      mutable_items();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseStoreDetailCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ItemMessage > items_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseStoreDetailCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestBuyItemCommand : public ::google::protobuf::Message {
 public:
  RequestBuyItemCommand();
  virtual ~RequestBuyItemCommand();
  
  RequestBuyItemCommand(const RequestBuyItemCommand& from);
  
  inline RequestBuyItemCommand& operator=(const RequestBuyItemCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBuyItemCommand& default_instance();
  
  void Swap(RequestBuyItemCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestBuyItemCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestBuyItemCommand& from);
  void MergeFrom(const RequestBuyItemCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 itemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestBuyItemCommand)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 itemid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestBuyItemCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseBuyItemCommand : public ::google::protobuf::Message {
 public:
  ResponseBuyItemCommand();
  virtual ~ResponseBuyItemCommand();
  
  ResponseBuyItemCommand(const ResponseBuyItemCommand& from);
  
  inline ResponseBuyItemCommand& operator=(const ResponseBuyItemCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBuyItemCommand& default_instance();
  
  void Swap(ResponseBuyItemCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseBuyItemCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseBuyItemCommand& from);
  void MergeFrom(const ResponseBuyItemCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseBuyItemCommand)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseBuyItemCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestSystemCommand : public ::google::protobuf::Message {
 public:
  RequestSystemCommand();
  virtual ~RequestSystemCommand();
  
  RequestSystemCommand(const RequestSystemCommand& from);
  
  inline RequestSystemCommand& operator=(const RequestSystemCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSystemCommand& default_instance();
  
  void Swap(RequestSystemCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestSystemCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestSystemCommand& from);
  void MergeFrom(const RequestSystemCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef RequestSystemCommand_SystemConfigType SystemConfigType;
  static const SystemConfigType UserLanguage = RequestSystemCommand_SystemConfigType_UserLanguage;
  static const SystemConfigType SynergyUID = RequestSystemCommand_SystemConfigType_SynergyUID;
  static inline bool SystemConfigType_IsValid(int value) {
    return RequestSystemCommand_SystemConfigType_IsValid(value);
  }
  static const SystemConfigType SystemConfigType_MIN =
    RequestSystemCommand_SystemConfigType_SystemConfigType_MIN;
  static const SystemConfigType SystemConfigType_MAX =
    RequestSystemCommand_SystemConfigType_SystemConfigType_MAX;
  static const int SystemConfigType_ARRAYSIZE =
    RequestSystemCommand_SystemConfigType_SystemConfigType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SystemConfigType_descriptor() {
    return RequestSystemCommand_SystemConfigType_descriptor();
  }
  static inline const ::std::string& SystemConfigType_Name(SystemConfigType value) {
    return RequestSystemCommand_SystemConfigType_Name(value);
  }
  static inline bool SystemConfigType_Parse(const ::std::string& name,
      SystemConfigType* value) {
    return RequestSystemCommand_SystemConfigType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .com.ea.eamobile.nfsmw.protoc.RequestSystemCommand.SystemConfigType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand_SystemConfigType type() const;
  inline void set_type(::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand_SystemConfigType value);
  
  // required string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestSystemCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_content();
  inline void clear_has_content();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* content_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestSystemCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseSystemCommand : public ::google::protobuf::Message {
 public:
  ResponseSystemCommand();
  virtual ~ResponseSystemCommand();
  
  ResponseSystemCommand(const ResponseSystemCommand& from);
  
  inline ResponseSystemCommand& operator=(const ResponseSystemCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSystemCommand& default_instance();
  
  void Swap(ResponseSystemCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseSystemCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseSystemCommand& from);
  void MergeFrom(const ResponseSystemCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.EventOptionMessage EventOption = 1;
  inline int eventoption_size() const;
  inline void clear_eventoption();
  static const int kEventOptionFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage& eventoption(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage* mutable_eventoption(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage* add_eventoption();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage >&
      eventoption() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage >*
      mutable_eventoption();
  
  // repeated int32 CtaParam = 2;
  inline int ctaparam_size() const;
  inline void clear_ctaparam();
  static const int kCtaParamFieldNumber = 2;
  inline ::google::protobuf::int32 ctaparam(int index) const;
  inline void set_ctaparam(int index, ::google::protobuf::int32 value);
  inline void add_ctaparam(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ctaparam() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ctaparam();
  
  // optional string messageUrl = 3;
  inline bool has_messageurl() const;
  inline void clear_messageurl();
  static const int kMessageUrlFieldNumber = 3;
  inline const ::std::string& messageurl() const;
  inline void set_messageurl(const ::std::string& value);
  inline void set_messageurl(const char* value);
  inline void set_messageurl(const char* value, size_t size);
  inline ::std::string* mutable_messageurl();
  inline ::std::string* release_messageurl();
  
  // repeated float speedFactor = 4;
  inline int speedfactor_size() const;
  inline void clear_speedfactor();
  static const int kSpeedFactorFieldNumber = 4;
  inline float speedfactor(int index) const;
  inline void set_speedfactor(int index, float value);
  inline void add_speedfactor(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      speedfactor() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_speedfactor();
  
  // optional string IPSPFailedMessageUrl = 5;
  inline bool has_ipspfailedmessageurl() const;
  inline void clear_ipspfailedmessageurl();
  static const int kIPSPFailedMessageUrlFieldNumber = 5;
  inline const ::std::string& ipspfailedmessageurl() const;
  inline void set_ipspfailedmessageurl(const ::std::string& value);
  inline void set_ipspfailedmessageurl(const char* value);
  inline void set_ipspfailedmessageurl(const char* value, size_t size);
  inline ::std::string* mutable_ipspfailedmessageurl();
  inline ::std::string* release_ipspfailedmessageurl();
  
  // optional string rentJaguarUrl = 6;
  inline bool has_rentjaguarurl() const;
  inline void clear_rentjaguarurl();
  static const int kRentJaguarUrlFieldNumber = 6;
  inline const ::std::string& rentjaguarurl() const;
  inline void set_rentjaguarurl(const ::std::string& value);
  inline void set_rentjaguarurl(const char* value);
  inline void set_rentjaguarurl(const char* value, size_t size);
  inline ::std::string* mutable_rentjaguarurl();
  inline ::std::string* release_rentjaguarurl();
  
  // optional string getJaguarUrl = 7;
  inline bool has_getjaguarurl() const;
  inline void clear_getjaguarurl();
  static const int kGetJaguarUrlFieldNumber = 7;
  inline const ::std::string& getjaguarurl() const;
  inline void set_getjaguarurl(const ::std::string& value);
  inline void set_getjaguarurl(const char* value);
  inline void set_getjaguarurl(const char* value, size_t size);
  inline ::std::string* mutable_getjaguarurl();
  inline ::std::string* release_getjaguarurl();
  
  // optional string jaguarInfoUrl = 8;
  inline bool has_jaguarinfourl() const;
  inline void clear_jaguarinfourl();
  static const int kJaguarInfoUrlFieldNumber = 8;
  inline const ::std::string& jaguarinfourl() const;
  inline void set_jaguarinfourl(const ::std::string& value);
  inline void set_jaguarinfourl(const char* value);
  inline void set_jaguarinfourl(const char* value, size_t size);
  inline ::std::string* mutable_jaguarinfourl();
  inline ::std::string* release_jaguarinfourl();
  
  // repeated string servers = 9;
  inline int servers_size() const;
  inline void clear_servers();
  static const int kServersFieldNumber = 9;
  inline const ::std::string& servers(int index) const;
  inline ::std::string* mutable_servers(int index);
  inline void set_servers(int index, const ::std::string& value);
  inline void set_servers(int index, const char* value);
  inline void set_servers(int index, const char* value, size_t size);
  inline ::std::string* add_servers();
  inline void add_servers(const ::std::string& value);
  inline void add_servers(const char* value);
  inline void add_servers(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& servers() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_servers();
  
  // optional bool popMOD = 10;
  inline bool has_popmod() const;
  inline void clear_popmod();
  static const int kPopMODFieldNumber = 10;
  inline bool popmod() const;
  inline void set_popmod(bool value);
  
  // optional int32 energyRecoveringStartTime = 11;
  inline bool has_energyrecoveringstarttime() const;
  inline void clear_energyrecoveringstarttime();
  static const int kEnergyRecoveringStartTimeFieldNumber = 11;
  inline ::google::protobuf::int32 energyrecoveringstarttime() const;
  inline void set_energyrecoveringstarttime(::google::protobuf::int32 value);
  
  // optional int32 energyRecoveringPeriod = 12;
  inline bool has_energyrecoveringperiod() const;
  inline void clear_energyrecoveringperiod();
  static const int kEnergyRecoveringPeriodFieldNumber = 12;
  inline ::google::protobuf::int32 energyrecoveringperiod() const;
  inline void set_energyrecoveringperiod(::google::protobuf::int32 value);
  
  // optional int32 energyRecoveringNum = 13;
  inline bool has_energyrecoveringnum() const;
  inline void clear_energyrecoveringnum();
  static const int kEnergyRecoveringNumFieldNumber = 13;
  inline ::google::protobuf::int32 energyrecoveringnum() const;
  inline void set_energyrecoveringnum(::google::protobuf::int32 value);
  
  // optional int32 ipspPurchaseItemCallBackType = 14;
  inline bool has_ipsppurchaseitemcallbacktype() const;
  inline void clear_ipsppurchaseitemcallbacktype();
  static const int kIpspPurchaseItemCallBackTypeFieldNumber = 14;
  inline ::google::protobuf::int32 ipsppurchaseitemcallbacktype() const;
  inline void set_ipsppurchaseitemcallbacktype(::google::protobuf::int32 value);
  
  // optional int32 energyMaxNum = 15;
  inline bool has_energymaxnum() const;
  inline void clear_energymaxnum();
  static const int kEnergyMaxNumFieldNumber = 15;
  inline ::google::protobuf::int32 energymaxnum() const;
  inline void set_energymaxnum(::google::protobuf::int32 value);
  
  // optional int32 newMOD = 16;
  inline bool has_newmod() const;
  inline void clear_newmod();
  static const int kNewMODFieldNumber = 16;
  inline ::google::protobuf::int32 newmod() const;
  inline void set_newmod(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseSystemCommand)
 private:
  inline void set_has_messageurl();
  inline void clear_has_messageurl();
  inline void set_has_ipspfailedmessageurl();
  inline void clear_has_ipspfailedmessageurl();
  inline void set_has_rentjaguarurl();
  inline void clear_has_rentjaguarurl();
  inline void set_has_getjaguarurl();
  inline void clear_has_getjaguarurl();
  inline void set_has_jaguarinfourl();
  inline void clear_has_jaguarinfourl();
  inline void set_has_popmod();
  inline void clear_has_popmod();
  inline void set_has_energyrecoveringstarttime();
  inline void clear_has_energyrecoveringstarttime();
  inline void set_has_energyrecoveringperiod();
  inline void clear_has_energyrecoveringperiod();
  inline void set_has_energyrecoveringnum();
  inline void clear_has_energyrecoveringnum();
  inline void set_has_ipsppurchaseitemcallbacktype();
  inline void clear_has_ipsppurchaseitemcallbacktype();
  inline void set_has_energymaxnum();
  inline void clear_has_energymaxnum();
  inline void set_has_newmod();
  inline void clear_has_newmod();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage > eventoption_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ctaparam_;
  ::std::string* messageurl_;
  ::google::protobuf::RepeatedField< float > speedfactor_;
  ::std::string* ipspfailedmessageurl_;
  ::std::string* rentjaguarurl_;
  ::std::string* getjaguarurl_;
  ::std::string* jaguarinfourl_;
  ::google::protobuf::RepeatedPtrField< ::std::string> servers_;
  bool popmod_;
  ::google::protobuf::int32 energyrecoveringstarttime_;
  ::google::protobuf::int32 energyrecoveringperiod_;
  ::google::protobuf::int32 energyrecoveringnum_;
  ::google::protobuf::int32 ipsppurchaseitemcallbacktype_;
  ::google::protobuf::int32 energymaxnum_;
  ::google::protobuf::int32 newmod_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseSystemCommand* default_instance_;
};
// -------------------------------------------------------------------

class EventOptionMessage : public ::google::protobuf::Message {
 public:
  EventOptionMessage();
  virtual ~EventOptionMessage();
  
  EventOptionMessage(const EventOptionMessage& from);
  
  inline EventOptionMessage& operator=(const EventOptionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EventOptionMessage& default_instance();
  
  void Swap(EventOptionMessage* other);
  
  // implements Message ----------------------------------------------
  
  EventOptionMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventOptionMessage& from);
  void MergeFrom(const EventOptionMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .com.ea.eamobile.nfsmw.protoc.CashRewardMessage cashReward = 1;
  inline bool has_cashreward() const;
  inline void clear_cashreward();
  static const int kCashRewardFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::CashRewardMessage& cashreward() const;
  inline ::com::ea::eamobile::nfsmw::protoc::CashRewardMessage* mutable_cashreward();
  inline ::com::ea::eamobile::nfsmw::protoc::CashRewardMessage* release_cashreward();
  
  // optional .com.ea.eamobile.nfsmw.protoc.OpponentCollectionMessage opponentCollection = 2;
  inline bool has_opponentcollection() const;
  inline void clear_opponentcollection();
  static const int kOpponentCollectionFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage& opponentcollection() const;
  inline ::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage* mutable_opponentcollection();
  inline ::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage* release_opponentcollection();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RaceEventMessage raceEvent = 3;
  inline bool has_raceevent() const;
  inline void clear_raceevent();
  static const int kRaceEventFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::RaceEventMessage& raceevent() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RaceEventMessage* mutable_raceevent();
  inline ::com::ea::eamobile::nfsmw::protoc::RaceEventMessage* release_raceevent();
  
  // optional .com.ea.eamobile.nfsmw.protoc.TrafficFlowMessage trafficFlow = 4;
  inline bool has_trafficflow() const;
  inline void clear_trafficflow();
  static const int kTrafficFlowFieldNumber = 4;
  inline const ::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage& trafficflow() const;
  inline ::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage* mutable_trafficflow();
  inline ::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage* release_trafficflow();
  
  // required int32 modeId = 5;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 5;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.MedalPositionMessage MedalPosition = 6;
  inline bool has_medalposition() const;
  inline void clear_medalposition();
  static const int kMedalPositionFieldNumber = 6;
  inline const ::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage& medalposition() const;
  inline ::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage* mutable_medalposition();
  inline ::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage* release_medalposition();
  
  // required string FileName = 7;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 7;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // optional .com.ea.eamobile.nfsmw.protoc.MedalScoreMessage MedalScore = 8;
  inline bool has_medalscore() const;
  inline void clear_medalscore();
  static const int kMedalScoreFieldNumber = 8;
  inline const ::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage& medalscore() const;
  inline ::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage* mutable_medalscore();
  inline ::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage* release_medalscore();
  
  // optional .com.ea.eamobile.nfsmw.protoc.MedalTimeMessage MedalTime = 9;
  inline bool has_medaltime() const;
  inline void clear_medaltime();
  static const int kMedalTimeFieldNumber = 9;
  inline const ::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage& medaltime() const;
  inline ::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage* mutable_medaltime();
  inline ::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage* release_medaltime();
  
  // optional .com.ea.eamobile.nfsmw.protoc.CountdownInitialTimeMessage InitialTime = 10;
  inline bool has_initialtime() const;
  inline void clear_initialtime();
  static const int kInitialTimeFieldNumber = 10;
  inline const ::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage& initialtime() const;
  inline ::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage* mutable_initialtime();
  inline ::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage* release_initialtime();
  
  // optional .com.ea.eamobile.nfsmw.protoc.PenaltyTimeMessage PenaltyTime = 11;
  inline bool has_penaltytime() const;
  inline void clear_penaltytime();
  static const int kPenaltyTimeFieldNumber = 11;
  inline const ::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage& penaltytime() const;
  inline ::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage* mutable_penaltytime();
  inline ::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage* release_penaltytime();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.EventOptionMessage)
 private:
  inline void set_has_cashreward();
  inline void clear_has_cashreward();
  inline void set_has_opponentcollection();
  inline void clear_has_opponentcollection();
  inline void set_has_raceevent();
  inline void clear_has_raceevent();
  inline void set_has_trafficflow();
  inline void clear_has_trafficflow();
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_medalposition();
  inline void clear_has_medalposition();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_medalscore();
  inline void clear_has_medalscore();
  inline void set_has_medaltime();
  inline void clear_has_medaltime();
  inline void set_has_initialtime();
  inline void clear_has_initialtime();
  inline void set_has_penaltytime();
  inline void clear_has_penaltytime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::CashRewardMessage* cashreward_;
  ::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage* opponentcollection_;
  ::com::ea::eamobile::nfsmw::protoc::RaceEventMessage* raceevent_;
  ::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage* trafficflow_;
  ::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage* medalposition_;
  ::std::string* filename_;
  ::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage* medalscore_;
  ::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage* medaltime_;
  ::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage* initialtime_;
  ::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage* penaltytime_;
  ::google::protobuf::int32 modeid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static EventOptionMessage* default_instance_;
};
// -------------------------------------------------------------------

class CashRewardMessage : public ::google::protobuf::Message {
 public:
  CashRewardMessage();
  virtual ~CashRewardMessage();
  
  CashRewardMessage(const CashRewardMessage& from);
  
  inline CashRewardMessage& operator=(const CashRewardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CashRewardMessage& default_instance();
  
  void Swap(CashRewardMessage* other);
  
  // implements Message ----------------------------------------------
  
  CashRewardMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CashRewardMessage& from);
  void MergeFrom(const CashRewardMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 bronze = 1;
  inline bool has_bronze() const;
  inline void clear_bronze();
  static const int kBronzeFieldNumber = 1;
  inline ::google::protobuf::int32 bronze() const;
  inline void set_bronze(::google::protobuf::int32 value);
  
  // optional int32 silver = 2;
  inline bool has_silver() const;
  inline void clear_silver();
  static const int kSilverFieldNumber = 2;
  inline ::google::protobuf::int32 silver() const;
  inline void set_silver(::google::protobuf::int32 value);
  
  // optional int32 gold = 3;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 3;
  inline ::google::protobuf::int32 gold() const;
  inline void set_gold(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.CashRewardMessage)
 private:
  inline void set_has_bronze();
  inline void clear_has_bronze();
  inline void set_has_silver();
  inline void clear_has_silver();
  inline void set_has_gold();
  inline void clear_has_gold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 bronze_;
  ::google::protobuf::int32 silver_;
  ::google::protobuf::int32 gold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static CashRewardMessage* default_instance_;
};
// -------------------------------------------------------------------

class MedalPositionMessage : public ::google::protobuf::Message {
 public:
  MedalPositionMessage();
  virtual ~MedalPositionMessage();
  
  MedalPositionMessage(const MedalPositionMessage& from);
  
  inline MedalPositionMessage& operator=(const MedalPositionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MedalPositionMessage& default_instance();
  
  void Swap(MedalPositionMessage* other);
  
  // implements Message ----------------------------------------------
  
  MedalPositionMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MedalPositionMessage& from);
  void MergeFrom(const MedalPositionMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 PositionBronze = 1;
  inline bool has_positionbronze() const;
  inline void clear_positionbronze();
  static const int kPositionBronzeFieldNumber = 1;
  inline ::google::protobuf::int32 positionbronze() const;
  inline void set_positionbronze(::google::protobuf::int32 value);
  
  // optional int32 PositionSilver = 2;
  inline bool has_positionsilver() const;
  inline void clear_positionsilver();
  static const int kPositionSilverFieldNumber = 2;
  inline ::google::protobuf::int32 positionsilver() const;
  inline void set_positionsilver(::google::protobuf::int32 value);
  
  // optional int32 PositionGold = 3;
  inline bool has_positiongold() const;
  inline void clear_positiongold();
  static const int kPositionGoldFieldNumber = 3;
  inline ::google::protobuf::int32 positiongold() const;
  inline void set_positiongold(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.MedalPositionMessage)
 private:
  inline void set_has_positionbronze();
  inline void clear_has_positionbronze();
  inline void set_has_positionsilver();
  inline void clear_has_positionsilver();
  inline void set_has_positiongold();
  inline void clear_has_positiongold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 positionbronze_;
  ::google::protobuf::int32 positionsilver_;
  ::google::protobuf::int32 positiongold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static MedalPositionMessage* default_instance_;
};
// -------------------------------------------------------------------

class MedalScoreMessage : public ::google::protobuf::Message {
 public:
  MedalScoreMessage();
  virtual ~MedalScoreMessage();
  
  MedalScoreMessage(const MedalScoreMessage& from);
  
  inline MedalScoreMessage& operator=(const MedalScoreMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MedalScoreMessage& default_instance();
  
  void Swap(MedalScoreMessage* other);
  
  // implements Message ----------------------------------------------
  
  MedalScoreMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MedalScoreMessage& from);
  void MergeFrom(const MedalScoreMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 ScoreBronze = 1;
  inline bool has_scorebronze() const;
  inline void clear_scorebronze();
  static const int kScoreBronzeFieldNumber = 1;
  inline ::google::protobuf::int32 scorebronze() const;
  inline void set_scorebronze(::google::protobuf::int32 value);
  
  // optional int32 ScoreSilver = 2;
  inline bool has_scoresilver() const;
  inline void clear_scoresilver();
  static const int kScoreSilverFieldNumber = 2;
  inline ::google::protobuf::int32 scoresilver() const;
  inline void set_scoresilver(::google::protobuf::int32 value);
  
  // optional int32 ScoreGold = 3;
  inline bool has_scoregold() const;
  inline void clear_scoregold();
  static const int kScoreGoldFieldNumber = 3;
  inline ::google::protobuf::int32 scoregold() const;
  inline void set_scoregold(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.MedalScoreMessage)
 private:
  inline void set_has_scorebronze();
  inline void clear_has_scorebronze();
  inline void set_has_scoresilver();
  inline void clear_has_scoresilver();
  inline void set_has_scoregold();
  inline void clear_has_scoregold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 scorebronze_;
  ::google::protobuf::int32 scoresilver_;
  ::google::protobuf::int32 scoregold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static MedalScoreMessage* default_instance_;
};
// -------------------------------------------------------------------

class MedalTimeMessage : public ::google::protobuf::Message {
 public:
  MedalTimeMessage();
  virtual ~MedalTimeMessage();
  
  MedalTimeMessage(const MedalTimeMessage& from);
  
  inline MedalTimeMessage& operator=(const MedalTimeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MedalTimeMessage& default_instance();
  
  void Swap(MedalTimeMessage* other);
  
  // implements Message ----------------------------------------------
  
  MedalTimeMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MedalTimeMessage& from);
  void MergeFrom(const MedalTimeMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float TimeBronze = 1;
  inline bool has_timebronze() const;
  inline void clear_timebronze();
  static const int kTimeBronzeFieldNumber = 1;
  inline float timebronze() const;
  inline void set_timebronze(float value);
  
  // optional float TimeSilver = 2;
  inline bool has_timesilver() const;
  inline void clear_timesilver();
  static const int kTimeSilverFieldNumber = 2;
  inline float timesilver() const;
  inline void set_timesilver(float value);
  
  // optional float TimeGold = 3;
  inline bool has_timegold() const;
  inline void clear_timegold();
  static const int kTimeGoldFieldNumber = 3;
  inline float timegold() const;
  inline void set_timegold(float value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.MedalTimeMessage)
 private:
  inline void set_has_timebronze();
  inline void clear_has_timebronze();
  inline void set_has_timesilver();
  inline void clear_has_timesilver();
  inline void set_has_timegold();
  inline void clear_has_timegold();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float timebronze_;
  float timesilver_;
  float timegold_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static MedalTimeMessage* default_instance_;
};
// -------------------------------------------------------------------

class CountdownInitialTimeMessage : public ::google::protobuf::Message {
 public:
  CountdownInitialTimeMessage();
  virtual ~CountdownInitialTimeMessage();
  
  CountdownInitialTimeMessage(const CountdownInitialTimeMessage& from);
  
  inline CountdownInitialTimeMessage& operator=(const CountdownInitialTimeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CountdownInitialTimeMessage& default_instance();
  
  void Swap(CountdownInitialTimeMessage* other);
  
  // implements Message ----------------------------------------------
  
  CountdownInitialTimeMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CountdownInitialTimeMessage& from);
  void MergeFrom(const CountdownInitialTimeMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float InitialTime = 1;
  inline bool has_initialtime() const;
  inline void clear_initialtime();
  static const int kInitialTimeFieldNumber = 1;
  inline float initialtime() const;
  inline void set_initialtime(float value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.CountdownInitialTimeMessage)
 private:
  inline void set_has_initialtime();
  inline void clear_has_initialtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float initialtime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static CountdownInitialTimeMessage* default_instance_;
};
// -------------------------------------------------------------------

class PenaltyTimeMessage : public ::google::protobuf::Message {
 public:
  PenaltyTimeMessage();
  virtual ~PenaltyTimeMessage();
  
  PenaltyTimeMessage(const PenaltyTimeMessage& from);
  
  inline PenaltyTimeMessage& operator=(const PenaltyTimeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PenaltyTimeMessage& default_instance();
  
  void Swap(PenaltyTimeMessage* other);
  
  // implements Message ----------------------------------------------
  
  PenaltyTimeMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PenaltyTimeMessage& from);
  void MergeFrom(const PenaltyTimeMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float MaximumTime = 1;
  inline bool has_maximumtime() const;
  inline void clear_maximumtime();
  static const int kMaximumTimeFieldNumber = 1;
  inline float maximumtime() const;
  inline void set_maximumtime(float value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.PenaltyTimeMessage)
 private:
  inline void set_has_maximumtime();
  inline void clear_has_maximumtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float maximumtime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static PenaltyTimeMessage* default_instance_;
};
// -------------------------------------------------------------------

class OpponentCollectionMessage : public ::google::protobuf::Message {
 public:
  OpponentCollectionMessage();
  virtual ~OpponentCollectionMessage();
  
  OpponentCollectionMessage(const OpponentCollectionMessage& from);
  
  inline OpponentCollectionMessage& operator=(const OpponentCollectionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpponentCollectionMessage& default_instance();
  
  void Swap(OpponentCollectionMessage* other);
  
  // implements Message ----------------------------------------------
  
  OpponentCollectionMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpponentCollectionMessage& from);
  void MergeFrom(const OpponentCollectionMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.OpponentMessage opponent = 1;
  inline int opponent_size() const;
  inline void clear_opponent();
  static const int kOpponentFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::OpponentMessage& opponent(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::OpponentMessage* mutable_opponent(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::OpponentMessage* add_opponent();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::OpponentMessage >&
      opponent() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::OpponentMessage >*
      mutable_opponent();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.OpponentCollectionMessage)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::OpponentMessage > opponent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static OpponentCollectionMessage* default_instance_;
};
// -------------------------------------------------------------------

class OpponentMessage : public ::google::protobuf::Message {
 public:
  OpponentMessage();
  virtual ~OpponentMessage();
  
  OpponentMessage(const OpponentMessage& from);
  
  inline OpponentMessage& operator=(const OpponentMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpponentMessage& default_instance();
  
  void Swap(OpponentMessage* other);
  
  // implements Message ----------------------------------------------
  
  OpponentMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpponentMessage& from);
  void MergeFrom(const OpponentMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string driverName = 1;
  inline bool has_drivername() const;
  inline void clear_drivername();
  static const int kDriverNameFieldNumber = 1;
  inline const ::std::string& drivername() const;
  inline void set_drivername(const ::std::string& value);
  inline void set_drivername(const char* value);
  inline void set_drivername(const char* value, size_t size);
  inline ::std::string* mutable_drivername();
  inline ::std::string* release_drivername();
  
  // optional string carDescriptionName = 2;
  inline bool has_cardescriptionname() const;
  inline void clear_cardescriptionname();
  static const int kCarDescriptionNameFieldNumber = 2;
  inline const ::std::string& cardescriptionname() const;
  inline void set_cardescriptionname(const ::std::string& value);
  inline void set_cardescriptionname(const char* value);
  inline void set_cardescriptionname(const char* value, size_t size);
  inline ::std::string* mutable_cardescriptionname();
  inline ::std::string* release_cardescriptionname();
  
  // optional int32 colourIndex = 3;
  inline bool has_colourindex() const;
  inline void clear_colourindex();
  static const int kColourIndexFieldNumber = 3;
  inline ::google::protobuf::int32 colourindex() const;
  inline void set_colourindex(::google::protobuf::int32 value);
  
  // optional bool stationary = 4;
  inline bool has_stationary() const;
  inline void clear_stationary();
  static const int kStationaryFieldNumber = 4;
  inline bool stationary() const;
  inline void set_stationary(bool value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.AiSettingsMessage aiSettings = 5;
  inline bool has_aisettings() const;
  inline void clear_aisettings();
  static const int kAiSettingsFieldNumber = 5;
  inline const ::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage& aisettings() const;
  inline ::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage* mutable_aisettings();
  inline ::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage* release_aisettings();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.OpponentMessage)
 private:
  inline void set_has_drivername();
  inline void clear_has_drivername();
  inline void set_has_cardescriptionname();
  inline void clear_has_cardescriptionname();
  inline void set_has_colourindex();
  inline void clear_has_colourindex();
  inline void set_has_stationary();
  inline void clear_has_stationary();
  inline void set_has_aisettings();
  inline void clear_has_aisettings();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* drivername_;
  ::std::string* cardescriptionname_;
  ::google::protobuf::int32 colourindex_;
  bool stationary_;
  ::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage* aisettings_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static OpponentMessage* default_instance_;
};
// -------------------------------------------------------------------

class AiSettingsMessage : public ::google::protobuf::Message {
 public:
  AiSettingsMessage();
  virtual ~AiSettingsMessage();
  
  AiSettingsMessage(const AiSettingsMessage& from);
  
  inline AiSettingsMessage& operator=(const AiSettingsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AiSettingsMessage& default_instance();
  
  void Swap(AiSettingsMessage* other);
  
  // implements Message ----------------------------------------------
  
  AiSettingsMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AiSettingsMessage& from);
  void MergeFrom(const AiSettingsMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float speedFactor = 1;
  inline bool has_speedfactor() const;
  inline void clear_speedfactor();
  static const int kSpeedFactorFieldNumber = 1;
  inline float speedfactor() const;
  inline void set_speedfactor(float value);
  
  // optional float corneringFactor = 2;
  inline bool has_corneringfactor() const;
  inline void clear_corneringfactor();
  static const int kCorneringFactorFieldNumber = 2;
  inline float corneringfactor() const;
  inline void set_corneringfactor(float value);
  
  // optional float racingLineScale = 3;
  inline bool has_racinglinescale() const;
  inline void clear_racinglinescale();
  static const int kRacingLineScaleFieldNumber = 3;
  inline float racinglinescale() const;
  inline void set_racinglinescale(float value);
  
  // optional int32 rubberBandingTweaksToUse = 4;
  inline bool has_rubberbandingtweakstouse() const;
  inline void clear_rubberbandingtweakstouse();
  static const int kRubberBandingTweaksToUseFieldNumber = 4;
  inline ::google::protobuf::int32 rubberbandingtweakstouse() const;
  inline void set_rubberbandingtweakstouse(::google::protobuf::int32 value);
  
  // optional float rubberBandingDifficulty = 5;
  inline bool has_rubberbandingdifficulty() const;
  inline void clear_rubberbandingdifficulty();
  static const int kRubberBandingDifficultyFieldNumber = 5;
  inline float rubberbandingdifficulty() const;
  inline void set_rubberbandingdifficulty(float value);
  
  // optional float rubberBandingTargetDifficulty = 6;
  inline bool has_rubberbandingtargetdifficulty() const;
  inline void clear_rubberbandingtargetdifficulty();
  static const int kRubberBandingTargetDifficultyFieldNumber = 6;
  inline float rubberbandingtargetdifficulty() const;
  inline void set_rubberbandingtargetdifficulty(float value);
  
  // optional float pathfindingSkill = 7;
  inline bool has_pathfindingskill() const;
  inline void clear_pathfindingskill();
  static const int kPathfindingSkillFieldNumber = 7;
  inline float pathfindingskill() const;
  inline void set_pathfindingskill(float value);
  
  // optional float nitroSkill = 8;
  inline bool has_nitroskill() const;
  inline void clear_nitroskill();
  static const int kNitroSkillFieldNumber = 8;
  inline float nitroskill() const;
  inline void set_nitroskill(float value);
  
  // optional float maxHealth = 9;
  inline bool has_maxhealth() const;
  inline void clear_maxhealth();
  static const int kMaxHealthFieldNumber = 9;
  inline float maxhealth() const;
  inline void set_maxhealth(float value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.AiSettingsMessage)
 private:
  inline void set_has_speedfactor();
  inline void clear_has_speedfactor();
  inline void set_has_corneringfactor();
  inline void clear_has_corneringfactor();
  inline void set_has_racinglinescale();
  inline void clear_has_racinglinescale();
  inline void set_has_rubberbandingtweakstouse();
  inline void clear_has_rubberbandingtweakstouse();
  inline void set_has_rubberbandingdifficulty();
  inline void clear_has_rubberbandingdifficulty();
  inline void set_has_rubberbandingtargetdifficulty();
  inline void clear_has_rubberbandingtargetdifficulty();
  inline void set_has_pathfindingskill();
  inline void clear_has_pathfindingskill();
  inline void set_has_nitroskill();
  inline void clear_has_nitroskill();
  inline void set_has_maxhealth();
  inline void clear_has_maxhealth();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float speedfactor_;
  float corneringfactor_;
  float racinglinescale_;
  ::google::protobuf::int32 rubberbandingtweakstouse_;
  float rubberbandingdifficulty_;
  float rubberbandingtargetdifficulty_;
  float pathfindingskill_;
  float nitroskill_;
  float maxhealth_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static AiSettingsMessage* default_instance_;
};
// -------------------------------------------------------------------

class RaceEventMessage : public ::google::protobuf::Message {
 public:
  RaceEventMessage();
  virtual ~RaceEventMessage();
  
  RaceEventMessage(const RaceEventMessage& from);
  
  inline RaceEventMessage& operator=(const RaceEventMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RaceEventMessage& default_instance();
  
  void Swap(RaceEventMessage* other);
  
  // implements Message ----------------------------------------------
  
  RaceEventMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaceEventMessage& from);
  void MergeFrom(const RaceEventMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string raceType = 1;
  inline bool has_racetype() const;
  inline void clear_racetype();
  static const int kRaceTypeFieldNumber = 1;
  inline const ::std::string& racetype() const;
  inline void set_racetype(const ::std::string& value);
  inline void set_racetype(const char* value);
  inline void set_racetype(const char* value, size_t size);
  inline ::std::string* mutable_racetype();
  inline ::std::string* release_racetype();
  
  // optional string raceFSMPrefabOverride = 2;
  inline bool has_racefsmprefaboverride() const;
  inline void clear_racefsmprefaboverride();
  static const int kRaceFSMPrefabOverrideFieldNumber = 2;
  inline const ::std::string& racefsmprefaboverride() const;
  inline void set_racefsmprefaboverride(const ::std::string& value);
  inline void set_racefsmprefaboverride(const char* value);
  inline void set_racefsmprefaboverride(const char* value, size_t size);
  inline ::std::string* mutable_racefsmprefaboverride();
  inline ::std::string* release_racefsmprefaboverride();
  
  // optional string carRestriction = 3;
  inline bool has_carrestriction() const;
  inline void clear_carrestriction();
  static const int kCarRestrictionFieldNumber = 3;
  inline const ::std::string& carrestriction() const;
  inline void set_carrestriction(const ::std::string& value);
  inline void set_carrestriction(const char* value);
  inline void set_carrestriction(const char* value, size_t size);
  inline ::std::string* mutable_carrestriction();
  inline ::std::string* release_carrestriction();
  
  // optional string trackName = 4;
  inline bool has_trackname() const;
  inline void clear_trackname();
  static const int kTrackNameFieldNumber = 4;
  inline const ::std::string& trackname() const;
  inline void set_trackname(const ::std::string& value);
  inline void set_trackname(const char* value);
  inline void set_trackname(const char* value, size_t size);
  inline ::std::string* mutable_trackname();
  inline ::std::string* release_trackname();
  
  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional string location = 6;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 6;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  
  // optional bool blacklistEvent = 7;
  inline bool has_blacklistevent() const;
  inline void clear_blacklistevent();
  static const int kBlacklistEventFieldNumber = 7;
  inline bool blacklistevent() const;
  inline void set_blacklistevent(bool value);
  
  // optional int32 classRestriction = 8;
  inline bool has_classrestriction() const;
  inline void clear_classrestriction();
  static const int kClassRestrictionFieldNumber = 8;
  inline ::google::protobuf::int32 classrestriction() const;
  inline void set_classrestriction(::google::protobuf::int32 value);
  
  // optional string environmentPrefab = 9;
  inline bool has_environmentprefab() const;
  inline void clear_environmentprefab();
  static const int kEnvironmentPrefabFieldNumber = 9;
  inline const ::std::string& environmentprefab() const;
  inline void set_environmentprefab(const ::std::string& value);
  inline void set_environmentprefab(const char* value);
  inline void set_environmentprefab(const char* value, size_t size);
  inline ::std::string* mutable_environmentprefab();
  inline ::std::string* release_environmentprefab();
  
  // optional int32 trafficCarCount = 10;
  inline bool has_trafficcarcount() const;
  inline void clear_trafficcarcount();
  static const int kTrafficCarCountFieldNumber = 10;
  inline ::google::protobuf::int32 trafficcarcount() const;
  inline void set_trafficcarcount(::google::protobuf::int32 value);
  
  // optional bool openWorldTrack = 11;
  inline bool has_openworldtrack() const;
  inline void clear_openworldtrack();
  static const int kOpenWorldTrackFieldNumber = 11;
  inline bool openworldtrack() const;
  inline void set_openworldtrack(bool value);
  
  // optional int32 autoLogId = 12;
  inline bool has_autologid() const;
  inline void clear_autologid();
  static const int kAutoLogIdFieldNumber = 12;
  inline ::google::protobuf::int32 autologid() const;
  inline void set_autologid(::google::protobuf::int32 value);
  
  // optional string pursuitType = 13;
  inline bool has_pursuittype() const;
  inline void clear_pursuittype();
  static const int kPursuitTypeFieldNumber = 13;
  inline const ::std::string& pursuittype() const;
  inline void set_pursuittype(const ::std::string& value);
  inline void set_pursuittype(const char* value);
  inline void set_pursuittype(const char* value, size_t size);
  inline ::std::string* mutable_pursuittype();
  inline ::std::string* release_pursuittype();
  
  // optional float startLineNoSpawnZone = 14;
  inline bool has_startlinenospawnzone() const;
  inline void clear_startlinenospawnzone();
  static const int kStartLineNoSpawnZoneFieldNumber = 14;
  inline float startlinenospawnzone() const;
  inline void set_startlinenospawnzone(float value);
  
  // optional float finishLineNoSpawnZone = 15;
  inline bool has_finishlinenospawnzone() const;
  inline void clear_finishlinenospawnzone();
  static const int kFinishLineNoSpawnZoneFieldNumber = 15;
  inline float finishlinenospawnzone() const;
  inline void set_finishlinenospawnzone(float value);
  
  // optional float spawnDistance = 16;
  inline bool has_spawndistance() const;
  inline void clear_spawndistance();
  static const int kSpawnDistanceFieldNumber = 16;
  inline float spawndistance() const;
  inline void set_spawndistance(float value);
  
  // optional string startLine = 17;
  inline bool has_startline() const;
  inline void clear_startline();
  static const int kStartLineFieldNumber = 17;
  inline const ::std::string& startline() const;
  inline void set_startline(const ::std::string& value);
  inline void set_startline(const char* value);
  inline void set_startline(const char* value, size_t size);
  inline ::std::string* mutable_startline();
  inline ::std::string* release_startline();
  
  // optional string finishLine = 18;
  inline bool has_finishline() const;
  inline void clear_finishline();
  static const int kFinishLineFieldNumber = 18;
  inline const ::std::string& finishline() const;
  inline void set_finishline(const ::std::string& value);
  inline void set_finishline(const char* value);
  inline void set_finishline(const char* value, size_t size);
  inline ::std::string* mutable_finishline();
  inline ::std::string* release_finishline();
  
  // optional string endOfTrack = 19;
  inline bool has_endoftrack() const;
  inline void clear_endoftrack();
  static const int kEndOfTrackFieldNumber = 19;
  inline const ::std::string& endoftrack() const;
  inline void set_endoftrack(const ::std::string& value);
  inline void set_endoftrack(const char* value);
  inline void set_endoftrack(const char* value, size_t size);
  inline ::std::string* mutable_endoftrack();
  inline ::std::string* release_endoftrack();
  
  // optional string checkpointCollection = 20;
  inline bool has_checkpointcollection() const;
  inline void clear_checkpointcollection();
  static const int kCheckpointCollectionFieldNumber = 20;
  inline const ::std::string& checkpointcollection() const;
  inline void set_checkpointcollection(const ::std::string& value);
  inline void set_checkpointcollection(const char* value);
  inline void set_checkpointcollection(const char* value, size_t size);
  inline ::std::string* mutable_checkpointcollection();
  inline ::std::string* release_checkpointcollection();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RaceEventMessage)
 private:
  inline void set_has_racetype();
  inline void clear_has_racetype();
  inline void set_has_racefsmprefaboverride();
  inline void clear_has_racefsmprefaboverride();
  inline void set_has_carrestriction();
  inline void clear_has_carrestriction();
  inline void set_has_trackname();
  inline void clear_has_trackname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_blacklistevent();
  inline void clear_has_blacklistevent();
  inline void set_has_classrestriction();
  inline void clear_has_classrestriction();
  inline void set_has_environmentprefab();
  inline void clear_has_environmentprefab();
  inline void set_has_trafficcarcount();
  inline void clear_has_trafficcarcount();
  inline void set_has_openworldtrack();
  inline void clear_has_openworldtrack();
  inline void set_has_autologid();
  inline void clear_has_autologid();
  inline void set_has_pursuittype();
  inline void clear_has_pursuittype();
  inline void set_has_startlinenospawnzone();
  inline void clear_has_startlinenospawnzone();
  inline void set_has_finishlinenospawnzone();
  inline void clear_has_finishlinenospawnzone();
  inline void set_has_spawndistance();
  inline void clear_has_spawndistance();
  inline void set_has_startline();
  inline void clear_has_startline();
  inline void set_has_finishline();
  inline void clear_has_finishline();
  inline void set_has_endoftrack();
  inline void clear_has_endoftrack();
  inline void set_has_checkpointcollection();
  inline void clear_has_checkpointcollection();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* racetype_;
  ::std::string* racefsmprefaboverride_;
  ::std::string* carrestriction_;
  ::std::string* trackname_;
  ::std::string* name_;
  ::std::string* location_;
  ::google::protobuf::int32 classrestriction_;
  bool blacklistevent_;
  bool openworldtrack_;
  ::std::string* environmentprefab_;
  ::google::protobuf::int32 trafficcarcount_;
  ::google::protobuf::int32 autologid_;
  ::std::string* pursuittype_;
  float startlinenospawnzone_;
  float finishlinenospawnzone_;
  ::std::string* startline_;
  ::std::string* finishline_;
  ::std::string* endoftrack_;
  ::std::string* checkpointcollection_;
  float spawndistance_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RaceEventMessage* default_instance_;
};
// -------------------------------------------------------------------

class TrafficFlowMessage : public ::google::protobuf::Message {
 public:
  TrafficFlowMessage();
  virtual ~TrafficFlowMessage();
  
  TrafficFlowMessage(const TrafficFlowMessage& from);
  
  inline TrafficFlowMessage& operator=(const TrafficFlowMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficFlowMessage& default_instance();
  
  void Swap(TrafficFlowMessage* other);
  
  // implements Message ----------------------------------------------
  
  TrafficFlowMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrafficFlowMessage& from);
  void MergeFrom(const TrafficFlowMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 maxIncomingCarsOverride = 1;
  inline bool has_maxincomingcarsoverride() const;
  inline void clear_maxincomingcarsoverride();
  static const int kMaxIncomingCarsOverrideFieldNumber = 1;
  inline ::google::protobuf::int32 maxincomingcarsoverride() const;
  inline void set_maxincomingcarsoverride(::google::protobuf::int32 value);
  
  // optional int32 maxOutcomingCarsOverride = 2;
  inline bool has_maxoutcomingcarsoverride() const;
  inline void clear_maxoutcomingcarsoverride();
  static const int kMaxOutcomingCarsOverrideFieldNumber = 2;
  inline ::google::protobuf::int32 maxoutcomingcarsoverride() const;
  inline void set_maxoutcomingcarsoverride(::google::protobuf::int32 value);
  
  // optional float outgoingLightMinDistance = 3;
  inline bool has_outgoinglightmindistance() const;
  inline void clear_outgoinglightmindistance();
  static const int kOutgoingLightMinDistanceFieldNumber = 3;
  inline float outgoinglightmindistance() const;
  inline void set_outgoinglightmindistance(float value);
  
  // optional float outgoingLightMaxDistance = 4;
  inline bool has_outgoinglightmaxdistance() const;
  inline void clear_outgoinglightmaxdistance();
  static const int kOutgoingLightMaxDistanceFieldNumber = 4;
  inline float outgoinglightmaxdistance() const;
  inline void set_outgoinglightmaxdistance(float value);
  
  // optional float outgoingHeavyMinDistance = 5;
  inline bool has_outgoingheavymindistance() const;
  inline void clear_outgoingheavymindistance();
  static const int kOutgoingHeavyMinDistanceFieldNumber = 5;
  inline float outgoingheavymindistance() const;
  inline void set_outgoingheavymindistance(float value);
  
  // optional float outgoingHeavyMaxDistance = 6;
  inline bool has_outgoingheavymaxdistance() const;
  inline void clear_outgoingheavymaxdistance();
  static const int kOutgoingHeavyMaxDistanceFieldNumber = 6;
  inline float outgoingheavymaxdistance() const;
  inline void set_outgoingheavymaxdistance(float value);
  
  // optional float incomingLightMinDistance = 7;
  inline bool has_incominglightmindistance() const;
  inline void clear_incominglightmindistance();
  static const int kIncomingLightMinDistanceFieldNumber = 7;
  inline float incominglightmindistance() const;
  inline void set_incominglightmindistance(float value);
  
  // optional float incomingLightMaxDistance = 8;
  inline bool has_incominglightmaxdistance() const;
  inline void clear_incominglightmaxdistance();
  static const int kIncomingLightMaxDistanceFieldNumber = 8;
  inline float incominglightmaxdistance() const;
  inline void set_incominglightmaxdistance(float value);
  
  // optional float incomingHeavyMinDistance = 9;
  inline bool has_incomingheavymindistance() const;
  inline void clear_incomingheavymindistance();
  static const int kIncomingHeavyMinDistanceFieldNumber = 9;
  inline float incomingheavymindistance() const;
  inline void set_incomingheavymindistance(float value);
  
  // optional float incomingHeavyMaxDistance = 10;
  inline bool has_incomingheavymaxdistance() const;
  inline void clear_incomingheavymaxdistance();
  static const int kIncomingHeavyMaxDistanceFieldNumber = 10;
  inline float incomingheavymaxdistance() const;
  inline void set_incomingheavymaxdistance(float value);
  
  // optional float intialNoTrafficDistance = 11;
  inline bool has_intialnotrafficdistance() const;
  inline void clear_intialnotrafficdistance();
  static const int kIntialNoTrafficDistanceFieldNumber = 11;
  inline float intialnotrafficdistance() const;
  inline void set_intialnotrafficdistance(float value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RaceTrafficCongestionMessage raceTrafficCongestion = 12;
  inline int racetrafficcongestion_size() const;
  inline void clear_racetrafficcongestion();
  static const int kRaceTrafficCongestionFieldNumber = 12;
  inline const ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage& racetrafficcongestion(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage* mutable_racetrafficcongestion(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage* add_racetrafficcongestion();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage >&
      racetrafficcongestion() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage >*
      mutable_racetrafficcongestion();
  
  // optional .com.ea.eamobile.nfsmw.protoc.TrafficCarSpawnDescsMessage trfficCarSpawnDescs = 13;
  inline bool has_trfficcarspawndescs() const;
  inline void clear_trfficcarspawndescs();
  static const int kTrfficCarSpawnDescsFieldNumber = 13;
  inline const ::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage& trfficcarspawndescs() const;
  inline ::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage* mutable_trfficcarspawndescs();
  inline ::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage* release_trfficcarspawndescs();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TrafficFlowMessage)
 private:
  inline void set_has_maxincomingcarsoverride();
  inline void clear_has_maxincomingcarsoverride();
  inline void set_has_maxoutcomingcarsoverride();
  inline void clear_has_maxoutcomingcarsoverride();
  inline void set_has_outgoinglightmindistance();
  inline void clear_has_outgoinglightmindistance();
  inline void set_has_outgoinglightmaxdistance();
  inline void clear_has_outgoinglightmaxdistance();
  inline void set_has_outgoingheavymindistance();
  inline void clear_has_outgoingheavymindistance();
  inline void set_has_outgoingheavymaxdistance();
  inline void clear_has_outgoingheavymaxdistance();
  inline void set_has_incominglightmindistance();
  inline void clear_has_incominglightmindistance();
  inline void set_has_incominglightmaxdistance();
  inline void clear_has_incominglightmaxdistance();
  inline void set_has_incomingheavymindistance();
  inline void clear_has_incomingheavymindistance();
  inline void set_has_incomingheavymaxdistance();
  inline void clear_has_incomingheavymaxdistance();
  inline void set_has_intialnotrafficdistance();
  inline void clear_has_intialnotrafficdistance();
  inline void set_has_trfficcarspawndescs();
  inline void clear_has_trfficcarspawndescs();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 maxincomingcarsoverride_;
  ::google::protobuf::int32 maxoutcomingcarsoverride_;
  float outgoinglightmindistance_;
  float outgoinglightmaxdistance_;
  float outgoingheavymindistance_;
  float outgoingheavymaxdistance_;
  float incominglightmindistance_;
  float incominglightmaxdistance_;
  float incomingheavymindistance_;
  float incomingheavymaxdistance_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage > racetrafficcongestion_;
  ::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage* trfficcarspawndescs_;
  float intialnotrafficdistance_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TrafficFlowMessage* default_instance_;
};
// -------------------------------------------------------------------

class RaceTrafficCongestionMessage : public ::google::protobuf::Message {
 public:
  RaceTrafficCongestionMessage();
  virtual ~RaceTrafficCongestionMessage();
  
  RaceTrafficCongestionMessage(const RaceTrafficCongestionMessage& from);
  
  inline RaceTrafficCongestionMessage& operator=(const RaceTrafficCongestionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RaceTrafficCongestionMessage& default_instance();
  
  void Swap(RaceTrafficCongestionMessage* other);
  
  // implements Message ----------------------------------------------
  
  RaceTrafficCongestionMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaceTrafficCongestionMessage& from);
  void MergeFrom(const RaceTrafficCongestionMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float raceCompletetionFactor = 1;
  inline bool has_racecompletetionfactor() const;
  inline void clear_racecompletetionfactor();
  static const int kRaceCompletetionFactorFieldNumber = 1;
  inline float racecompletetionfactor() const;
  inline void set_racecompletetionfactor(float value);
  
  // optional float outgoingTrafficCongestionFactor = 2;
  inline bool has_outgoingtrafficcongestionfactor() const;
  inline void clear_outgoingtrafficcongestionfactor();
  static const int kOutgoingTrafficCongestionFactorFieldNumber = 2;
  inline float outgoingtrafficcongestionfactor() const;
  inline void set_outgoingtrafficcongestionfactor(float value);
  
  // optional float oncomingTrafficCongestionFactor = 3;
  inline bool has_oncomingtrafficcongestionfactor() const;
  inline void clear_oncomingtrafficcongestionfactor();
  static const int kOncomingTrafficCongestionFactorFieldNumber = 3;
  inline float oncomingtrafficcongestionfactor() const;
  inline void set_oncomingtrafficcongestionfactor(float value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RaceTrafficCongestionMessage)
 private:
  inline void set_has_racecompletetionfactor();
  inline void clear_has_racecompletetionfactor();
  inline void set_has_outgoingtrafficcongestionfactor();
  inline void clear_has_outgoingtrafficcongestionfactor();
  inline void set_has_oncomingtrafficcongestionfactor();
  inline void clear_has_oncomingtrafficcongestionfactor();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float racecompletetionfactor_;
  float outgoingtrafficcongestionfactor_;
  float oncomingtrafficcongestionfactor_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RaceTrafficCongestionMessage* default_instance_;
};
// -------------------------------------------------------------------

class TrafficCarSpawnDescsMessage : public ::google::protobuf::Message {
 public:
  TrafficCarSpawnDescsMessage();
  virtual ~TrafficCarSpawnDescsMessage();
  
  TrafficCarSpawnDescsMessage(const TrafficCarSpawnDescsMessage& from);
  
  inline TrafficCarSpawnDescsMessage& operator=(const TrafficCarSpawnDescsMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficCarSpawnDescsMessage& default_instance();
  
  void Swap(TrafficCarSpawnDescsMessage* other);
  
  // implements Message ----------------------------------------------
  
  TrafficCarSpawnDescsMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrafficCarSpawnDescsMessage& from);
  void MergeFrom(const TrafficCarSpawnDescsMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string prefabld = 1;
  inline int prefabld_size() const;
  inline void clear_prefabld();
  static const int kPrefabldFieldNumber = 1;
  inline const ::std::string& prefabld(int index) const;
  inline ::std::string* mutable_prefabld(int index);
  inline void set_prefabld(int index, const ::std::string& value);
  inline void set_prefabld(int index, const char* value);
  inline void set_prefabld(int index, const char* value, size_t size);
  inline ::std::string* add_prefabld();
  inline void add_prefabld(const ::std::string& value);
  inline void add_prefabld(const char* value);
  inline void add_prefabld(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& prefabld() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_prefabld();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.TrafficCarSpawnDescsMessage)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> prefabld_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static TrafficCarSpawnDescsMessage* default_instance_;
};
// -------------------------------------------------------------------

class RequestRegistJaguarCommand : public ::google::protobuf::Message {
 public:
  RequestRegistJaguarCommand();
  virtual ~RequestRegistJaguarCommand();
  
  RequestRegistJaguarCommand(const RequestRegistJaguarCommand& from);
  
  inline RequestRegistJaguarCommand& operator=(const RequestRegistJaguarCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRegistJaguarCommand& default_instance();
  
  void Swap(RequestRegistJaguarCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestRegistJaguarCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRegistJaguarCommand& from);
  void MergeFrom(const RequestRegistJaguarCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 jaguarType = 1;
  inline bool has_jaguartype() const;
  inline void clear_jaguartype();
  static const int kJaguarTypeFieldNumber = 1;
  inline ::google::protobuf::int32 jaguartype() const;
  inline void set_jaguartype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestRegistJaguarCommand)
 private:
  inline void set_has_jaguartype();
  inline void clear_has_jaguartype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 jaguartype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestRegistJaguarCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRegistJaguarCommand : public ::google::protobuf::Message {
 public:
  ResponseRegistJaguarCommand();
  virtual ~ResponseRegistJaguarCommand();
  
  ResponseRegistJaguarCommand(const ResponseRegistJaguarCommand& from);
  
  inline ResponseRegistJaguarCommand& operator=(const ResponseRegistJaguarCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRegistJaguarCommand& default_instance();
  
  void Swap(ResponseRegistJaguarCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseRegistJaguarCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseRegistJaguarCommand& from);
  void MergeFrom(const ResponseRegistJaguarCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool levelRaceCanUse = 1;
  inline bool has_levelracecanuse() const;
  inline void clear_levelracecanuse();
  static const int kLevelRaceCanUseFieldNumber = 1;
  inline bool levelracecanuse() const;
  inline void set_levelracecanuse(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseRegistJaguarCommand)
 private:
  inline void set_has_levelracecanuse();
  inline void clear_has_levelracecanuse();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool levelracecanuse_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseRegistJaguarCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestRpLeaderboardCommand : public ::google::protobuf::Message {
 public:
  RequestRpLeaderboardCommand();
  virtual ~RequestRpLeaderboardCommand();
  
  RequestRpLeaderboardCommand(const RequestRpLeaderboardCommand& from);
  
  inline RequestRpLeaderboardCommand& operator=(const RequestRpLeaderboardCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRpLeaderboardCommand& default_instance();
  
  void Swap(RequestRpLeaderboardCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestRpLeaderboardCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRpLeaderboardCommand& from);
  void MergeFrom(const RequestRpLeaderboardCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional bool hasProfileUI = 2;
  inline bool has_hasprofileui() const;
  inline void clear_hasprofileui();
  static const int kHasProfileUIFieldNumber = 2;
  inline bool hasprofileui() const;
  inline void set_hasprofileui(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestRpLeaderboardCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_hasprofileui();
  inline void clear_has_hasprofileui();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 type_;
  bool hasprofileui_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestRpLeaderboardCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseRpLeaderboardCommand : public ::google::protobuf::Message {
 public:
  ResponseRpLeaderboardCommand();
  virtual ~ResponseRpLeaderboardCommand();
  
  ResponseRpLeaderboardCommand(const ResponseRpLeaderboardCommand& from);
  
  inline ResponseRpLeaderboardCommand& operator=(const ResponseRpLeaderboardCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseRpLeaderboardCommand& default_instance();
  
  void Swap(ResponseRpLeaderboardCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseRpLeaderboardCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseRpLeaderboardCommand& from);
  void MergeFrom(const ResponseRpLeaderboardCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RpLeaderboardMessage rpLeaderboard = 2;
  inline int rpleaderboard_size() const;
  inline void clear_rpleaderboard();
  static const int kRpLeaderboardFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage& rpleaderboard(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage* mutable_rpleaderboard(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage* add_rpleaderboard();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage >&
      rpleaderboard() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage >*
      mutable_rpleaderboard();
  
  // required int32 selfRank = 3;
  inline bool has_selfrank() const;
  inline void clear_selfrank();
  static const int kSelfRankFieldNumber = 3;
  inline ::google::protobuf::int32 selfrank() const;
  inline void set_selfrank(::google::protobuf::int32 value);
  
  // required int32 selfHeadIndex = 4;
  inline bool has_selfheadindex() const;
  inline void clear_selfheadindex();
  static const int kSelfHeadIndexFieldNumber = 4;
  inline ::google::protobuf::int32 selfheadindex() const;
  inline void set_selfheadindex(::google::protobuf::int32 value);
  
  // optional string selfHeadUrl = 5;
  inline bool has_selfheadurl() const;
  inline void clear_selfheadurl();
  static const int kSelfHeadUrlFieldNumber = 5;
  inline const ::std::string& selfheadurl() const;
  inline void set_selfheadurl(const ::std::string& value);
  inline void set_selfheadurl(const char* value);
  inline void set_selfheadurl(const char* value, size_t size);
  inline ::std::string* mutable_selfheadurl();
  inline ::std::string* release_selfheadurl();
  
  // required string selfName = 6;
  inline bool has_selfname() const;
  inline void clear_selfname();
  static const int kSelfNameFieldNumber = 6;
  inline const ::std::string& selfname() const;
  inline void set_selfname(const ::std::string& value);
  inline void set_selfname(const char* value);
  inline void set_selfname(const char* value, size_t size);
  inline ::std::string* mutable_selfname();
  inline ::std::string* release_selfname();
  
  // required int32 selfRpLevel = 7;
  inline bool has_selfrplevel() const;
  inline void clear_selfrplevel();
  static const int kSelfRpLevelFieldNumber = 7;
  inline ::google::protobuf::int32 selfrplevel() const;
  inline void set_selfrplevel(::google::protobuf::int32 value);
  
  // required int32 selfRpNum = 8;
  inline bool has_selfrpnum() const;
  inline void clear_selfrpnum();
  static const int kSelfRpNumFieldNumber = 8;
  inline ::google::protobuf::int32 selfrpnum() const;
  inline void set_selfrpnum(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseRpLeaderboardCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_selfrank();
  inline void clear_has_selfrank();
  inline void set_has_selfheadindex();
  inline void clear_has_selfheadindex();
  inline void set_has_selfheadurl();
  inline void clear_has_selfheadurl();
  inline void set_has_selfname();
  inline void clear_has_selfname();
  inline void set_has_selfrplevel();
  inline void clear_has_selfrplevel();
  inline void set_has_selfrpnum();
  inline void clear_has_selfrpnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage > rpleaderboard_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 selfrank_;
  ::std::string* selfheadurl_;
  ::google::protobuf::int32 selfheadindex_;
  ::google::protobuf::int32 selfrplevel_;
  ::std::string* selfname_;
  ::google::protobuf::int32 selfrpnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseRpLeaderboardCommand* default_instance_;
};
// -------------------------------------------------------------------

class RpLeaderboardMessage : public ::google::protobuf::Message {
 public:
  RpLeaderboardMessage();
  virtual ~RpLeaderboardMessage();
  
  RpLeaderboardMessage(const RpLeaderboardMessage& from);
  
  inline RpLeaderboardMessage& operator=(const RpLeaderboardMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RpLeaderboardMessage& default_instance();
  
  void Swap(RpLeaderboardMessage* other);
  
  // implements Message ----------------------------------------------
  
  RpLeaderboardMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RpLeaderboardMessage& from);
  void MergeFrom(const RpLeaderboardMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // required int32 headIndex = 2;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 2;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // optional string headUrl = 3;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 3;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 rpLevel = 5;
  inline bool has_rplevel() const;
  inline void clear_rplevel();
  static const int kRpLevelFieldNumber = 5;
  inline ::google::protobuf::int32 rplevel() const;
  inline void set_rplevel(::google::protobuf::int32 value);
  
  // required int32 rpNum = 6;
  inline bool has_rpnum() const;
  inline void clear_rpnum();
  static const int kRpNumFieldNumber = 6;
  inline ::google::protobuf::int32 rpnum() const;
  inline void set_rpnum(::google::protobuf::int32 value);
  
  // optional int64 userId = 7;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 7;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RpLeaderboardMessage)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rplevel();
  inline void clear_has_rplevel();
  inline void set_has_rpnum();
  inline void clear_has_rpnum();
  inline void set_has_userid();
  inline void clear_has_userid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 headindex_;
  ::std::string* headurl_;
  ::std::string* name_;
  ::google::protobuf::int32 rplevel_;
  ::google::protobuf::int32 rpnum_;
  ::google::protobuf::int64 userid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RpLeaderboardMessage* default_instance_;
};
// -------------------------------------------------------------------

class ProfileCarInfo : public ::google::protobuf::Message {
 public:
  ProfileCarInfo();
  virtual ~ProfileCarInfo();
  
  ProfileCarInfo(const ProfileCarInfo& from);
  
  inline ProfileCarInfo& operator=(const ProfileCarInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfileCarInfo& default_instance();
  
  void Swap(ProfileCarInfo* other);
  
  // implements Message ----------------------------------------------
  
  ProfileCarInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProfileCarInfo& from);
  void MergeFrom(const ProfileCarInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 userCarId = 1;
  inline bool has_usercarid() const;
  inline void clear_usercarid();
  static const int kUserCarIdFieldNumber = 1;
  inline ::google::protobuf::int64 usercarid() const;
  inline void set_usercarid(::google::protobuf::int64 value);
  
  // required string carId = 2;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 2;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // repeated int32 slotLevel = 3;
  inline int slotlevel_size() const;
  inline void clear_slotlevel();
  static const int kSlotLevelFieldNumber = 3;
  inline ::google::protobuf::int32 slotlevel(int index) const;
  inline void set_slotlevel(int index, ::google::protobuf::int32 value);
  inline void add_slotlevel(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      slotlevel() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_slotlevel();
  
  // required int32 carPaintJobIndex = 4;
  inline bool has_carpaintjobindex() const;
  inline void clear_carpaintjobindex();
  static const int kCarPaintJobIndexFieldNumber = 4;
  inline ::google::protobuf::int32 carpaintjobindex() const;
  inline void set_carpaintjobindex(::google::protobuf::int32 value);
  
  // required int32 carScore = 5;
  inline bool has_carscore() const;
  inline void clear_carscore();
  static const int kCarScoreFieldNumber = 5;
  inline ::google::protobuf::int32 carscore() const;
  inline void set_carscore(::google::protobuf::int32 value);
  
  // required int64 likeNum = 6;
  inline bool has_likenum() const;
  inline void clear_likenum();
  static const int kLikeNumFieldNumber = 6;
  inline ::google::protobuf::int64 likenum() const;
  inline void set_likenum(::google::protobuf::int64 value);
  
  // required bool canLike = 7;
  inline bool has_canlike() const;
  inline void clear_canlike();
  static const int kCanLikeFieldNumber = 7;
  inline bool canlike() const;
  inline void set_canlike(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ProfileCarInfo)
 private:
  inline void set_has_usercarid();
  inline void clear_has_usercarid();
  inline void set_has_carid();
  inline void clear_has_carid();
  inline void set_has_carpaintjobindex();
  inline void clear_has_carpaintjobindex();
  inline void set_has_carscore();
  inline void clear_has_carscore();
  inline void set_has_likenum();
  inline void clear_has_likenum();
  inline void set_has_canlike();
  inline void clear_has_canlike();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 usercarid_;
  ::std::string* carid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > slotlevel_;
  ::google::protobuf::int32 carpaintjobindex_;
  ::google::protobuf::int32 carscore_;
  ::google::protobuf::int64 likenum_;
  bool canlike_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ProfileCarInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestProfileUserDataCommand : public ::google::protobuf::Message {
 public:
  RequestProfileUserDataCommand();
  virtual ~RequestProfileUserDataCommand();
  
  RequestProfileUserDataCommand(const RequestProfileUserDataCommand& from);
  
  inline RequestProfileUserDataCommand& operator=(const RequestProfileUserDataCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestProfileUserDataCommand& default_instance();
  
  void Swap(RequestProfileUserDataCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestProfileUserDataCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestProfileUserDataCommand& from);
  void MergeFrom(const RequestProfileUserDataCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 profileId = 1;
  inline bool has_profileid() const;
  inline void clear_profileid();
  static const int kProfileIdFieldNumber = 1;
  inline ::google::protobuf::int64 profileid() const;
  inline void set_profileid(::google::protobuf::int64 value);
  
  // required int32 sourceTypeId = 2;
  inline bool has_sourcetypeid() const;
  inline void clear_sourcetypeid();
  static const int kSourceTypeIdFieldNumber = 2;
  inline ::google::protobuf::int32 sourcetypeid() const;
  inline void set_sourcetypeid(::google::protobuf::int32 value);
  
  // required int32 tournamentOnlineId = 3;
  inline bool has_tournamentonlineid() const;
  inline void clear_tournamentonlineid();
  static const int kTournamentOnlineIdFieldNumber = 3;
  inline ::google::protobuf::int32 tournamentonlineid() const;
  inline void set_tournamentonlineid(::google::protobuf::int32 value);
  
  // required int32 tournamentGroupId = 4;
  inline bool has_tournamentgroupid() const;
  inline void clear_tournamentgroupid();
  static const int kTournamentGroupIdFieldNumber = 4;
  inline ::google::protobuf::int32 tournamentgroupid() const;
  inline void set_tournamentgroupid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestProfileUserDataCommand)
 private:
  inline void set_has_profileid();
  inline void clear_has_profileid();
  inline void set_has_sourcetypeid();
  inline void clear_has_sourcetypeid();
  inline void set_has_tournamentonlineid();
  inline void clear_has_tournamentonlineid();
  inline void set_has_tournamentgroupid();
  inline void clear_has_tournamentgroupid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 profileid_;
  ::google::protobuf::int32 sourcetypeid_;
  ::google::protobuf::int32 tournamentonlineid_;
  ::google::protobuf::int32 tournamentgroupid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestProfileUserDataCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseProfileUserDataCommand : public ::google::protobuf::Message {
 public:
  ResponseProfileUserDataCommand();
  virtual ~ResponseProfileUserDataCommand();
  
  ResponseProfileUserDataCommand(const ResponseProfileUserDataCommand& from);
  
  inline ResponseProfileUserDataCommand& operator=(const ResponseProfileUserDataCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseProfileUserDataCommand& default_instance();
  
  void Swap(ResponseProfileUserDataCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseProfileUserDataCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseProfileUserDataCommand& from);
  void MergeFrom(const ResponseProfileUserDataCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  
  // required string headUrl = 2;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 2;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // required int32 headIndex = 3;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 3;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // required int32 rpLevel = 4;
  inline bool has_rplevel() const;
  inline void clear_rplevel();
  static const int kRpLevelFieldNumber = 4;
  inline ::google::protobuf::int32 rplevel() const;
  inline void set_rplevel(::google::protobuf::int32 value);
  
  // required int32 rpExp = 5;
  inline bool has_rpexp() const;
  inline void clear_rpexp();
  static const int kRpExpFieldNumber = 5;
  inline ::google::protobuf::int32 rpexp() const;
  inline void set_rpexp(::google::protobuf::int32 value);
  
  // required int32 mostwantedNum = 6;
  inline bool has_mostwantednum() const;
  inline void clear_mostwantednum();
  static const int kMostwantedNumFieldNumber = 6;
  inline ::google::protobuf::int32 mostwantednum() const;
  inline void set_mostwantednum(::google::protobuf::int32 value);
  
  // required int32 carNum = 7;
  inline bool has_carnum() const;
  inline void clear_carnum();
  static const int kCarNumFieldNumber = 7;
  inline ::google::protobuf::int32 carnum() const;
  inline void set_carnum(::google::protobuf::int32 value);
  
  // required int32 garageScore = 8;
  inline bool has_garagescore() const;
  inline void clear_garagescore();
  static const int kGarageScoreFieldNumber = 8;
  inline ::google::protobuf::int32 garagescore() const;
  inline void set_garagescore(::google::protobuf::int32 value);
  
  // required bool canReport = 9;
  inline bool has_canreport() const;
  inline void clear_canreport();
  static const int kCanReportFieldNumber = 9;
  inline bool canreport() const;
  inline void set_canreport(bool value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.ProfileCarInfo carInfo = 10;
  inline bool has_carinfo() const;
  inline void clear_carinfo();
  static const int kCarInfoFieldNumber = 10;
  inline const ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo& carinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* mutable_carinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* release_carinfo();
  
  // repeated string ownedCarId = 11;
  inline int ownedcarid_size() const;
  inline void clear_ownedcarid();
  static const int kOwnedCarIdFieldNumber = 11;
  inline const ::std::string& ownedcarid(int index) const;
  inline ::std::string* mutable_ownedcarid(int index);
  inline void set_ownedcarid(int index, const ::std::string& value);
  inline void set_ownedcarid(int index, const char* value);
  inline void set_ownedcarid(int index, const char* value, size_t size);
  inline ::std::string* add_ownedcarid();
  inline void add_ownedcarid(const ::std::string& value);
  inline void add_ownedcarid(const char* value);
  inline void add_ownedcarid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ownedcarid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ownedcarid();
  
  // repeated int64 ownedUserCarId = 12;
  inline int ownedusercarid_size() const;
  inline void clear_ownedusercarid();
  static const int kOwnedUserCarIdFieldNumber = 12;
  inline ::google::protobuf::int64 ownedusercarid(int index) const;
  inline void set_ownedusercarid(int index, ::google::protobuf::int64 value);
  inline void add_ownedusercarid(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      ownedusercarid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_ownedusercarid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseProfileUserDataCommand)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_rplevel();
  inline void clear_has_rplevel();
  inline void set_has_rpexp();
  inline void clear_has_rpexp();
  inline void set_has_mostwantednum();
  inline void clear_has_mostwantednum();
  inline void set_has_carnum();
  inline void clear_has_carnum();
  inline void set_has_garagescore();
  inline void clear_has_garagescore();
  inline void set_has_canreport();
  inline void clear_has_canreport();
  inline void set_has_carinfo();
  inline void clear_has_carinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* nickname_;
  ::std::string* headurl_;
  ::google::protobuf::int32 headindex_;
  ::google::protobuf::int32 rplevel_;
  ::google::protobuf::int32 rpexp_;
  ::google::protobuf::int32 mostwantednum_;
  ::google::protobuf::int32 carnum_;
  ::google::protobuf::int32 garagescore_;
  ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* carinfo_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ownedcarid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > ownedusercarid_;
  bool canreport_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseProfileUserDataCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestProfileNextCarCommand : public ::google::protobuf::Message {
 public:
  RequestProfileNextCarCommand();
  virtual ~RequestProfileNextCarCommand();
  
  RequestProfileNextCarCommand(const RequestProfileNextCarCommand& from);
  
  inline RequestProfileNextCarCommand& operator=(const RequestProfileNextCarCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestProfileNextCarCommand& default_instance();
  
  void Swap(RequestProfileNextCarCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestProfileNextCarCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestProfileNextCarCommand& from);
  void MergeFrom(const RequestProfileNextCarCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 userCarId = 1;
  inline bool has_usercarid() const;
  inline void clear_usercarid();
  static const int kUserCarIdFieldNumber = 1;
  inline ::google::protobuf::int64 usercarid() const;
  inline void set_usercarid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestProfileNextCarCommand)
 private:
  inline void set_has_usercarid();
  inline void clear_has_usercarid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 usercarid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestProfileNextCarCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseProfileNextCarCommand : public ::google::protobuf::Message {
 public:
  ResponseProfileNextCarCommand();
  virtual ~ResponseProfileNextCarCommand();
  
  ResponseProfileNextCarCommand(const ResponseProfileNextCarCommand& from);
  
  inline ResponseProfileNextCarCommand& operator=(const ResponseProfileNextCarCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseProfileNextCarCommand& default_instance();
  
  void Swap(ResponseProfileNextCarCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseProfileNextCarCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseProfileNextCarCommand& from);
  void MergeFrom(const ResponseProfileNextCarCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.ea.eamobile.nfsmw.protoc.ProfileCarInfo carInfo = 1;
  inline bool has_carinfo() const;
  inline void clear_carinfo();
  static const int kCarInfoFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo& carinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* mutable_carinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* release_carinfo();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseProfileNextCarCommand)
 private:
  inline void set_has_carinfo();
  inline void clear_has_carinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* carinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseProfileNextCarCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestProfileLikeCommand : public ::google::protobuf::Message {
 public:
  RequestProfileLikeCommand();
  virtual ~RequestProfileLikeCommand();
  
  RequestProfileLikeCommand(const RequestProfileLikeCommand& from);
  
  inline RequestProfileLikeCommand& operator=(const RequestProfileLikeCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestProfileLikeCommand& default_instance();
  
  void Swap(RequestProfileLikeCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestProfileLikeCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestProfileLikeCommand& from);
  void MergeFrom(const RequestProfileLikeCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 userCarId = 1;
  inline bool has_usercarid() const;
  inline void clear_usercarid();
  static const int kUserCarIdFieldNumber = 1;
  inline ::google::protobuf::int64 usercarid() const;
  inline void set_usercarid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestProfileLikeCommand)
 private:
  inline void set_has_usercarid();
  inline void clear_has_usercarid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 usercarid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestProfileLikeCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseProfileLikeCommand : public ::google::protobuf::Message {
 public:
  ResponseProfileLikeCommand();
  virtual ~ResponseProfileLikeCommand();
  
  ResponseProfileLikeCommand(const ResponseProfileLikeCommand& from);
  
  inline ResponseProfileLikeCommand& operator=(const ResponseProfileLikeCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseProfileLikeCommand& default_instance();
  
  void Swap(ResponseProfileLikeCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseProfileLikeCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseProfileLikeCommand& from);
  void MergeFrom(const ResponseProfileLikeCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 likeNum = 1;
  inline bool has_likenum() const;
  inline void clear_likenum();
  static const int kLikeNumFieldNumber = 1;
  inline ::google::protobuf::int64 likenum() const;
  inline void set_likenum(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseProfileLikeCommand)
 private:
  inline void set_has_likenum();
  inline void clear_has_likenum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 likenum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseProfileLikeCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestProfileReportCommand : public ::google::protobuf::Message {
 public:
  RequestProfileReportCommand();
  virtual ~RequestProfileReportCommand();
  
  RequestProfileReportCommand(const RequestProfileReportCommand& from);
  
  inline RequestProfileReportCommand& operator=(const RequestProfileReportCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestProfileReportCommand& default_instance();
  
  void Swap(RequestProfileReportCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestProfileReportCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestProfileReportCommand& from);
  void MergeFrom(const RequestProfileReportCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 profileId = 1;
  inline bool has_profileid() const;
  inline void clear_profileid();
  static const int kProfileIdFieldNumber = 1;
  inline ::google::protobuf::int64 profileid() const;
  inline void set_profileid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestProfileReportCommand)
 private:
  inline void set_has_profileid();
  inline void clear_has_profileid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 profileid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestProfileReportCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseProfileReportCommand : public ::google::protobuf::Message {
 public:
  ResponseProfileReportCommand();
  virtual ~ResponseProfileReportCommand();
  
  ResponseProfileReportCommand(const ResponseProfileReportCommand& from);
  
  inline ResponseProfileReportCommand& operator=(const ResponseProfileReportCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseProfileReportCommand& default_instance();
  
  void Swap(ResponseProfileReportCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseProfileReportCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseProfileReportCommand& from);
  void MergeFrom(const ResponseProfileReportCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseProfileReportCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseProfileReportCommand* default_instance_;
};
// -------------------------------------------------------------------

class UserVSProfile : public ::google::protobuf::Message {
 public:
  UserVSProfile();
  virtual ~UserVSProfile();
  
  UserVSProfile(const UserVSProfile& from);
  
  inline UserVSProfile& operator=(const UserVSProfile& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserVSProfile& default_instance();
  
  void Swap(UserVSProfile* other);
  
  // implements Message ----------------------------------------------
  
  UserVSProfile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserVSProfile& from);
  void MergeFrom(const UserVSProfile& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string titleStr = 1;
  inline bool has_titlestr() const;
  inline void clear_titlestr();
  static const int kTitleStrFieldNumber = 1;
  inline const ::std::string& titlestr() const;
  inline void set_titlestr(const ::std::string& value);
  inline void set_titlestr(const char* value);
  inline void set_titlestr(const char* value, size_t size);
  inline ::std::string* mutable_titlestr();
  inline ::std::string* release_titlestr();
  
  // required int32 playerValue = 2;
  inline bool has_playervalue() const;
  inline void clear_playervalue();
  static const int kPlayerValueFieldNumber = 2;
  inline ::google::protobuf::int32 playervalue() const;
  inline void set_playervalue(::google::protobuf::int32 value);
  
  // required int32 ghostValue = 3;
  inline bool has_ghostvalue() const;
  inline void clear_ghostvalue();
  static const int kGhostValueFieldNumber = 3;
  inline ::google::protobuf::int32 ghostvalue() const;
  inline void set_ghostvalue(::google::protobuf::int32 value);
  
  // required bool hasProgressBar = 4;
  inline bool has_hasprogressbar() const;
  inline void clear_hasprogressbar();
  static const int kHasProgressBarFieldNumber = 4;
  inline bool hasprogressbar() const;
  inline void set_hasprogressbar(bool value);
  
  // required string subTitleStr = 5;
  inline bool has_subtitlestr() const;
  inline void clear_subtitlestr();
  static const int kSubTitleStrFieldNumber = 5;
  inline const ::std::string& subtitlestr() const;
  inline void set_subtitlestr(const ::std::string& value);
  inline void set_subtitlestr(const char* value);
  inline void set_subtitlestr(const char* value, size_t size);
  inline ::std::string* mutable_subtitlestr();
  inline ::std::string* release_subtitlestr();
  
  // required string unitsStr = 6;
  inline bool has_unitsstr() const;
  inline void clear_unitsstr();
  static const int kUnitsStrFieldNumber = 6;
  inline const ::std::string& unitsstr() const;
  inline void set_unitsstr(const ::std::string& value);
  inline void set_unitsstr(const char* value);
  inline void set_unitsstr(const char* value, size_t size);
  inline ::std::string* mutable_unitsstr();
  inline ::std::string* release_unitsstr();
  
  // required int32 valueType = 7;
  inline bool has_valuetype() const;
  inline void clear_valuetype();
  static const int kValueTypeFieldNumber = 7;
  inline ::google::protobuf::int32 valuetype() const;
  inline void set_valuetype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.UserVSProfile)
 private:
  inline void set_has_titlestr();
  inline void clear_has_titlestr();
  inline void set_has_playervalue();
  inline void clear_has_playervalue();
  inline void set_has_ghostvalue();
  inline void clear_has_ghostvalue();
  inline void set_has_hasprogressbar();
  inline void clear_has_hasprogressbar();
  inline void set_has_subtitlestr();
  inline void clear_has_subtitlestr();
  inline void set_has_unitsstr();
  inline void clear_has_unitsstr();
  inline void set_has_valuetype();
  inline void clear_has_valuetype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* titlestr_;
  ::google::protobuf::int32 playervalue_;
  ::google::protobuf::int32 ghostvalue_;
  ::std::string* subtitlestr_;
  bool hasprogressbar_;
  ::google::protobuf::int32 valuetype_;
  ::std::string* unitsstr_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static UserVSProfile* default_instance_;
};
// -------------------------------------------------------------------

class RequestProfileVSCommand : public ::google::protobuf::Message {
 public:
  RequestProfileVSCommand();
  virtual ~RequestProfileVSCommand();
  
  RequestProfileVSCommand(const RequestProfileVSCommand& from);
  
  inline RequestProfileVSCommand& operator=(const RequestProfileVSCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestProfileVSCommand& default_instance();
  
  void Swap(RequestProfileVSCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestProfileVSCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestProfileVSCommand& from);
  void MergeFrom(const RequestProfileVSCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int64 profileId = 1;
  inline bool has_profileid() const;
  inline void clear_profileid();
  static const int kProfileIdFieldNumber = 1;
  inline ::google::protobuf::int64 profileid() const;
  inline void set_profileid(::google::protobuf::int64 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestProfileVSCommand)
 private:
  inline void set_has_profileid();
  inline void clear_has_profileid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 profileid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestProfileVSCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseProfileVSCommand : public ::google::protobuf::Message {
 public:
  ResponseProfileVSCommand();
  virtual ~ResponseProfileVSCommand();
  
  ResponseProfileVSCommand(const ResponseProfileVSCommand& from);
  
  inline ResponseProfileVSCommand& operator=(const ResponseProfileVSCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseProfileVSCommand& default_instance();
  
  void Swap(ResponseProfileVSCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseProfileVSCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseProfileVSCommand& from);
  void MergeFrom(const ResponseProfileVSCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.UserVSProfile vsData = 1;
  inline int vsdata_size() const;
  inline void clear_vsdata();
  static const int kVsDataFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::UserVSProfile& vsdata(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::UserVSProfile* mutable_vsdata(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::UserVSProfile* add_vsdata();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::UserVSProfile >&
      vsdata() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::UserVSProfile >*
      mutable_vsdata();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseProfileVSCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::UserVSProfile > vsdata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseProfileVSCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestRecordUserRaceActionCommand : public ::google::protobuf::Message {
 public:
  RequestRecordUserRaceActionCommand();
  virtual ~RequestRecordUserRaceActionCommand();
  
  RequestRecordUserRaceActionCommand(const RequestRecordUserRaceActionCommand& from);
  
  inline RequestRecordUserRaceActionCommand& operator=(const RequestRecordUserRaceActionCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestRecordUserRaceActionCommand& default_instance();
  
  void Swap(RequestRecordUserRaceActionCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestRecordUserRaceActionCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestRecordUserRaceActionCommand& from);
  void MergeFrom(const RequestRecordUserRaceActionCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 copsKill = 1;
  inline bool has_copskill() const;
  inline void clear_copskill();
  static const int kCopsKillFieldNumber = 1;
  inline ::google::protobuf::int32 copskill() const;
  inline void set_copskill(::google::protobuf::int32 value);
  
  // required int32 consumable = 2;
  inline bool has_consumable() const;
  inline void clear_consumable();
  static const int kConsumableFieldNumber = 2;
  inline ::google::protobuf::int32 consumable() const;
  inline void set_consumable(::google::protobuf::int32 value);
  
  // required int32 drift = 3;
  inline bool has_drift() const;
  inline void clear_drift();
  static const int kDriftFieldNumber = 3;
  inline ::google::protobuf::int32 drift() const;
  inline void set_drift(::google::protobuf::int32 value);
  
  // required int32 jump = 4;
  inline bool has_jump() const;
  inline void clear_jump();
  static const int kJumpFieldNumber = 4;
  inline ::google::protobuf::int32 jump() const;
  inline void set_jump(::google::protobuf::int32 value);
  
  // required int32 billBoard = 5;
  inline bool has_billboard() const;
  inline void clear_billboard();
  static const int kBillBoardFieldNumber = 5;
  inline ::google::protobuf::int32 billboard() const;
  inline void set_billboard(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestRecordUserRaceActionCommand)
 private:
  inline void set_has_copskill();
  inline void clear_has_copskill();
  inline void set_has_consumable();
  inline void clear_has_consumable();
  inline void set_has_drift();
  inline void clear_has_drift();
  inline void set_has_jump();
  inline void clear_has_jump();
  inline void set_has_billboard();
  inline void clear_has_billboard();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 copskill_;
  ::google::protobuf::int32 consumable_;
  ::google::protobuf::int32 drift_;
  ::google::protobuf::int32 jump_;
  ::google::protobuf::int32 billboard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestRecordUserRaceActionCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestQuickRaceCommand : public ::google::protobuf::Message {
 public:
  RequestQuickRaceCommand();
  virtual ~RequestQuickRaceCommand();
  
  RequestQuickRaceCommand(const RequestQuickRaceCommand& from);
  
  inline RequestQuickRaceCommand& operator=(const RequestQuickRaceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuickRaceCommand& default_instance();
  
  void Swap(RequestQuickRaceCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestQuickRaceCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestQuickRaceCommand& from);
  void MergeFrom(const RequestQuickRaceCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestQuickRaceCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestQuickRaceCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseQuickRaceCommand : public ::google::protobuf::Message {
 public:
  ResponseQuickRaceCommand();
  virtual ~ResponseQuickRaceCommand();
  
  ResponseQuickRaceCommand(const ResponseQuickRaceCommand& from);
  
  inline ResponseQuickRaceCommand& operator=(const ResponseQuickRaceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuickRaceCommand& default_instance();
  
  void Swap(ResponseQuickRaceCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseQuickRaceCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseQuickRaceCommand& from);
  void MergeFrom(const ResponseQuickRaceCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.ea.eamobile.nfsmw.protoc.TrackInfo track = 1;
  inline bool has_track() const;
  inline void clear_track();
  static const int kTrackFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::TrackInfo& track() const;
  inline ::com::ea::eamobile::nfsmw::protoc::TrackInfo* mutable_track();
  inline ::com::ea::eamobile::nfsmw::protoc::TrackInfo* release_track();
  
  // required int32 trackIndex = 2;
  inline bool has_trackindex() const;
  inline void clear_trackindex();
  static const int kTrackIndexFieldNumber = 2;
  inline ::google::protobuf::int32 trackindex() const;
  inline void set_trackindex(::google::protobuf::int32 value);
  
  // required int32 modeId = 3;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 3;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.CheckPointInfo checkPointInfo = 4;
  inline bool has_checkpointinfo() const;
  inline void clear_checkpointinfo();
  static const int kCheckPointInfoFieldNumber = 4;
  inline const ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo& checkpointinfo() const;
  inline ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* mutable_checkpointinfo();
  inline ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* release_checkpointinfo();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseQuickRaceCommand)
 private:
  inline void set_has_track();
  inline void clear_has_track();
  inline void set_has_trackindex();
  inline void clear_has_trackindex();
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_checkpointinfo();
  inline void clear_has_checkpointinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::TrackInfo* track_;
  ::google::protobuf::int32 trackindex_;
  ::google::protobuf::int32 modeid_;
  ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* checkpointinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseQuickRaceCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseNotificationCommand : public ::google::protobuf::Message {
 public:
  ResponseNotificationCommand();
  virtual ~ResponseNotificationCommand();
  
  ResponseNotificationCommand(const ResponseNotificationCommand& from);
  
  inline ResponseNotificationCommand& operator=(const ResponseNotificationCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseNotificationCommand& default_instance();
  
  void Swap(ResponseNotificationCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseNotificationCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseNotificationCommand& from);
  void MergeFrom(const ResponseNotificationCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 iconId = 1;
  inline bool has_iconid() const;
  inline void clear_iconid();
  static const int kIconIdFieldNumber = 1;
  inline ::google::protobuf::int32 iconid() const;
  inline void set_iconid(::google::protobuf::int32 value);
  
  // required float duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline float duration() const;
  inline void set_duration(float value);
  
  // required string content = 3;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 3;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseNotificationCommand)
 private:
  inline void set_has_iconid();
  inline void clear_has_iconid();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_content();
  inline void clear_has_content();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 iconid_;
  float duration_;
  ::std::string* content_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseNotificationCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestGhostRecordCommand : public ::google::protobuf::Message {
 public:
  RequestGhostRecordCommand();
  virtual ~RequestGhostRecordCommand();
  
  RequestGhostRecordCommand(const RequestGhostRecordCommand& from);
  
  inline RequestGhostRecordCommand& operator=(const RequestGhostRecordCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGhostRecordCommand& default_instance();
  
  void Swap(RequestGhostRecordCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestGhostRecordCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestGhostRecordCommand& from);
  void MergeFrom(const RequestGhostRecordCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 modeId = 1;
  inline bool has_modeid() const;
  inline void clear_modeid();
  static const int kModeIdFieldNumber = 1;
  inline ::google::protobuf::int32 modeid() const;
  inline void set_modeid(::google::protobuf::int32 value);
  
  // required float raceTime = 2;
  inline bool has_racetime() const;
  inline void clear_racetime();
  static const int kRaceTimeFieldNumber = 2;
  inline float racetime() const;
  inline void set_racetime(float value);
  
  // required string carId = 3;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 3;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // repeated int32 carModType = 4;
  inline int carmodtype_size() const;
  inline void clear_carmodtype();
  static const int kCarModTypeFieldNumber = 4;
  inline ::google::protobuf::int32 carmodtype(int index) const;
  inline void set_carmodtype(int index, ::google::protobuf::int32 value);
  inline void add_carmodtype(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodtype() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodtype();
  
  // repeated float carModValue = 5;
  inline int carmodvalue_size() const;
  inline void clear_carmodvalue();
  static const int kCarModValueFieldNumber = 5;
  inline float carmodvalue(int index) const;
  inline void set_carmodvalue(int index, float value);
  inline void add_carmodvalue(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      carmodvalue() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_carmodvalue();
  
  // repeated int32 carModLevel = 6;
  inline int carmodlevel_size() const;
  inline void clear_carmodlevel();
  static const int kCarModLevelFieldNumber = 6;
  inline ::google::protobuf::int32 carmodlevel(int index) const;
  inline void set_carmodlevel(int index, ::google::protobuf::int32 value);
  inline void add_carmodlevel(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodlevel() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodlevel();
  
  // repeated int32 carModId = 7;
  inline int carmodid_size() const;
  inline void clear_carmodid();
  static const int kCarModIdFieldNumber = 7;
  inline ::google::protobuf::int32 carmodid(int index) const;
  inline void set_carmodid(int index, ::google::protobuf::int32 value);
  inline void add_carmodid(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      carmodid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_carmodid();
  
  // required int32 samplePeriod = 8;
  inline bool has_sampleperiod() const;
  inline void clear_sampleperiod();
  static const int kSamplePeriodFieldNumber = 8;
  inline ::google::protobuf::int32 sampleperiod() const;
  inline void set_sampleperiod(::google::protobuf::int32 value);
  
  // repeated float sampleData = 9;
  inline int sampledata_size() const;
  inline void clear_sampledata();
  static const int kSampleDataFieldNumber = 9;
  inline float sampledata(int index) const;
  inline void set_sampledata(int index, float value);
  inline void add_sampledata(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      sampledata() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_sampledata();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestGhostRecordCommand)
 private:
  inline void set_has_modeid();
  inline void clear_has_modeid();
  inline void set_has_racetime();
  inline void clear_has_racetime();
  inline void set_has_carid();
  inline void clear_has_carid();
  inline void set_has_sampleperiod();
  inline void clear_has_sampleperiod();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 modeid_;
  float racetime_;
  ::std::string* carid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodtype_;
  ::google::protobuf::RepeatedField< float > carmodvalue_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodlevel_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > carmodid_;
  ::google::protobuf::RepeatedField< float > sampledata_;
  ::google::protobuf::int32 sampleperiod_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestGhostRecordCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGhostRecordCommand : public ::google::protobuf::Message {
 public:
  ResponseGhostRecordCommand();
  virtual ~ResponseGhostRecordCommand();
  
  ResponseGhostRecordCommand(const ResponseGhostRecordCommand& from);
  
  inline ResponseGhostRecordCommand& operator=(const ResponseGhostRecordCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseGhostRecordCommand& default_instance();
  
  void Swap(ResponseGhostRecordCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseGhostRecordCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseGhostRecordCommand& from);
  void MergeFrom(const ResponseGhostRecordCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseGhostRecordCommand)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseGhostRecordCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestIapCheckCommand : public ::google::protobuf::Message {
 public:
  RequestIapCheckCommand();
  virtual ~RequestIapCheckCommand();
  
  RequestIapCheckCommand(const RequestIapCheckCommand& from);
  
  inline RequestIapCheckCommand& operator=(const RequestIapCheckCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestIapCheckCommand& default_instance();
  
  void Swap(RequestIapCheckCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestIapCheckCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestIapCheckCommand& from);
  void MergeFrom(const RequestIapCheckCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string receiptData = 1;
  inline bool has_receiptdata() const;
  inline void clear_receiptdata();
  static const int kReceiptDataFieldNumber = 1;
  inline const ::std::string& receiptdata() const;
  inline void set_receiptdata(const ::std::string& value);
  inline void set_receiptdata(const char* value);
  inline void set_receiptdata(const char* value, size_t size);
  inline ::std::string* mutable_receiptdata();
  inline ::std::string* release_receiptdata();
  
  // optional int32 ipspPurchaseItemCallBackType = 2;
  inline bool has_ipsppurchaseitemcallbacktype() const;
  inline void clear_ipsppurchaseitemcallbacktype();
  static const int kIpspPurchaseItemCallBackTypeFieldNumber = 2;
  inline ::google::protobuf::int32 ipsppurchaseitemcallbacktype() const;
  inline void set_ipsppurchaseitemcallbacktype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestIapCheckCommand)
 private:
  inline void set_has_receiptdata();
  inline void clear_has_receiptdata();
  inline void set_has_ipsppurchaseitemcallbacktype();
  inline void clear_has_ipsppurchaseitemcallbacktype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* receiptdata_;
  ::google::protobuf::int32 ipsppurchaseitemcallbacktype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestIapCheckCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseIapCheckCommand : public ::google::protobuf::Message {
 public:
  ResponseIapCheckCommand();
  virtual ~ResponseIapCheckCommand();
  
  ResponseIapCheckCommand(const ResponseIapCheckCommand& from);
  
  inline ResponseIapCheckCommand& operator=(const ResponseIapCheckCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseIapCheckCommand& default_instance();
  
  void Swap(ResponseIapCheckCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseIapCheckCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseIapCheckCommand& from);
  void MergeFrom(const ResponseIapCheckCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseIapCheckCommand)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_message();
  inline void clear_has_message();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* message_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseIapCheckCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTournamentNotificationCommand : public ::google::protobuf::Message {
 public:
  ResponseTournamentNotificationCommand();
  virtual ~ResponseTournamentNotificationCommand();
  
  ResponseTournamentNotificationCommand(const ResponseTournamentNotificationCommand& from);
  
  inline ResponseTournamentNotificationCommand& operator=(const ResponseTournamentNotificationCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTournamentNotificationCommand& default_instance();
  
  void Swap(ResponseTournamentNotificationCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTournamentNotificationCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTournamentNotificationCommand& from);
  void MergeFrom(const ResponseTournamentNotificationCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string message = 1;
  inline int message_size() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 1;
  inline const ::std::string& message(int index) const;
  inline ::std::string* mutable_message(int index);
  inline void set_message(int index, const ::std::string& value);
  inline void set_message(int index, const char* value);
  inline void set_message(int index, const char* value, size_t size);
  inline ::std::string* add_message();
  inline void add_message(const ::std::string& value);
  inline void add_message(const char* value);
  inline void add_message(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& message() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_message();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTournamentNotificationCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> message_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTournamentNotificationCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestTutorialRewardCommand : public ::google::protobuf::Message {
 public:
  RequestTutorialRewardCommand();
  virtual ~RequestTutorialRewardCommand();
  
  RequestTutorialRewardCommand(const RequestTutorialRewardCommand& from);
  
  inline RequestTutorialRewardCommand& operator=(const RequestTutorialRewardCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestTutorialRewardCommand& default_instance();
  
  void Swap(RequestTutorialRewardCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestTutorialRewardCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestTutorialRewardCommand& from);
  void MergeFrom(const RequestTutorialRewardCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool finishedAllTutorial = 1;
  inline bool has_finishedalltutorial() const;
  inline void clear_finishedalltutorial();
  static const int kFinishedAllTutorialFieldNumber = 1;
  inline bool finishedalltutorial() const;
  inline void set_finishedalltutorial(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestTutorialRewardCommand)
 private:
  inline void set_has_finishedalltutorial();
  inline void clear_has_finishedalltutorial();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool finishedalltutorial_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestTutorialRewardCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTutorialRewardCommand : public ::google::protobuf::Message {
 public:
  ResponseTutorialRewardCommand();
  virtual ~ResponseTutorialRewardCommand();
  
  ResponseTutorialRewardCommand(const ResponseTutorialRewardCommand& from);
  
  inline ResponseTutorialRewardCommand& operator=(const ResponseTutorialRewardCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTutorialRewardCommand& default_instance();
  
  void Swap(ResponseTutorialRewardCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTutorialRewardCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTutorialRewardCommand& from);
  void MergeFrom(const ResponseTutorialRewardCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);
  
  // optional .com.ea.eamobile.nfsmw.protoc.Reward reward = 2;
  inline bool has_reward() const;
  inline void clear_reward();
  static const int kRewardFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::Reward& reward() const;
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* mutable_reward();
  inline ::com::ea::eamobile::nfsmw::protoc::Reward* release_reward();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTutorialRewardCommand)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_reward();
  inline void clear_has_reward();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::Reward* reward_;
  bool success_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTutorialRewardCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponsePopupCommand : public ::google::protobuf::Message {
 public:
  ResponsePopupCommand();
  virtual ~ResponsePopupCommand();
  
  ResponsePopupCommand(const ResponsePopupCommand& from);
  
  inline ResponsePopupCommand& operator=(const ResponsePopupCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponsePopupCommand& default_instance();
  
  void Swap(ResponsePopupCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponsePopupCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponsePopupCommand& from);
  void MergeFrom(const ResponsePopupCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 popScreen = 1;
  inline bool has_popscreen() const;
  inline void clear_popscreen();
  static const int kPopScreenFieldNumber = 1;
  inline ::google::protobuf::int32 popscreen() const;
  inline void set_popscreen(::google::protobuf::int32 value);
  
  // optional string flowID = 2;
  inline bool has_flowid() const;
  inline void clear_flowid();
  static const int kFlowIDFieldNumber = 2;
  inline const ::std::string& flowid() const;
  inline void set_flowid(const ::std::string& value);
  inline void set_flowid(const char* value);
  inline void set_flowid(const char* value, size_t size);
  inline ::std::string* mutable_flowid();
  inline ::std::string* release_flowid();
  
  // required string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // optional string heading = 4;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 4;
  inline const ::std::string& heading() const;
  inline void set_heading(const ::std::string& value);
  inline void set_heading(const char* value);
  inline void set_heading(const char* value, size_t size);
  inline ::std::string* mutable_heading();
  inline ::std::string* release_heading();
  
  // optional string yesButtonID = 5;
  inline bool has_yesbuttonid() const;
  inline void clear_yesbuttonid();
  static const int kYesButtonIDFieldNumber = 5;
  inline const ::std::string& yesbuttonid() const;
  inline void set_yesbuttonid(const ::std::string& value);
  inline void set_yesbuttonid(const char* value);
  inline void set_yesbuttonid(const char* value, size_t size);
  inline ::std::string* mutable_yesbuttonid();
  inline ::std::string* release_yesbuttonid();
  
  // optional string noButtonID = 6;
  inline bool has_nobuttonid() const;
  inline void clear_nobuttonid();
  static const int kNoButtonIDFieldNumber = 6;
  inline const ::std::string& nobuttonid() const;
  inline void set_nobuttonid(const ::std::string& value);
  inline void set_nobuttonid(const char* value);
  inline void set_nobuttonid(const char* value, size_t size);
  inline ::std::string* mutable_nobuttonid();
  inline ::std::string* release_nobuttonid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponsePopupCommand)
 private:
  inline void set_has_popscreen();
  inline void clear_has_popscreen();
  inline void set_has_flowid();
  inline void clear_has_flowid();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_yesbuttonid();
  inline void clear_has_yesbuttonid();
  inline void set_has_nobuttonid();
  inline void clear_has_nobuttonid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* flowid_;
  ::std::string* text_;
  ::std::string* heading_;
  ::std::string* yesbuttonid_;
  ::std::string* nobuttonid_;
  ::google::protobuf::int32 popscreen_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponsePopupCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponsePopupListCommand : public ::google::protobuf::Message {
 public:
  ResponsePopupListCommand();
  virtual ~ResponsePopupListCommand();
  
  ResponsePopupListCommand(const ResponsePopupListCommand& from);
  
  inline ResponsePopupListCommand& operator=(const ResponsePopupListCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponsePopupListCommand& default_instance();
  
  void Swap(ResponsePopupListCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponsePopupListCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponsePopupListCommand& from);
  void MergeFrom(const ResponsePopupListCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.ResponsePopupCommand popups = 1;
  inline int popups_size() const;
  inline void clear_popups();
  static const int kPopupsFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand& popups(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* mutable_popups(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* add_popups();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand >&
      popups() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand >*
      mutable_popups();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponsePopupListCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand > popups_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponsePopupListCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTournamentRewardNumCommand : public ::google::protobuf::Message {
 public:
  ResponseTournamentRewardNumCommand();
  virtual ~ResponseTournamentRewardNumCommand();
  
  ResponseTournamentRewardNumCommand(const ResponseTournamentRewardNumCommand& from);
  
  inline ResponseTournamentRewardNumCommand& operator=(const ResponseTournamentRewardNumCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTournamentRewardNumCommand& default_instance();
  
  void Swap(ResponseTournamentRewardNumCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTournamentRewardNumCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTournamentRewardNumCommand& from);
  void MergeFrom(const ResponseTournamentRewardNumCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rewardNum = 1;
  inline bool has_rewardnum() const;
  inline void clear_rewardnum();
  static const int kRewardNumFieldNumber = 1;
  inline ::google::protobuf::int32 rewardnum() const;
  inline void set_rewardnum(::google::protobuf::int32 value);
  
  // repeated int32 endTime = 2;
  inline int endtime_size() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int32 endtime(int index) const;
  inline void set_endtime(int index, ::google::protobuf::int32 value);
  inline void add_endtime(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      endtime() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_endtime();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTournamentRewardNumCommand)
 private:
  inline void set_has_rewardnum();
  inline void clear_has_rewardnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > endtime_;
  ::google::protobuf::int32 rewardnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTournamentRewardNumCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestGotchaCommand : public ::google::protobuf::Message {
 public:
  RequestGotchaCommand();
  virtual ~RequestGotchaCommand();
  
  RequestGotchaCommand(const RequestGotchaCommand& from);
  
  inline RequestGotchaCommand& operator=(const RequestGotchaCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestGotchaCommand& default_instance();
  
  void Swap(RequestGotchaCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestGotchaCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestGotchaCommand& from);
  void MergeFrom(const RequestGotchaCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);
  
  // required string carId = 2;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 2;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestGotchaCommand)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_carid();
  inline void clear_has_carid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* carid_;
  ::google::protobuf::int32 level_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestGotchaCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseGotchaCommand : public ::google::protobuf::Message {
 public:
  ResponseGotchaCommand();
  virtual ~ResponseGotchaCommand();
  
  ResponseGotchaCommand(const ResponseGotchaCommand& from);
  
  inline ResponseGotchaCommand& operator=(const ResponseGotchaCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseGotchaCommand& default_instance();
  
  void Swap(ResponseGotchaCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseGotchaCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseGotchaCommand& from);
  void MergeFrom(const ResponseGotchaCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.GotchaItemInfo gotchaItems = 1;
  inline int gotchaitems_size() const;
  inline void clear_gotchaitems();
  static const int kGotchaItemsFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo& gotchaitems(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo* mutable_gotchaitems(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo* add_gotchaitems();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo >&
      gotchaitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo >*
      mutable_gotchaitems();
  
  // optional string globalMessage = 2;
  inline bool has_globalmessage() const;
  inline void clear_globalmessage();
  static const int kGlobalMessageFieldNumber = 2;
  inline const ::std::string& globalmessage() const;
  inline void set_globalmessage(const ::std::string& value);
  inline void set_globalmessage(const char* value);
  inline void set_globalmessage(const char* value, size_t size);
  inline ::std::string* mutable_globalmessage();
  inline ::std::string* release_globalmessage();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseGotchaCommand)
 private:
  inline void set_has_globalmessage();
  inline void clear_has_globalmessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo > gotchaitems_;
  ::std::string* globalmessage_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseGotchaCommand* default_instance_;
};
// -------------------------------------------------------------------

class GotchaItemInfo : public ::google::protobuf::Message {
 public:
  GotchaItemInfo();
  virtual ~GotchaItemInfo();
  
  GotchaItemInfo(const GotchaItemInfo& from);
  
  inline GotchaItemInfo& operator=(const GotchaItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GotchaItemInfo& default_instance();
  
  void Swap(GotchaItemInfo* other);
  
  // implements Message ----------------------------------------------
  
  GotchaItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GotchaItemInfo& from);
  void MergeFrom(const GotchaItemInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 number = 3;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 3;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.GotchaItemInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_number();
  inline void clear_has_number();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 number_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static GotchaItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestCheatInfoCommand : public ::google::protobuf::Message {
 public:
  RequestCheatInfoCommand();
  virtual ~RequestCheatInfoCommand();
  
  RequestCheatInfoCommand(const RequestCheatInfoCommand& from);
  
  inline RequestCheatInfoCommand& operator=(const RequestCheatInfoCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCheatInfoCommand& default_instance();
  
  void Swap(RequestCheatInfoCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestCheatInfoCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestCheatInfoCommand& from);
  void MergeFrom(const RequestCheatInfoCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 CheatType = 1;
  inline bool has_cheattype() const;
  inline void clear_cheattype();
  static const int kCheatTypeFieldNumber = 1;
  inline ::google::protobuf::int32 cheattype() const;
  inline void set_cheattype(::google::protobuf::int32 value);
  
  // optional string CarConfigName = 2;
  inline bool has_carconfigname() const;
  inline void clear_carconfigname();
  static const int kCarConfigNameFieldNumber = 2;
  inline const ::std::string& carconfigname() const;
  inline void set_carconfigname(const ::std::string& value);
  inline void set_carconfigname(const char* value);
  inline void set_carconfigname(const char* value, size_t size);
  inline ::std::string* mutable_carconfigname();
  inline ::std::string* release_carconfigname();
  
  // optional int32 MidGearSpd = 3;
  inline bool has_midgearspd() const;
  inline void clear_midgearspd();
  static const int kMidGearSpdFieldNumber = 3;
  inline ::google::protobuf::int32 midgearspd() const;
  inline void set_midgearspd(::google::protobuf::int32 value);
  
  // optional int32 TopGearSpd = 4;
  inline bool has_topgearspd() const;
  inline void clear_topgearspd();
  static const int kTopGearSpdFieldNumber = 4;
  inline ::google::protobuf::int32 topgearspd() const;
  inline void set_topgearspd(::google::protobuf::int32 value);
  
  // optional string ExeFileMD5 = 5;
  inline bool has_exefilemd5() const;
  inline void clear_exefilemd5();
  static const int kExeFileMD5FieldNumber = 5;
  inline const ::std::string& exefilemd5() const;
  inline void set_exefilemd5(const ::std::string& value);
  inline void set_exefilemd5(const char* value);
  inline void set_exefilemd5(const char* value, size_t size);
  inline ::std::string* mutable_exefilemd5();
  inline ::std::string* release_exefilemd5();
  
  // optional string UserSelectCarID = 6;
  inline bool has_userselectcarid() const;
  inline void clear_userselectcarid();
  static const int kUserSelectCarIDFieldNumber = 6;
  inline const ::std::string& userselectcarid() const;
  inline void set_userselectcarid(const ::std::string& value);
  inline void set_userselectcarid(const char* value);
  inline void set_userselectcarid(const char* value, size_t size);
  inline ::std::string* mutable_userselectcarid();
  inline ::std::string* release_userselectcarid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestCheatInfoCommand)
 private:
  inline void set_has_cheattype();
  inline void clear_has_cheattype();
  inline void set_has_carconfigname();
  inline void clear_has_carconfigname();
  inline void set_has_midgearspd();
  inline void clear_has_midgearspd();
  inline void set_has_topgearspd();
  inline void clear_has_topgearspd();
  inline void set_has_exefilemd5();
  inline void clear_has_exefilemd5();
  inline void set_has_userselectcarid();
  inline void clear_has_userselectcarid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* carconfigname_;
  ::google::protobuf::int32 cheattype_;
  ::google::protobuf::int32 midgearspd_;
  ::std::string* exefilemd5_;
  ::std::string* userselectcarid_;
  ::google::protobuf::int32 topgearspd_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestCheatInfoCommand* default_instance_;
};
// -------------------------------------------------------------------

class LeaderboardClass : public ::google::protobuf::Message {
 public:
  LeaderboardClass();
  virtual ~LeaderboardClass();
  
  LeaderboardClass(const LeaderboardClass& from);
  
  inline LeaderboardClass& operator=(const LeaderboardClass& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderboardClass& default_instance();
  
  void Swap(LeaderboardClass* other);
  
  // implements Message ----------------------------------------------
  
  LeaderboardClass* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderboardClass& from);
  void MergeFrom(const LeaderboardClass& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.LeaderboardClass)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static LeaderboardClass* default_instance_;
};
// -------------------------------------------------------------------

class LeaderboardItem : public ::google::protobuf::Message {
 public:
  LeaderboardItem();
  virtual ~LeaderboardItem();
  
  LeaderboardItem(const LeaderboardItem& from);
  
  inline LeaderboardItem& operator=(const LeaderboardItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderboardItem& default_instance();
  
  void Swap(LeaderboardItem* other);
  
  // implements Message ----------------------------------------------
  
  LeaderboardItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderboardItem& from);
  void MergeFrom(const LeaderboardItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rank = 1;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 1;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int64 userId = 3;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 3;
  inline ::google::protobuf::int64 userid() const;
  inline void set_userid(::google::protobuf::int64 value);
  
  // required int32 headIndex = 4;
  inline bool has_headindex() const;
  inline void clear_headindex();
  static const int kHeadIndexFieldNumber = 4;
  inline ::google::protobuf::int32 headindex() const;
  inline void set_headindex(::google::protobuf::int32 value);
  
  // optional string headUrl = 5;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 5;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  
  // optional string text = 6;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 6;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  
  // optional int32 rpLevel = 7;
  inline bool has_rplevel() const;
  inline void clear_rplevel();
  static const int kRpLevelFieldNumber = 7;
  inline ::google::protobuf::int32 rplevel() const;
  inline void set_rplevel(::google::protobuf::int32 value);
  
  // optional int32 rpNum = 8;
  inline bool has_rpnum() const;
  inline void clear_rpnum();
  static const int kRpNumFieldNumber = 8;
  inline ::google::protobuf::int32 rpnum() const;
  inline void set_rpnum(::google::protobuf::int32 value);
  
  // optional bool isMyself = 9;
  inline bool has_ismyself() const;
  inline void clear_ismyself();
  static const int kIsMyselfFieldNumber = 9;
  inline bool ismyself() const;
  inline void set_ismyself(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.LeaderboardItem)
 private:
  inline void set_has_rank();
  inline void clear_has_rank();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_headindex();
  inline void clear_has_headindex();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_rplevel();
  inline void clear_has_rplevel();
  inline void set_has_rpnum();
  inline void clear_has_rpnum();
  inline void set_has_ismyself();
  inline void clear_has_ismyself();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 headindex_;
  ::google::protobuf::int64 userid_;
  ::std::string* headurl_;
  ::std::string* text_;
  ::google::protobuf::int32 rplevel_;
  ::google::protobuf::int32 rpnum_;
  bool ismyself_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static LeaderboardItem* default_instance_;
};
// -------------------------------------------------------------------

class RequestLeaderboardClass : public ::google::protobuf::Message {
 public:
  RequestLeaderboardClass();
  virtual ~RequestLeaderboardClass();
  
  RequestLeaderboardClass(const RequestLeaderboardClass& from);
  
  inline RequestLeaderboardClass& operator=(const RequestLeaderboardClass& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLeaderboardClass& default_instance();
  
  void Swap(RequestLeaderboardClass* other);
  
  // implements Message ----------------------------------------------
  
  RequestLeaderboardClass* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestLeaderboardClass& from);
  void MergeFrom(const RequestLeaderboardClass& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestLeaderboardClass)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestLeaderboardClass* default_instance_;
};
// -------------------------------------------------------------------

class ResponseLeaderboardClass : public ::google::protobuf::Message {
 public:
  ResponseLeaderboardClass();
  virtual ~ResponseLeaderboardClass();
  
  ResponseLeaderboardClass(const ResponseLeaderboardClass& from);
  
  inline ResponseLeaderboardClass& operator=(const ResponseLeaderboardClass& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseLeaderboardClass& default_instance();
  
  void Swap(ResponseLeaderboardClass* other);
  
  // implements Message ----------------------------------------------
  
  ResponseLeaderboardClass* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseLeaderboardClass& from);
  void MergeFrom(const ResponseLeaderboardClass& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.LeaderboardClass clases = 1;
  inline int clases_size() const;
  inline void clear_clases();
  static const int kClasesFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass& clases(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass* mutable_clases(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass* add_clases();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass >&
      clases() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass >*
      mutable_clases();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseLeaderboardClass)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass > clases_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseLeaderboardClass* default_instance_;
};
// -------------------------------------------------------------------

class LeaderboardHeadInfo : public ::google::protobuf::Message {
 public:
  LeaderboardHeadInfo();
  virtual ~LeaderboardHeadInfo();
  
  LeaderboardHeadInfo(const LeaderboardHeadInfo& from);
  
  inline LeaderboardHeadInfo& operator=(const LeaderboardHeadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderboardHeadInfo& default_instance();
  
  void Swap(LeaderboardHeadInfo* other);
  
  // implements Message ----------------------------------------------
  
  LeaderboardHeadInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderboardHeadInfo& from);
  void MergeFrom(const LeaderboardHeadInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 classId = 1;
  inline bool has_classid() const;
  inline void clear_classid();
  static const int kClassIdFieldNumber = 1;
  inline ::google::protobuf::int32 classid() const;
  inline void set_classid(::google::protobuf::int32 value);
  
  // required int32 tier = 2;
  inline bool has_tier() const;
  inline void clear_tier();
  static const int kTierFieldNumber = 2;
  inline ::google::protobuf::int32 tier() const;
  inline void set_tier(::google::protobuf::int32 value);
  
  // required int32 range = 3;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 3;
  inline ::google::protobuf::int32 range() const;
  inline void set_range(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.LeaderboardHeadInfo)
 private:
  inline void set_has_classid();
  inline void clear_has_classid();
  inline void set_has_tier();
  inline void clear_has_tier();
  inline void set_has_range();
  inline void clear_has_range();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 classid_;
  ::google::protobuf::int32 tier_;
  ::google::protobuf::int32 range_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static LeaderboardHeadInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequestLeaderboard : public ::google::protobuf::Message {
 public:
  RequestLeaderboard();
  virtual ~RequestLeaderboard();
  
  RequestLeaderboard(const RequestLeaderboard& from);
  
  inline RequestLeaderboard& operator=(const RequestLeaderboard& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLeaderboard& default_instance();
  
  void Swap(RequestLeaderboard* other);
  
  // implements Message ----------------------------------------------
  
  RequestLeaderboard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestLeaderboard& from);
  void MergeFrom(const RequestLeaderboard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.ea.eamobile.nfsmw.protoc.LeaderboardHeadInfo info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo& info() const;
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* mutable_info();
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* release_info();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestLeaderboard)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestLeaderboard* default_instance_;
};
// -------------------------------------------------------------------

class ResponseLeaderboard : public ::google::protobuf::Message {
 public:
  ResponseLeaderboard();
  virtual ~ResponseLeaderboard();
  
  ResponseLeaderboard(const ResponseLeaderboard& from);
  
  inline ResponseLeaderboard& operator=(const ResponseLeaderboard& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseLeaderboard& default_instance();
  
  void Swap(ResponseLeaderboard* other);
  
  // implements Message ----------------------------------------------
  
  ResponseLeaderboard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseLeaderboard& from);
  void MergeFrom(const ResponseLeaderboard& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.ea.eamobile.nfsmw.protoc.LeaderboardHeadInfo info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo& info() const;
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* mutable_info();
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* release_info();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.LeaderboardItem items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem& items(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem* mutable_items(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem >*
      mutable_items();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseLeaderboard)
 private:
  inline void set_has_info();
  inline void clear_has_info();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* info_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem > items_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseLeaderboard* default_instance_;
};
// -------------------------------------------------------------------

class RequestTournamentNum : public ::google::protobuf::Message {
 public:
  RequestTournamentNum();
  virtual ~RequestTournamentNum();
  
  RequestTournamentNum(const RequestTournamentNum& from);
  
  inline RequestTournamentNum& operator=(const RequestTournamentNum& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestTournamentNum& default_instance();
  
  void Swap(RequestTournamentNum* other);
  
  // implements Message ----------------------------------------------
  
  RequestTournamentNum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestTournamentNum& from);
  void MergeFrom(const RequestTournamentNum& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestTournamentNum)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestTournamentNum* default_instance_;
};
// -------------------------------------------------------------------

class ResponseTournamentNum : public ::google::protobuf::Message {
 public:
  ResponseTournamentNum();
  virtual ~ResponseTournamentNum();
  
  ResponseTournamentNum(const ResponseTournamentNum& from);
  
  inline ResponseTournamentNum& operator=(const ResponseTournamentNum& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseTournamentNum& default_instance();
  
  void Swap(ResponseTournamentNum* other);
  
  // implements Message ----------------------------------------------
  
  ResponseTournamentNum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseTournamentNum& from);
  void MergeFrom(const ResponseTournamentNum& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 rewardNum = 1;
  inline bool has_rewardnum() const;
  inline void clear_rewardnum();
  static const int kRewardNumFieldNumber = 1;
  inline ::google::protobuf::int32 rewardnum() const;
  inline void set_rewardnum(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseTournamentNum)
 private:
  inline void set_has_rewardnum();
  inline void clear_has_rewardnum();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 rewardnum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseTournamentNum* default_instance_;
};
// -------------------------------------------------------------------

class RequestCollectEnergyCommand : public ::google::protobuf::Message {
 public:
  RequestCollectEnergyCommand();
  virtual ~RequestCollectEnergyCommand();
  
  RequestCollectEnergyCommand(const RequestCollectEnergyCommand& from);
  
  inline RequestCollectEnergyCommand& operator=(const RequestCollectEnergyCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCollectEnergyCommand& default_instance();
  
  void Swap(RequestCollectEnergyCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestCollectEnergyCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestCollectEnergyCommand& from);
  void MergeFrom(const RequestCollectEnergyCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestCollectEnergyCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestCollectEnergyCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestEnergyTimeCommand : public ::google::protobuf::Message {
 public:
  RequestEnergyTimeCommand();
  virtual ~RequestEnergyTimeCommand();
  
  RequestEnergyTimeCommand(const RequestEnergyTimeCommand& from);
  
  inline RequestEnergyTimeCommand& operator=(const RequestEnergyTimeCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestEnergyTimeCommand& default_instance();
  
  void Swap(RequestEnergyTimeCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestEnergyTimeCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestEnergyTimeCommand& from);
  void MergeFrom(const RequestEnergyTimeCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestEnergyTimeCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestEnergyTimeCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseEnergyTimeCommand : public ::google::protobuf::Message {
 public:
  ResponseEnergyTimeCommand();
  virtual ~ResponseEnergyTimeCommand();
  
  ResponseEnergyTimeCommand(const ResponseEnergyTimeCommand& from);
  
  inline ResponseEnergyTimeCommand& operator=(const ResponseEnergyTimeCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseEnergyTimeCommand& default_instance();
  
  void Swap(ResponseEnergyTimeCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseEnergyTimeCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseEnergyTimeCommand& from);
  void MergeFrom(const ResponseEnergyTimeCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 starttime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 1;
  inline ::google::protobuf::int32 starttime() const;
  inline void set_starttime(::google::protobuf::int32 value);
  
  // required int32 endtime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndtimeFieldNumber = 2;
  inline ::google::protobuf::int32 endtime() const;
  inline void set_endtime(::google::protobuf::int32 value);
  
  // required int32 energy = 3;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 3;
  inline ::google::protobuf::int32 energy() const;
  inline void set_energy(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseEnergyTimeCommand)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_energy();
  inline void clear_has_energy();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 starttime_;
  ::google::protobuf::int32 endtime_;
  ::google::protobuf::int32 energy_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseEnergyTimeCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestFansRewardCommand : public ::google::protobuf::Message {
 public:
  RequestFansRewardCommand();
  virtual ~RequestFansRewardCommand();
  
  RequestFansRewardCommand(const RequestFansRewardCommand& from);
  
  inline RequestFansRewardCommand& operator=(const RequestFansRewardCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFansRewardCommand& default_instance();
  
  void Swap(RequestFansRewardCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestFansRewardCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFansRewardCommand& from);
  void MergeFrom(const RequestFansRewardCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestFansRewardCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestFansRewardCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseFansRewardTimeCommand : public ::google::protobuf::Message {
 public:
  ResponseFansRewardTimeCommand();
  virtual ~ResponseFansRewardTimeCommand();
  
  ResponseFansRewardTimeCommand(const ResponseFansRewardTimeCommand& from);
  
  inline ResponseFansRewardTimeCommand& operator=(const ResponseFansRewardTimeCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFansRewardTimeCommand& default_instance();
  
  void Swap(ResponseFansRewardTimeCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseFansRewardTimeCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseFansRewardTimeCommand& from);
  void MergeFrom(const ResponseFansRewardTimeCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 starttime = 2;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 2;
  inline ::google::protobuf::int32 starttime() const;
  inline void set_starttime(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseFansRewardTimeCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 starttime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseFansRewardTimeCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestPropPurchaseCommand : public ::google::protobuf::Message {
 public:
  RequestPropPurchaseCommand();
  virtual ~RequestPropPurchaseCommand();
  
  RequestPropPurchaseCommand(const RequestPropPurchaseCommand& from);
  
  inline RequestPropPurchaseCommand& operator=(const RequestPropPurchaseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPropPurchaseCommand& default_instance();
  
  void Swap(RequestPropPurchaseCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestPropPurchaseCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPropPurchaseCommand& from);
  void MergeFrom(const RequestPropPurchaseCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestPropPurchaseCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_count();
  inline void clear_has_count();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 count_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestPropPurchaseCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestMissionRewardCommand : public ::google::protobuf::Message {
 public:
  RequestMissionRewardCommand();
  virtual ~RequestMissionRewardCommand();
  
  RequestMissionRewardCommand(const RequestMissionRewardCommand& from);
  
  inline RequestMissionRewardCommand& operator=(const RequestMissionRewardCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestMissionRewardCommand& default_instance();
  
  void Swap(RequestMissionRewardCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestMissionRewardCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestMissionRewardCommand& from);
  void MergeFrom(const RequestMissionRewardCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestMissionRewardCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestMissionRewardCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestMissionFinishCommand : public ::google::protobuf::Message {
 public:
  RequestMissionFinishCommand();
  virtual ~RequestMissionFinishCommand();
  
  RequestMissionFinishCommand(const RequestMissionFinishCommand& from);
  
  inline RequestMissionFinishCommand& operator=(const RequestMissionFinishCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestMissionFinishCommand& default_instance();
  
  void Swap(RequestMissionFinishCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestMissionFinishCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestMissionFinishCommand& from);
  void MergeFrom(const RequestMissionFinishCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestMissionFinishCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestMissionFinishCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseMissionListCommand : public ::google::protobuf::Message {
 public:
  ResponseMissionListCommand();
  virtual ~ResponseMissionListCommand();
  
  ResponseMissionListCommand(const ResponseMissionListCommand& from);
  
  inline ResponseMissionListCommand& operator=(const ResponseMissionListCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseMissionListCommand& default_instance();
  
  void Swap(ResponseMissionListCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseMissionListCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseMissionListCommand& from);
  void MergeFrom(const ResponseMissionListCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.MissionInfo missions = 1;
  inline int missions_size() const;
  inline void clear_missions();
  static const int kMissionsFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::MissionInfo& missions(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::MissionInfo* mutable_missions(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::MissionInfo* add_missions();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::MissionInfo >&
      missions() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::MissionInfo >*
      mutable_missions();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseMissionListCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::MissionInfo > missions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseMissionListCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestLotteryCommand : public ::google::protobuf::Message {
 public:
  RequestLotteryCommand();
  virtual ~RequestLotteryCommand();
  
  RequestLotteryCommand(const RequestLotteryCommand& from);
  
  inline RequestLotteryCommand& operator=(const RequestLotteryCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLotteryCommand& default_instance();
  
  void Swap(RequestLotteryCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestLotteryCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestLotteryCommand& from);
  void MergeFrom(const RequestLotteryCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 lotteryType = 1;
  inline bool has_lotterytype() const;
  inline void clear_lotterytype();
  static const int kLotteryTypeFieldNumber = 1;
  inline ::google::protobuf::int32 lotterytype() const;
  inline void set_lotterytype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestLotteryCommand)
 private:
  inline void set_has_lotterytype();
  inline void clear_has_lotterytype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 lotterytype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestLotteryCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseLotteryCommand : public ::google::protobuf::Message {
 public:
  ResponseLotteryCommand();
  virtual ~ResponseLotteryCommand();
  
  ResponseLotteryCommand(const ResponseLotteryCommand& from);
  
  inline ResponseLotteryCommand& operator=(const ResponseLotteryCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseLotteryCommand& default_instance();
  
  void Swap(ResponseLotteryCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseLotteryCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseLotteryCommand& from);
  void MergeFrom(const ResponseLotteryCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RewardList rewards = 1;
  inline int rewards_size() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::RewardList& rewards(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RewardList* mutable_rewards(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RewardList* add_rewards();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >&
      rewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >*
      mutable_rewards();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseLotteryCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList > rewards_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseLotteryCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestFleetRaceCommand : public ::google::protobuf::Message {
 public:
  RequestFleetRaceCommand();
  virtual ~RequestFleetRaceCommand();
  
  RequestFleetRaceCommand(const RequestFleetRaceCommand& from);
  
  inline RequestFleetRaceCommand& operator=(const RequestFleetRaceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFleetRaceCommand& default_instance();
  
  void Swap(RequestFleetRaceCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestFleetRaceCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFleetRaceCommand& from);
  void MergeFrom(const RequestFleetRaceCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestFleetRaceCommand)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestFleetRaceCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseFleetRaceCommand : public ::google::protobuf::Message {
 public:
  ResponseFleetRaceCommand();
  virtual ~ResponseFleetRaceCommand();
  
  ResponseFleetRaceCommand(const ResponseFleetRaceCommand& from);
  
  inline ResponseFleetRaceCommand& operator=(const ResponseFleetRaceCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFleetRaceCommand& default_instance();
  
  void Swap(ResponseFleetRaceCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseFleetRaceCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseFleetRaceCommand& from);
  void MergeFrom(const ResponseFleetRaceCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .com.ea.eamobile.nfsmw.protoc.FleetRace races = 1;
  inline int races_size() const;
  inline void clear_races();
  static const int kRacesFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::FleetRace& races(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::FleetRace* mutable_races(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::FleetRace* add_races();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::FleetRace >&
      races() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::FleetRace >*
      mutable_races();
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RpLeaderboardMessage rpLeaderboard = 2;
  inline int rpleaderboard_size() const;
  inline void clear_rpleaderboard();
  static const int kRpLeaderboardFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage& rpleaderboard(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage* mutable_rpleaderboard(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage* add_rpleaderboard();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage >&
      rpleaderboard() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage >*
      mutable_rpleaderboard();
  
  // required int32 selfRank = 3;
  inline bool has_selfrank() const;
  inline void clear_selfrank();
  static const int kSelfRankFieldNumber = 3;
  inline ::google::protobuf::int32 selfrank() const;
  inline void set_selfrank(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseFleetRaceCommand)
 private:
  inline void set_has_selfrank();
  inline void clear_has_selfrank();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::FleetRace > races_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage > rpleaderboard_;
  ::google::protobuf::int32 selfrank_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseFleetRaceCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestFleetStartCommand : public ::google::protobuf::Message {
 public:
  RequestFleetStartCommand();
  virtual ~RequestFleetStartCommand();
  
  RequestFleetStartCommand(const RequestFleetStartCommand& from);
  
  inline RequestFleetStartCommand& operator=(const RequestFleetStartCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFleetStartCommand& default_instance();
  
  void Swap(RequestFleetStartCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestFleetStartCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFleetStartCommand& from);
  void MergeFrom(const RequestFleetStartCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // repeated string cars = 2;
  inline int cars_size() const;
  inline void clear_cars();
  static const int kCarsFieldNumber = 2;
  inline const ::std::string& cars(int index) const;
  inline ::std::string* mutable_cars(int index);
  inline void set_cars(int index, const ::std::string& value);
  inline void set_cars(int index, const char* value);
  inline void set_cars(int index, const char* value, size_t size);
  inline ::std::string* add_cars();
  inline void add_cars(const ::std::string& value);
  inline void add_cars(const char* value);
  inline void add_cars(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& cars() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_cars();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestFleetStartCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> cars_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestFleetStartCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseFleetStartCommand : public ::google::protobuf::Message {
 public:
  ResponseFleetStartCommand();
  virtual ~ResponseFleetStartCommand();
  
  ResponseFleetStartCommand(const ResponseFleetStartCommand& from);
  
  inline ResponseFleetStartCommand& operator=(const ResponseFleetStartCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFleetStartCommand& default_instance();
  
  void Swap(ResponseFleetStartCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseFleetStartCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseFleetStartCommand& from);
  void MergeFrom(const ResponseFleetStartCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // required string displayName = 3;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 3;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseFleetStartCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 result_;
  ::std::string* displayname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseFleetStartCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestFleetEndCommand : public ::google::protobuf::Message {
 public:
  RequestFleetEndCommand();
  virtual ~RequestFleetEndCommand();
  
  RequestFleetEndCommand(const RequestFleetEndCommand& from);
  
  inline RequestFleetEndCommand& operator=(const RequestFleetEndCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFleetEndCommand& default_instance();
  
  void Swap(RequestFleetEndCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestFleetEndCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFleetEndCommand& from);
  void MergeFrom(const RequestFleetEndCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional bool advanced = 2;
  inline bool has_advanced() const;
  inline void clear_advanced();
  static const int kAdvancedFieldNumber = 2;
  inline bool advanced() const;
  inline void set_advanced(bool value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestFleetEndCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_advanced();
  inline void clear_has_advanced();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  bool advanced_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestFleetEndCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseFleetEndCommand : public ::google::protobuf::Message {
 public:
  ResponseFleetEndCommand();
  virtual ~ResponseFleetEndCommand();
  
  ResponseFleetEndCommand(const ResponseFleetEndCommand& from);
  
  inline ResponseFleetEndCommand& operator=(const ResponseFleetEndCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFleetEndCommand& default_instance();
  
  void Swap(ResponseFleetEndCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseFleetEndCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseFleetEndCommand& from);
  void MergeFrom(const ResponseFleetEndCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // required string displayName = 3;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 3;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  
  // required int32 rank = 4;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 4;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // repeated .com.ea.eamobile.nfsmw.protoc.RewardList rewards = 5;
  inline int rewards_size() const;
  inline void clear_rewards();
  static const int kRewardsFieldNumber = 5;
  inline const ::com::ea::eamobile::nfsmw::protoc::RewardList& rewards(int index) const;
  inline ::com::ea::eamobile::nfsmw::protoc::RewardList* mutable_rewards(int index);
  inline ::com::ea::eamobile::nfsmw::protoc::RewardList* add_rewards();
  inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >&
      rewards() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >*
      mutable_rewards();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseFleetEndCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  inline void set_has_rank();
  inline void clear_has_rank();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 result_;
  ::std::string* displayname_;
  ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList > rewards_;
  ::google::protobuf::int32 rank_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseFleetEndCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestFleetDoubleCommand : public ::google::protobuf::Message {
 public:
  RequestFleetDoubleCommand();
  virtual ~RequestFleetDoubleCommand();
  
  RequestFleetDoubleCommand(const RequestFleetDoubleCommand& from);
  
  inline RequestFleetDoubleCommand& operator=(const RequestFleetDoubleCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFleetDoubleCommand& default_instance();
  
  void Swap(RequestFleetDoubleCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestFleetDoubleCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFleetDoubleCommand& from);
  void MergeFrom(const RequestFleetDoubleCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestFleetDoubleCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestFleetDoubleCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseFleetDoubleCommand : public ::google::protobuf::Message {
 public:
  ResponseFleetDoubleCommand();
  virtual ~ResponseFleetDoubleCommand();
  
  ResponseFleetDoubleCommand(const ResponseFleetDoubleCommand& from);
  
  inline ResponseFleetDoubleCommand& operator=(const ResponseFleetDoubleCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFleetDoubleCommand& default_instance();
  
  void Swap(ResponseFleetDoubleCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseFleetDoubleCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseFleetDoubleCommand& from);
  void MergeFrom(const ResponseFleetDoubleCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // required string displayName = 3;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 3;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseFleetDoubleCommand)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 result_;
  ::std::string* displayname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseFleetDoubleCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestFixCarLimitCommand : public ::google::protobuf::Message {
 public:
  RequestFixCarLimitCommand();
  virtual ~RequestFixCarLimitCommand();
  
  RequestFixCarLimitCommand(const RequestFixCarLimitCommand& from);
  
  inline RequestFixCarLimitCommand& operator=(const RequestFixCarLimitCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFixCarLimitCommand& default_instance();
  
  void Swap(RequestFixCarLimitCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestFixCarLimitCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestFixCarLimitCommand& from);
  void MergeFrom(const RequestFixCarLimitCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string carId = 1;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 1;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestFixCarLimitCommand)
 private:
  inline void set_has_carid();
  inline void clear_has_carid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* carid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestFixCarLimitCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseFixCarLimitCommand : public ::google::protobuf::Message {
 public:
  ResponseFixCarLimitCommand();
  virtual ~ResponseFixCarLimitCommand();
  
  ResponseFixCarLimitCommand(const ResponseFixCarLimitCommand& from);
  
  inline ResponseFixCarLimitCommand& operator=(const ResponseFixCarLimitCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFixCarLimitCommand& default_instance();
  
  void Swap(ResponseFixCarLimitCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseFixCarLimitCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseFixCarLimitCommand& from);
  void MergeFrom(const ResponseFixCarLimitCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string carId = 1;
  inline bool has_carid() const;
  inline void clear_carid();
  static const int kCarIdFieldNumber = 1;
  inline const ::std::string& carid() const;
  inline void set_carid(const ::std::string& value);
  inline void set_carid(const char* value);
  inline void set_carid(const char* value, size_t size);
  inline ::std::string* mutable_carid();
  inline ::std::string* release_carid();
  
  // required int32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::int32 result() const;
  inline void set_result(::google::protobuf::int32 value);
  
  // required string displayName = 3;
  inline bool has_displayname() const;
  inline void clear_displayname();
  static const int kDisplayNameFieldNumber = 3;
  inline const ::std::string& displayname() const;
  inline void set_displayname(const ::std::string& value);
  inline void set_displayname(const char* value);
  inline void set_displayname(const char* value, size_t size);
  inline ::std::string* mutable_displayname();
  inline ::std::string* release_displayname();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseFixCarLimitCommand)
 private:
  inline void set_has_carid();
  inline void clear_has_carid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_displayname();
  inline void clear_has_displayname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* carid_;
  ::std::string* displayname_;
  ::google::protobuf::int32 result_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseFixCarLimitCommand* default_instance_;
};
// -------------------------------------------------------------------

class RequestCommand : public ::google::protobuf::Message {
 public:
  RequestCommand();
  virtual ~RequestCommand();
  
  RequestCommand(const RequestCommand& from);
  
  inline RequestCommand& operator=(const RequestCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCommand& default_instance();
  
  void Swap(RequestCommand* other);
  
  // implements Message ----------------------------------------------
  
  RequestCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestCommand& from);
  void MergeFrom(const RequestCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.ea.eamobile.nfsmw.protoc.HeadInfo head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::HeadInfo& head() const;
  inline ::com::ea::eamobile::nfsmw::protoc::HeadInfo* mutable_head();
  inline ::com::ea::eamobile::nfsmw::protoc::HeadInfo* release_head();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestTrackCommand trackCommand = 2;
  inline bool has_trackcommand() const;
  inline void clear_trackcommand();
  static const int kTrackCommandFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand& trackcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand* mutable_trackcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand* release_trackcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestUserInfoCommand loginCommand = 3;
  inline bool has_logincommand() const;
  inline void clear_logincommand();
  static const int kLoginCommandFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand& logincommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand* mutable_logincommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand* release_logincommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestModeInfoCommand ghostCommand = 4;
  inline bool has_ghostcommand() const;
  inline void clear_ghostcommand();
  static const int kGhostCommandFieldNumber = 4;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand& ghostcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand* mutable_ghostcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand* release_ghostcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestRaceResultCommand raceResultCommand = 5;
  inline bool has_raceresultcommand() const;
  inline void clear_raceresultcommand();
  static const int kRaceResultCommandFieldNumber = 5;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand& raceresultcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand* mutable_raceresultcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand* release_raceresultcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentDetailCommand tournamentDetailCommand = 6;
  inline bool has_tournamentdetailcommand() const;
  inline void clear_tournamentdetailcommand();
  static const int kTournamentDetailCommandFieldNumber = 6;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand& tournamentdetailcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand* mutable_tournamentdetailcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand* release_tournamentdetailcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentRewardDetailCommand tournamentRewardDetailCommand = 7;
  inline bool has_tournamentrewarddetailcommand() const;
  inline void clear_tournamentrewarddetailcommand();
  static const int kTournamentRewardDetailCommandFieldNumber = 7;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand& tournamentrewarddetailcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand* mutable_tournamentrewarddetailcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand* release_tournamentrewarddetailcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentCommand tournamentCommand = 9;
  inline bool has_tournamentcommand() const;
  inline void clear_tournamentcommand();
  static const int kTournamentCommandFieldNumber = 9;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand& tournamentcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand* mutable_tournamentcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand* release_tournamentcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestResourceCommand resourceCommand = 10;
  inline bool has_resourcecommand() const;
  inline void clear_resourcecommand();
  static const int kResourceCommandFieldNumber = 10;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand& resourcecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand* mutable_resourcecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand* release_resourcecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentSignUpCommand tournamentSignUpCommand = 16;
  inline bool has_tournamentsignupcommand() const;
  inline void clear_tournamentsignupcommand();
  static const int kTournamentSignUpCommandFieldNumber = 16;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand& tournamentsignupcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand* mutable_tournamentsignupcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand* release_tournamentsignupcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestRaceStartCommand raceStartCommand = 18;
  inline bool has_racestartcommand() const;
  inline void clear_racestartcommand();
  static const int kRaceStartCommandFieldNumber = 18;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand& racestartcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand* mutable_racestartcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand* release_racestartcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestBindingStartCommand bindingStartCommand = 19;
  inline bool has_bindingstartcommand() const;
  inline void clear_bindingstartcommand();
  static const int kBindingStartCommandFieldNumber = 19;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand& bindingstartcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand* mutable_bindingstartcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand* release_bindingstartcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestBindingResultCommand bindingResultCommand = 20;
  inline bool has_bindingresultcommand() const;
  inline void clear_bindingresultcommand();
  static const int kBindingResultCommandFieldNumber = 20;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand& bindingresultcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand* mutable_bindingresultcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand* release_bindingresultcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestBindingConfirmCommand bindingConfirmCommand = 21;
  inline bool has_bindingconfirmcommand() const;
  inline void clear_bindingconfirmcommand();
  static const int kBindingConfirmCommandFieldNumber = 21;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand& bindingconfirmcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand* mutable_bindingconfirmcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand* release_bindingconfirmcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestGetRewardCommand getRward = 22;
  inline bool has_getrward() const;
  inline void clear_getrward();
  static const int kGetRwardFieldNumber = 22;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand& getrward() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand* mutable_getrward();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand* release_getrward();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestGarageCommand garageCommand = 23;
  inline bool has_garagecommand() const;
  inline void clear_garagecommand();
  static const int kGarageCommandFieldNumber = 23;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand& garagecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand* mutable_garagecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand* release_garagecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestBuyCarCommand buyCarCommand = 24;
  inline bool has_buycarcommand() const;
  inline void clear_buycarcommand();
  static const int kBuyCarCommandFieldNumber = 24;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand& buycarcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand* mutable_buycarcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand* release_buycarcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestCarDataCommand carDataCommand = 25;
  inline bool has_cardatacommand() const;
  inline void clear_cardatacommand();
  static const int kCarDataCommandFieldNumber = 25;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand& cardatacommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand* mutable_cardatacommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand* release_cardatacommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestUpgradeSlotCommand upgradeSlotCommand = 26;
  inline bool has_upgradeslotcommand() const;
  inline void clear_upgradeslotcommand();
  static const int kUpgradeSlotCommandFieldNumber = 26;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand& upgradeslotcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand* mutable_upgradeslotcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand* release_upgradeslotcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestUseChartletCommand useChartletCommand = 27;
  inline bool has_usechartletcommand() const;
  inline void clear_usechartletcommand();
  static const int kUseChartletCommandFieldNumber = 27;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand& usechartletcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand* mutable_usechartletcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand* release_usechartletcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestModifyUserInfoCommand modifyUserInfoCommand = 28;
  inline bool has_modifyuserinfocommand() const;
  inline void clear_modifyuserinfocommand();
  static const int kModifyUserInfoCommandFieldNumber = 28;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand& modifyuserinfocommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand* mutable_modifyuserinfocommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand* release_modifyuserinfocommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestStoreDetailCommand storeDetailCommand = 29;
  inline bool has_storedetailcommand() const;
  inline void clear_storedetailcommand();
  static const int kStoreDetailCommandFieldNumber = 29;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand& storedetailcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand* mutable_storedetailcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand* release_storedetailcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestBuyItemCommand buyItemCommand = 30;
  inline bool has_buyitemcommand() const;
  inline void clear_buyitemcommand();
  static const int kBuyItemCommandFieldNumber = 30;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand& buyitemcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand* mutable_buyitemcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand* release_buyitemcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestRegistJaguarCommand registJaguar = 31;
  inline bool has_registjaguar() const;
  inline void clear_registjaguar();
  static const int kRegistJaguarFieldNumber = 31;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand& registjaguar() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand* mutable_registjaguar();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand* release_registjaguar();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestIapCheckCommand IapCheckCommand = 32;
  inline bool has_iapcheckcommand() const;
  inline void clear_iapcheckcommand();
  static const int kIapCheckCommandFieldNumber = 32;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand& iapcheckcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand* mutable_iapcheckcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand* release_iapcheckcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestTutorialRewardCommand tutorialRewardCommand = 33;
  inline bool has_tutorialrewardcommand() const;
  inline void clear_tutorialrewardcommand();
  static const int kTutorialRewardCommandFieldNumber = 33;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand& tutorialrewardcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand* mutable_tutorialrewardcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand* release_tutorialrewardcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestRpLeaderboardCommand rpLeaderboardCommand = 34;
  inline bool has_rpleaderboardcommand() const;
  inline void clear_rpleaderboardcommand();
  static const int kRpLeaderboardCommandFieldNumber = 34;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand& rpleaderboardcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand* mutable_rpleaderboardcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand* release_rpleaderboardcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestGhostRecordCommand ghostRecordCommand = 35;
  inline bool has_ghostrecordcommand() const;
  inline void clear_ghostrecordcommand();
  static const int kGhostRecordCommandFieldNumber = 35;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand& ghostrecordcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand* mutable_ghostrecordcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand* release_ghostrecordcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestChallengeMathInfoCommand challengeMathInfoCommand = 36;
  inline bool has_challengemathinfocommand() const;
  inline void clear_challengemathinfocommand();
  static const int kChallengeMathInfoCommandFieldNumber = 36;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand& challengemathinfocommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand* mutable_challengemathinfocommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand* release_challengemathinfocommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestProfileUserDataCommand profileUserDataCommand = 37;
  inline bool has_profileuserdatacommand() const;
  inline void clear_profileuserdatacommand();
  static const int kProfileUserDataCommandFieldNumber = 37;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand& profileuserdatacommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand* mutable_profileuserdatacommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand* release_profileuserdatacommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestProfileNextCarCommand profileNextCarCommand = 38;
  inline bool has_profilenextcarcommand() const;
  inline void clear_profilenextcarcommand();
  static const int kProfileNextCarCommandFieldNumber = 38;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand& profilenextcarcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand* mutable_profilenextcarcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand* release_profilenextcarcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestProfileLikeCommand profileLikeCommand = 39;
  inline bool has_profilelikecommand() const;
  inline void clear_profilelikecommand();
  static const int kProfileLikeCommandFieldNumber = 39;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand& profilelikecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand* mutable_profilelikecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand* release_profilelikecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestProfileReportCommand profileReportCommand = 40;
  inline bool has_profilereportcommand() const;
  inline void clear_profilereportcommand();
  static const int kProfileReportCommandFieldNumber = 40;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand& profilereportcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand* mutable_profilereportcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand* release_profilereportcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestProfileVSCommand profileVSCommand = 41;
  inline bool has_profilevscommand() const;
  inline void clear_profilevscommand();
  static const int kProfileVSCommandFieldNumber = 41;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand& profilevscommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand* mutable_profilevscommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand* release_profilevscommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestGotchaCommand gotchaCommand = 42;
  inline bool has_gotchacommand() const;
  inline void clear_gotchacommand();
  static const int kGotchaCommandFieldNumber = 42;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand& gotchacommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand* mutable_gotchacommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand* release_gotchacommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestCheatInfoCommand cheatInfoCommand = 43;
  inline bool has_cheatinfocommand() const;
  inline void clear_cheatinfocommand();
  static const int kCheatInfoCommandFieldNumber = 43;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand& cheatinfocommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand* mutable_cheatinfocommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand* release_cheatinfocommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestRecordUserRaceActionCommand recordUserRaceActionCommand = 44;
  inline bool has_recorduserraceactioncommand() const;
  inline void clear_recorduserraceactioncommand();
  static const int kRecordUserRaceActionCommandFieldNumber = 44;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand& recorduserraceactioncommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand* mutable_recorduserraceactioncommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand* release_recorduserraceactioncommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestSystemCommand systemCommand = 45;
  inline bool has_systemcommand() const;
  inline void clear_systemcommand();
  static const int kSystemCommandFieldNumber = 45;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand& systemcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand* mutable_systemcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand* release_systemcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestLeaderboardClass leaderboardClassCommand = 46;
  inline bool has_leaderboardclasscommand() const;
  inline void clear_leaderboardclasscommand();
  static const int kLeaderboardClassCommandFieldNumber = 46;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass& leaderboardclasscommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass* mutable_leaderboardclasscommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass* release_leaderboardclasscommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestLeaderboard leaderboardCommand = 47;
  inline bool has_leaderboardcommand() const;
  inline void clear_leaderboardcommand();
  static const int kLeaderboardCommandFieldNumber = 47;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard& leaderboardcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard* mutable_leaderboardcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard* release_leaderboardcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentNum requestTournamentNum = 48;
  inline bool has_requesttournamentnum() const;
  inline void clear_requesttournamentnum();
  static const int kRequestTournamentNumFieldNumber = 48;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum& requesttournamentnum() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum* mutable_requesttournamentnum();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum* release_requesttournamentnum();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestQuickRaceCommand requestQuickRace = 49;
  inline bool has_requestquickrace() const;
  inline void clear_requestquickrace();
  static const int kRequestQuickRaceFieldNumber = 49;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand& requestquickrace() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand* mutable_requestquickrace();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand* release_requestquickrace();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestBindingTokenCommand bindingTokenCommand = 50;
  inline bool has_bindingtokencommand() const;
  inline void clear_bindingtokencommand();
  static const int kBindingTokenCommandFieldNumber = 50;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand& bindingtokencommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand* mutable_bindingtokencommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand* release_bindingtokencommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestBindingInfoCommand bindingInfoCommand = 51;
  inline bool has_bindinginfocommand() const;
  inline void clear_bindinginfocommand();
  static const int kBindingInfoCommandFieldNumber = 51;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand& bindinginfocommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand* mutable_bindinginfocommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand* release_bindinginfocommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestCollectEnergyCommand collectEnergyCommand = 52;
  inline bool has_collectenergycommand() const;
  inline void clear_collectenergycommand();
  static const int kCollectEnergyCommandFieldNumber = 52;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand& collectenergycommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand* mutable_collectenergycommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand* release_collectenergycommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestEnergyTimeCommand energyTimeCommand = 53;
  inline bool has_energytimecommand() const;
  inline void clear_energytimecommand();
  static const int kEnergyTimeCommandFieldNumber = 53;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand& energytimecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand* mutable_energytimecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand* release_energytimecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestFansRewardCommand fansRewardCommand = 54;
  inline bool has_fansrewardcommand() const;
  inline void clear_fansrewardcommand();
  static const int kFansRewardCommandFieldNumber = 54;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand& fansrewardcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand* mutable_fansrewardcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand* release_fansrewardcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestPropPurchaseCommand propPurchaseCommand = 55;
  inline bool has_proppurchasecommand() const;
  inline void clear_proppurchasecommand();
  static const int kPropPurchaseCommandFieldNumber = 55;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand& proppurchasecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand* mutable_proppurchasecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand* release_proppurchasecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestMissionRewardCommand missionRewardCommand = 56;
  inline bool has_missionrewardcommand() const;
  inline void clear_missionrewardcommand();
  static const int kMissionRewardCommandFieldNumber = 56;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand& missionrewardcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand* mutable_missionrewardcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand* release_missionrewardcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestMissionFinishCommand missionFinishCommand = 57;
  inline bool has_missionfinishcommand() const;
  inline void clear_missionfinishcommand();
  static const int kMissionFinishCommandFieldNumber = 57;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand& missionfinishcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand* mutable_missionfinishcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand* release_missionfinishcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestLotteryCommand lotteryCommand = 58;
  inline bool has_lotterycommand() const;
  inline void clear_lotterycommand();
  static const int kLotteryCommandFieldNumber = 58;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand& lotterycommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand* mutable_lotterycommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand* release_lotterycommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestFleetRaceCommand fleetRaceCommand = 59;
  inline bool has_fleetracecommand() const;
  inline void clear_fleetracecommand();
  static const int kFleetRaceCommandFieldNumber = 59;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand& fleetracecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand* mutable_fleetracecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand* release_fleetracecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestFleetStartCommand fleetStartCommand = 60;
  inline bool has_fleetstartcommand() const;
  inline void clear_fleetstartcommand();
  static const int kFleetStartCommandFieldNumber = 60;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand& fleetstartcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand* mutable_fleetstartcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand* release_fleetstartcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestFleetEndCommand fleetEndCommand = 61;
  inline bool has_fleetendcommand() const;
  inline void clear_fleetendcommand();
  static const int kFleetEndCommandFieldNumber = 61;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand& fleetendcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand* mutable_fleetendcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand* release_fleetendcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestFleetDoubleCommand fleetDoubleCommand = 62;
  inline bool has_fleetdoublecommand() const;
  inline void clear_fleetdoublecommand();
  static const int kFleetDoubleCommandFieldNumber = 62;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand& fleetdoublecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand* mutable_fleetdoublecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand* release_fleetdoublecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.RequestFixCarLimitCommand fixCarLimitCommand = 63;
  inline bool has_fixcarlimitcommand() const;
  inline void clear_fixcarlimitcommand();
  static const int kFixCarLimitCommandFieldNumber = 63;
  inline const ::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand& fixcarlimitcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand* mutable_fixcarlimitcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand* release_fixcarlimitcommand();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.RequestCommand)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_trackcommand();
  inline void clear_has_trackcommand();
  inline void set_has_logincommand();
  inline void clear_has_logincommand();
  inline void set_has_ghostcommand();
  inline void clear_has_ghostcommand();
  inline void set_has_raceresultcommand();
  inline void clear_has_raceresultcommand();
  inline void set_has_tournamentdetailcommand();
  inline void clear_has_tournamentdetailcommand();
  inline void set_has_tournamentrewarddetailcommand();
  inline void clear_has_tournamentrewarddetailcommand();
  inline void set_has_tournamentcommand();
  inline void clear_has_tournamentcommand();
  inline void set_has_resourcecommand();
  inline void clear_has_resourcecommand();
  inline void set_has_tournamentsignupcommand();
  inline void clear_has_tournamentsignupcommand();
  inline void set_has_racestartcommand();
  inline void clear_has_racestartcommand();
  inline void set_has_bindingstartcommand();
  inline void clear_has_bindingstartcommand();
  inline void set_has_bindingresultcommand();
  inline void clear_has_bindingresultcommand();
  inline void set_has_bindingconfirmcommand();
  inline void clear_has_bindingconfirmcommand();
  inline void set_has_getrward();
  inline void clear_has_getrward();
  inline void set_has_garagecommand();
  inline void clear_has_garagecommand();
  inline void set_has_buycarcommand();
  inline void clear_has_buycarcommand();
  inline void set_has_cardatacommand();
  inline void clear_has_cardatacommand();
  inline void set_has_upgradeslotcommand();
  inline void clear_has_upgradeslotcommand();
  inline void set_has_usechartletcommand();
  inline void clear_has_usechartletcommand();
  inline void set_has_modifyuserinfocommand();
  inline void clear_has_modifyuserinfocommand();
  inline void set_has_storedetailcommand();
  inline void clear_has_storedetailcommand();
  inline void set_has_buyitemcommand();
  inline void clear_has_buyitemcommand();
  inline void set_has_registjaguar();
  inline void clear_has_registjaguar();
  inline void set_has_iapcheckcommand();
  inline void clear_has_iapcheckcommand();
  inline void set_has_tutorialrewardcommand();
  inline void clear_has_tutorialrewardcommand();
  inline void set_has_rpleaderboardcommand();
  inline void clear_has_rpleaderboardcommand();
  inline void set_has_ghostrecordcommand();
  inline void clear_has_ghostrecordcommand();
  inline void set_has_challengemathinfocommand();
  inline void clear_has_challengemathinfocommand();
  inline void set_has_profileuserdatacommand();
  inline void clear_has_profileuserdatacommand();
  inline void set_has_profilenextcarcommand();
  inline void clear_has_profilenextcarcommand();
  inline void set_has_profilelikecommand();
  inline void clear_has_profilelikecommand();
  inline void set_has_profilereportcommand();
  inline void clear_has_profilereportcommand();
  inline void set_has_profilevscommand();
  inline void clear_has_profilevscommand();
  inline void set_has_gotchacommand();
  inline void clear_has_gotchacommand();
  inline void set_has_cheatinfocommand();
  inline void clear_has_cheatinfocommand();
  inline void set_has_recorduserraceactioncommand();
  inline void clear_has_recorduserraceactioncommand();
  inline void set_has_systemcommand();
  inline void clear_has_systemcommand();
  inline void set_has_leaderboardclasscommand();
  inline void clear_has_leaderboardclasscommand();
  inline void set_has_leaderboardcommand();
  inline void clear_has_leaderboardcommand();
  inline void set_has_requesttournamentnum();
  inline void clear_has_requesttournamentnum();
  inline void set_has_requestquickrace();
  inline void clear_has_requestquickrace();
  inline void set_has_bindingtokencommand();
  inline void clear_has_bindingtokencommand();
  inline void set_has_bindinginfocommand();
  inline void clear_has_bindinginfocommand();
  inline void set_has_collectenergycommand();
  inline void clear_has_collectenergycommand();
  inline void set_has_energytimecommand();
  inline void clear_has_energytimecommand();
  inline void set_has_fansrewardcommand();
  inline void clear_has_fansrewardcommand();
  inline void set_has_proppurchasecommand();
  inline void clear_has_proppurchasecommand();
  inline void set_has_missionrewardcommand();
  inline void clear_has_missionrewardcommand();
  inline void set_has_missionfinishcommand();
  inline void clear_has_missionfinishcommand();
  inline void set_has_lotterycommand();
  inline void clear_has_lotterycommand();
  inline void set_has_fleetracecommand();
  inline void clear_has_fleetracecommand();
  inline void set_has_fleetstartcommand();
  inline void clear_has_fleetstartcommand();
  inline void set_has_fleetendcommand();
  inline void clear_has_fleetendcommand();
  inline void set_has_fleetdoublecommand();
  inline void clear_has_fleetdoublecommand();
  inline void set_has_fixcarlimitcommand();
  inline void clear_has_fixcarlimitcommand();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::HeadInfo* head_;
  ::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand* trackcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand* logincommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand* ghostcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand* raceresultcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand* tournamentdetailcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand* tournamentrewarddetailcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand* tournamentcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand* resourcecommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand* tournamentsignupcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand* racestartcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand* bindingstartcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand* bindingresultcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand* bindingconfirmcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand* getrward_;
  ::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand* garagecommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand* buycarcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand* cardatacommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand* upgradeslotcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand* usechartletcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand* modifyuserinfocommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand* storedetailcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand* buyitemcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand* registjaguar_;
  ::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand* iapcheckcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand* tutorialrewardcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand* rpleaderboardcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand* ghostrecordcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand* challengemathinfocommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand* profileuserdatacommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand* profilenextcarcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand* profilelikecommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand* profilereportcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand* profilevscommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand* gotchacommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand* cheatinfocommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand* recorduserraceactioncommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand* systemcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass* leaderboardclasscommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard* leaderboardcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum* requesttournamentnum_;
  ::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand* requestquickrace_;
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand* bindingtokencommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand* bindinginfocommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand* collectenergycommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand* energytimecommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand* fansrewardcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand* proppurchasecommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand* missionrewardcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand* missionfinishcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand* lotterycommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand* fleetracecommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand* fleetstartcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand* fleetendcommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand* fleetdoublecommand_;
  ::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand* fixcarlimitcommand_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(56 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static RequestCommand* default_instance_;
};
// -------------------------------------------------------------------

class ResponseCommand : public ::google::protobuf::Message {
 public:
  ResponseCommand();
  virtual ~ResponseCommand();
  
  ResponseCommand(const ResponseCommand& from);
  
  inline ResponseCommand& operator=(const ResponseCommand& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCommand& default_instance();
  
  void Swap(ResponseCommand* other);
  
  // implements Message ----------------------------------------------
  
  ResponseCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseCommand& from);
  void MergeFrom(const ResponseCommand& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .com.ea.eamobile.nfsmw.protoc.HeadInfo head = 1;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 1;
  inline const ::com::ea::eamobile::nfsmw::protoc::HeadInfo& head() const;
  inline ::com::ea::eamobile::nfsmw::protoc::HeadInfo* mutable_head();
  inline ::com::ea::eamobile::nfsmw::protoc::HeadInfo* release_head();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTrackCommand trackCommand = 2;
  inline bool has_trackcommand() const;
  inline void clear_trackcommand();
  static const int kTrackCommandFieldNumber = 2;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand& trackcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand* mutable_trackcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand* release_trackcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseUserInfoCommand userInfoCommand = 3;
  inline bool has_userinfocommand() const;
  inline void clear_userinfocommand();
  static const int kUserInfoCommandFieldNumber = 3;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand& userinfocommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand* mutable_userinfocommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand* release_userinfocommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseRacerForGhostCommand ghostCommand = 4;
  inline bool has_ghostcommand() const;
  inline void clear_ghostcommand();
  static const int kGhostCommandFieldNumber = 4;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand& ghostcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand* mutable_ghostcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand* release_ghostcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseRaceResultCommand raceResultCommand = 5;
  inline bool has_raceresultcommand() const;
  inline void clear_raceresultcommand();
  static const int kRaceResultCommandFieldNumber = 5;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand& raceresultcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand* mutable_raceresultcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand* release_raceresultcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentDetailCommand tournamentDetailCommand = 6;
  inline bool has_tournamentdetailcommand() const;
  inline void clear_tournamentdetailcommand();
  static const int kTournamentDetailCommandFieldNumber = 6;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand& tournamentdetailcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand* mutable_tournamentdetailcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand* release_tournamentdetailcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentRewardDetailCommand tournamentRewardDetailCommand = 7;
  inline bool has_tournamentrewarddetailcommand() const;
  inline void clear_tournamentrewarddetailcommand();
  static const int kTournamentRewardDetailCommandFieldNumber = 7;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand& tournamentrewarddetailcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand* mutable_tournamentrewarddetailcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand* release_tournamentrewarddetailcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentCommand tournamentCommand = 9;
  inline bool has_tournamentcommand() const;
  inline void clear_tournamentcommand();
  static const int kTournamentCommandFieldNumber = 9;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand& tournamentcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand* mutable_tournamentcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand* release_tournamentcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseResourceCommand resourceCommand = 10;
  inline bool has_resourcecommand() const;
  inline void clear_resourcecommand();
  static const int kResourceCommandFieldNumber = 10;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand& resourcecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand* mutable_resourcecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand* release_resourcecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentSignUpCommand tournamentSignUpCommand = 17;
  inline bool has_tournamentsignupcommand() const;
  inline void clear_tournamentsignupcommand();
  static const int kTournamentSignUpCommandFieldNumber = 17;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand& tournamentsignupcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand* mutable_tournamentsignupcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand* release_tournamentsignupcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseRaceStartCommand raceStartCommand = 19;
  inline bool has_racestartcommand() const;
  inline void clear_racestartcommand();
  static const int kRaceStartCommandFieldNumber = 19;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand& racestartcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand* mutable_racestartcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand* release_racestartcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingStartCommand bindingStartCommand = 20;
  inline bool has_bindingstartcommand() const;
  inline void clear_bindingstartcommand();
  static const int kBindingStartCommandFieldNumber = 20;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand& bindingstartcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand* mutable_bindingstartcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand* release_bindingstartcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingResultCommand bindingResultCommand = 21;
  inline bool has_bindingresultcommand() const;
  inline void clear_bindingresultcommand();
  static const int kBindingResultCommandFieldNumber = 21;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand& bindingresultcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand* mutable_bindingresultcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand* release_bindingresultcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingConfirmCommand bindingConfirmCommand = 22;
  inline bool has_bindingconfirmcommand() const;
  inline void clear_bindingconfirmcommand();
  static const int kBindingConfirmCommandFieldNumber = 22;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand& bindingconfirmcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* mutable_bindingconfirmcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* release_bindingconfirmcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingPopupCommand bindingPopupCommand = 23;
  inline bool has_bindingpopupcommand() const;
  inline void clear_bindingpopupcommand();
  static const int kBindingPopupCommandFieldNumber = 23;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand& bindingpopupcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand* mutable_bindingpopupcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand* release_bindingpopupcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ErrorCommand errorCommand = 24;
  inline bool has_errorcommand() const;
  inline void clear_errorcommand();
  static const int kErrorCommandFieldNumber = 24;
  inline const ::com::ea::eamobile::nfsmw::protoc::ErrorCommand& errorcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* mutable_errorcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* release_errorcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseModeInfoCommand modeInfoCommand = 25;
  inline bool has_modeinfocommand() const;
  inline void clear_modeinfocommand();
  static const int kModeInfoCommandFieldNumber = 25;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand& modeinfocommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand* mutable_modeinfocommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand* release_modeinfocommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.responseTournamentRewardCommand rewardCommand = 26;
  inline bool has_rewardcommand() const;
  inline void clear_rewardcommand();
  static const int kRewardCommandFieldNumber = 26;
  inline const ::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand& rewardcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand* mutable_rewardcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand* release_rewardcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseGetRewardCommand getReward = 27;
  inline bool has_getreward() const;
  inline void clear_getreward();
  static const int kGetRewardFieldNumber = 27;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand& getreward() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand* mutable_getreward();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand* release_getreward();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentRaceStartCommand tournamentRaceStart = 28;
  inline bool has_tournamentracestart() const;
  inline void clear_tournamentracestart();
  static const int kTournamentRaceStartFieldNumber = 28;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand& tournamentracestart() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand* mutable_tournamentracestart();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand* release_tournamentracestart();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentRaceResultCommand tournamentRaceReault = 29;
  inline bool has_tournamentracereault() const;
  inline void clear_tournamentracereault();
  static const int kTournamentRaceReaultFieldNumber = 29;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand& tournamentracereault() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand* mutable_tournamentracereault();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand* release_tournamentracereault();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseGarageCommand garageCommand = 30;
  inline bool has_garagecommand() const;
  inline void clear_garagecommand();
  static const int kGarageCommandFieldNumber = 30;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand& garagecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand* mutable_garagecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand* release_garagecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBuyCarCommand buyCarCommand = 31;
  inline bool has_buycarcommand() const;
  inline void clear_buycarcommand();
  static const int kBuyCarCommandFieldNumber = 31;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand& buycarcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand* mutable_buycarcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand* release_buycarcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseCarDataCommand carDataCommand = 32;
  inline bool has_cardatacommand() const;
  inline void clear_cardatacommand();
  static const int kCarDataCommandFieldNumber = 32;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand& cardatacommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand* mutable_cardatacommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand* release_cardatacommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseUpgradeSlotCommand upgradeSlotCommand = 33;
  inline bool has_upgradeslotcommand() const;
  inline void clear_upgradeslotcommand();
  static const int kUpgradeSlotCommandFieldNumber = 33;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand& upgradeslotcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand* mutable_upgradeslotcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand* release_upgradeslotcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseUseChartletCommand useChartletCommand = 34;
  inline bool has_usechartletcommand() const;
  inline void clear_usechartletcommand();
  static const int kUseChartletCommandFieldNumber = 34;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand& usechartletcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand* mutable_usechartletcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand* release_usechartletcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseModifyUserInfoCommand modifyUserInfoCommand = 35;
  inline bool has_modifyuserinfocommand() const;
  inline void clear_modifyuserinfocommand();
  static const int kModifyUserInfoCommandFieldNumber = 35;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand& modifyuserinfocommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand* mutable_modifyuserinfocommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand* release_modifyuserinfocommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseChallengeMatchInfoCommand challengeMatchInfoCommand = 36;
  inline bool has_challengematchinfocommand() const;
  inline void clear_challengematchinfocommand();
  static const int kChallengeMatchInfoCommandFieldNumber = 36;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand& challengematchinfocommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand* mutable_challengematchinfocommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand* release_challengematchinfocommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseStoreDetailCommand storeDetailCommand = 37;
  inline bool has_storedetailcommand() const;
  inline void clear_storedetailcommand();
  static const int kStoreDetailCommandFieldNumber = 37;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand& storedetailcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand* mutable_storedetailcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand* release_storedetailcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBuyItemCommand buyItemCommand = 38;
  inline bool has_buyitemcommand() const;
  inline void clear_buyitemcommand();
  static const int kBuyItemCommandFieldNumber = 38;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand& buyitemcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand* mutable_buyitemcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand* release_buyitemcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseSystemCommand systemCommand = 39;
  inline bool has_systemcommand() const;
  inline void clear_systemcommand();
  static const int kSystemCommandFieldNumber = 39;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand& systemcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand* mutable_systemcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand* release_systemcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseWeiboShareLocksCommand weiboShareCommand = 40;
  inline bool has_weibosharecommand() const;
  inline void clear_weibosharecommand();
  static const int kWeiboShareCommandFieldNumber = 40;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand& weibosharecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand* mutable_weibosharecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand* release_weibosharecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseRegistJaguarCommand registJaguar = 41;
  inline bool has_registjaguar() const;
  inline void clear_registjaguar();
  static const int kRegistJaguarFieldNumber = 41;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand& registjaguar() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand* mutable_registjaguar();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand* release_registjaguar();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseFeedCommand feedCommand = 42;
  inline bool has_feedcommand() const;
  inline void clear_feedcommand();
  static const int kFeedCommandFieldNumber = 42;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand& feedcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand* mutable_feedcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand* release_feedcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseIapCheckCommand IapCheckCommand = 43;
  inline bool has_iapcheckcommand() const;
  inline void clear_iapcheckcommand();
  static const int kIapCheckCommandFieldNumber = 43;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand& iapcheckcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand* mutable_iapcheckcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand* release_iapcheckcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentNotificationCommand tournamentNotificationCommand = 44;
  inline bool has_tournamentnotificationcommand() const;
  inline void clear_tournamentnotificationcommand();
  static const int kTournamentNotificationCommandFieldNumber = 44;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand& tournamentnotificationcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand* mutable_tournamentnotificationcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand* release_tournamentnotificationcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTutorialRewardCommand tutorialRewardCommand = 45;
  inline bool has_tutorialrewardcommand() const;
  inline void clear_tutorialrewardcommand();
  static const int kTutorialRewardCommandFieldNumber = 45;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand& tutorialrewardcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand* mutable_tutorialrewardcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand* release_tutorialrewardcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponsePopupCommand popupCommand = 46;
  inline bool has_popupcommand() const;
  inline void clear_popupcommand();
  static const int kPopupCommandFieldNumber = 46;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand& popupcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* mutable_popupcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* release_popupcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseRpLeaderboardCommand rpLeaderboardCommand = 47;
  inline bool has_rpleaderboardcommand() const;
  inline void clear_rpleaderboardcommand();
  static const int kRpLeaderboardCommandFieldNumber = 47;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand& rpleaderboardcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand* mutable_rpleaderboardcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand* release_rpleaderboardcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseNotificationCommand notificationCommand = 48;
  inline bool has_notificationcommand() const;
  inline void clear_notificationcommand();
  static const int kNotificationCommandFieldNumber = 48;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand& notificationcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand* mutable_notificationcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand* release_notificationcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseGhostRecordCommand ghostRecordCommand = 49;
  inline bool has_ghostrecordcommand() const;
  inline void clear_ghostrecordcommand();
  static const int kGhostRecordCommandFieldNumber = 49;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand& ghostrecordcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand* mutable_ghostrecordcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand* release_ghostrecordcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentRewardNumCommand tournamentRewardNumCommand = 50;
  inline bool has_tournamentrewardnumcommand() const;
  inline void clear_tournamentrewardnumcommand();
  static const int kTournamentRewardNumCommandFieldNumber = 50;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand& tournamentrewardnumcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand* mutable_tournamentrewardnumcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand* release_tournamentrewardnumcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileUserDataCommand profileUserDataCommand = 51;
  inline bool has_profileuserdatacommand() const;
  inline void clear_profileuserdatacommand();
  static const int kProfileUserDataCommandFieldNumber = 51;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand& profileuserdatacommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand* mutable_profileuserdatacommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand* release_profileuserdatacommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileNextCarCommand profileNextCarCommand = 52;
  inline bool has_profilenextcarcommand() const;
  inline void clear_profilenextcarcommand();
  static const int kProfileNextCarCommandFieldNumber = 52;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand& profilenextcarcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand* mutable_profilenextcarcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand* release_profilenextcarcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileLikeCommand profileLikeCommand = 53;
  inline bool has_profilelikecommand() const;
  inline void clear_profilelikecommand();
  static const int kProfileLikeCommandFieldNumber = 53;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand& profilelikecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand* mutable_profilelikecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand* release_profilelikecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileReportCommand profileReportCommand = 54;
  inline bool has_profilereportcommand() const;
  inline void clear_profilereportcommand();
  static const int kProfileReportCommandFieldNumber = 54;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand& profilereportcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand* mutable_profilereportcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand* release_profilereportcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileVSCommand profileVSCommand = 55;
  inline bool has_profilevscommand() const;
  inline void clear_profilevscommand();
  static const int kProfileVSCommandFieldNumber = 55;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand& profilevscommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand* mutable_profilevscommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand* release_profilevscommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseGotchaCommand gotchaCommand = 56;
  inline bool has_gotchacommand() const;
  inline void clear_gotchacommand();
  static const int kGotchaCommandFieldNumber = 56;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand& gotchacommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand* mutable_gotchacommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand* release_gotchacommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseLeaderboardClass leaderboardClassCommand = 57;
  inline bool has_leaderboardclasscommand() const;
  inline void clear_leaderboardclasscommand();
  static const int kLeaderboardClassCommandFieldNumber = 57;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass& leaderboardclasscommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass* mutable_leaderboardclasscommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass* release_leaderboardclasscommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseLeaderboard leaderboardCommand = 58;
  inline bool has_leaderboardcommand() const;
  inline void clear_leaderboardcommand();
  static const int kLeaderboardCommandFieldNumber = 58;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard& leaderboardcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard* mutable_leaderboardcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard* release_leaderboardcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentNum responseTournamentNum = 59;
  inline bool has_responsetournamentnum() const;
  inline void clear_responsetournamentnum();
  static const int kResponseTournamentNumFieldNumber = 59;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum& responsetournamentnum() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum* mutable_responsetournamentnum();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum* release_responsetournamentnum();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseQuickRaceCommand responseQuickRace = 60;
  inline bool has_responsequickrace() const;
  inline void clear_responsequickrace();
  static const int kResponseQuickRaceFieldNumber = 60;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand& responsequickrace() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand* mutable_responsequickrace();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand* release_responsequickrace();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingTokenCommand bindingTokenCommand = 61;
  inline bool has_bindingtokencommand() const;
  inline void clear_bindingtokencommand();
  static const int kBindingTokenCommandFieldNumber = 61;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand& bindingtokencommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand* mutable_bindingtokencommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand* release_bindingtokencommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingInfoCommand bindingInfoCommand = 62;
  inline bool has_bindinginfocommand() const;
  inline void clear_bindinginfocommand();
  static const int kBindingInfoCommandFieldNumber = 62;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand& bindinginfocommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand* mutable_bindinginfocommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand* release_bindinginfocommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseEnergyTimeCommand energyTimeCommand = 63;
  inline bool has_energytimecommand() const;
  inline void clear_energytimecommand();
  static const int kEnergyTimeCommandFieldNumber = 63;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand& energytimecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand* mutable_energytimecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand* release_energytimecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseFansRewardTimeCommand fansRewardTimeCommand = 64;
  inline bool has_fansrewardtimecommand() const;
  inline void clear_fansrewardtimecommand();
  static const int kFansRewardTimeCommandFieldNumber = 64;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand& fansrewardtimecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand* mutable_fansrewardtimecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand* release_fansrewardtimecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseMissionListCommand missionListCommand = 65;
  inline bool has_missionlistcommand() const;
  inline void clear_missionlistcommand();
  static const int kMissionListCommandFieldNumber = 65;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand& missionlistcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand* mutable_missionlistcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand* release_missionlistcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseLotteryCommand lotteryCommand = 66;
  inline bool has_lotterycommand() const;
  inline void clear_lotterycommand();
  static const int kLotteryCommandFieldNumber = 66;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand& lotterycommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand* mutable_lotterycommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand* release_lotterycommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponsePopupListCommand popuplistCommand = 67;
  inline bool has_popuplistcommand() const;
  inline void clear_popuplistcommand();
  static const int kPopuplistCommandFieldNumber = 67;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand& popuplistcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand* mutable_popuplistcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand* release_popuplistcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseFleetRaceCommand fleetRaceCommand = 68;
  inline bool has_fleetracecommand() const;
  inline void clear_fleetracecommand();
  static const int kFleetRaceCommandFieldNumber = 68;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand& fleetracecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand* mutable_fleetracecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand* release_fleetracecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseFleetStartCommand fleetStartCommand = 69;
  inline bool has_fleetstartcommand() const;
  inline void clear_fleetstartcommand();
  static const int kFleetStartCommandFieldNumber = 69;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand& fleetstartcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand* mutable_fleetstartcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand* release_fleetstartcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseFleetEndCommand fleetEndCommand = 70;
  inline bool has_fleetendcommand() const;
  inline void clear_fleetendcommand();
  static const int kFleetEndCommandFieldNumber = 70;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand& fleetendcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand* mutable_fleetendcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand* release_fleetendcommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseFleetDoubleCommand fleetDoubleCommand = 71;
  inline bool has_fleetdoublecommand() const;
  inline void clear_fleetdoublecommand();
  static const int kFleetDoubleCommandFieldNumber = 71;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand& fleetdoublecommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand* mutable_fleetdoublecommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand* release_fleetdoublecommand();
  
  // optional .com.ea.eamobile.nfsmw.protoc.ResponseFixCarLimitCommand fixCarLimitCommand = 72;
  inline bool has_fixcarlimitcommand() const;
  inline void clear_fixcarlimitcommand();
  static const int kFixCarLimitCommandFieldNumber = 72;
  inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand& fixcarlimitcommand() const;
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand* mutable_fixcarlimitcommand();
  inline ::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand* release_fixcarlimitcommand();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.ResponseCommand)
 private:
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_trackcommand();
  inline void clear_has_trackcommand();
  inline void set_has_userinfocommand();
  inline void clear_has_userinfocommand();
  inline void set_has_ghostcommand();
  inline void clear_has_ghostcommand();
  inline void set_has_raceresultcommand();
  inline void clear_has_raceresultcommand();
  inline void set_has_tournamentdetailcommand();
  inline void clear_has_tournamentdetailcommand();
  inline void set_has_tournamentrewarddetailcommand();
  inline void clear_has_tournamentrewarddetailcommand();
  inline void set_has_tournamentcommand();
  inline void clear_has_tournamentcommand();
  inline void set_has_resourcecommand();
  inline void clear_has_resourcecommand();
  inline void set_has_tournamentsignupcommand();
  inline void clear_has_tournamentsignupcommand();
  inline void set_has_racestartcommand();
  inline void clear_has_racestartcommand();
  inline void set_has_bindingstartcommand();
  inline void clear_has_bindingstartcommand();
  inline void set_has_bindingresultcommand();
  inline void clear_has_bindingresultcommand();
  inline void set_has_bindingconfirmcommand();
  inline void clear_has_bindingconfirmcommand();
  inline void set_has_bindingpopupcommand();
  inline void clear_has_bindingpopupcommand();
  inline void set_has_errorcommand();
  inline void clear_has_errorcommand();
  inline void set_has_modeinfocommand();
  inline void clear_has_modeinfocommand();
  inline void set_has_rewardcommand();
  inline void clear_has_rewardcommand();
  inline void set_has_getreward();
  inline void clear_has_getreward();
  inline void set_has_tournamentracestart();
  inline void clear_has_tournamentracestart();
  inline void set_has_tournamentracereault();
  inline void clear_has_tournamentracereault();
  inline void set_has_garagecommand();
  inline void clear_has_garagecommand();
  inline void set_has_buycarcommand();
  inline void clear_has_buycarcommand();
  inline void set_has_cardatacommand();
  inline void clear_has_cardatacommand();
  inline void set_has_upgradeslotcommand();
  inline void clear_has_upgradeslotcommand();
  inline void set_has_usechartletcommand();
  inline void clear_has_usechartletcommand();
  inline void set_has_modifyuserinfocommand();
  inline void clear_has_modifyuserinfocommand();
  inline void set_has_challengematchinfocommand();
  inline void clear_has_challengematchinfocommand();
  inline void set_has_storedetailcommand();
  inline void clear_has_storedetailcommand();
  inline void set_has_buyitemcommand();
  inline void clear_has_buyitemcommand();
  inline void set_has_systemcommand();
  inline void clear_has_systemcommand();
  inline void set_has_weibosharecommand();
  inline void clear_has_weibosharecommand();
  inline void set_has_registjaguar();
  inline void clear_has_registjaguar();
  inline void set_has_feedcommand();
  inline void clear_has_feedcommand();
  inline void set_has_iapcheckcommand();
  inline void clear_has_iapcheckcommand();
  inline void set_has_tournamentnotificationcommand();
  inline void clear_has_tournamentnotificationcommand();
  inline void set_has_tutorialrewardcommand();
  inline void clear_has_tutorialrewardcommand();
  inline void set_has_popupcommand();
  inline void clear_has_popupcommand();
  inline void set_has_rpleaderboardcommand();
  inline void clear_has_rpleaderboardcommand();
  inline void set_has_notificationcommand();
  inline void clear_has_notificationcommand();
  inline void set_has_ghostrecordcommand();
  inline void clear_has_ghostrecordcommand();
  inline void set_has_tournamentrewardnumcommand();
  inline void clear_has_tournamentrewardnumcommand();
  inline void set_has_profileuserdatacommand();
  inline void clear_has_profileuserdatacommand();
  inline void set_has_profilenextcarcommand();
  inline void clear_has_profilenextcarcommand();
  inline void set_has_profilelikecommand();
  inline void clear_has_profilelikecommand();
  inline void set_has_profilereportcommand();
  inline void clear_has_profilereportcommand();
  inline void set_has_profilevscommand();
  inline void clear_has_profilevscommand();
  inline void set_has_gotchacommand();
  inline void clear_has_gotchacommand();
  inline void set_has_leaderboardclasscommand();
  inline void clear_has_leaderboardclasscommand();
  inline void set_has_leaderboardcommand();
  inline void clear_has_leaderboardcommand();
  inline void set_has_responsetournamentnum();
  inline void clear_has_responsetournamentnum();
  inline void set_has_responsequickrace();
  inline void clear_has_responsequickrace();
  inline void set_has_bindingtokencommand();
  inline void clear_has_bindingtokencommand();
  inline void set_has_bindinginfocommand();
  inline void clear_has_bindinginfocommand();
  inline void set_has_energytimecommand();
  inline void clear_has_energytimecommand();
  inline void set_has_fansrewardtimecommand();
  inline void clear_has_fansrewardtimecommand();
  inline void set_has_missionlistcommand();
  inline void clear_has_missionlistcommand();
  inline void set_has_lotterycommand();
  inline void clear_has_lotterycommand();
  inline void set_has_popuplistcommand();
  inline void clear_has_popuplistcommand();
  inline void set_has_fleetracecommand();
  inline void clear_has_fleetracecommand();
  inline void set_has_fleetstartcommand();
  inline void clear_has_fleetstartcommand();
  inline void set_has_fleetendcommand();
  inline void clear_has_fleetendcommand();
  inline void set_has_fleetdoublecommand();
  inline void clear_has_fleetdoublecommand();
  inline void set_has_fixcarlimitcommand();
  inline void clear_has_fixcarlimitcommand();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::com::ea::eamobile::nfsmw::protoc::HeadInfo* head_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand* trackcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand* userinfocommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand* ghostcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand* raceresultcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand* tournamentdetailcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand* tournamentrewarddetailcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand* tournamentcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand* resourcecommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand* tournamentsignupcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand* racestartcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand* bindingstartcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand* bindingresultcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* bindingconfirmcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand* bindingpopupcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* errorcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand* modeinfocommand_;
  ::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand* rewardcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand* getreward_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand* tournamentracestart_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand* tournamentracereault_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand* garagecommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand* buycarcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand* cardatacommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand* upgradeslotcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand* usechartletcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand* modifyuserinfocommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand* challengematchinfocommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand* storedetailcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand* buyitemcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand* systemcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand* weibosharecommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand* registjaguar_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand* feedcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand* iapcheckcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand* tournamentnotificationcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand* tutorialrewardcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* popupcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand* rpleaderboardcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand* notificationcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand* ghostrecordcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand* tournamentrewardnumcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand* profileuserdatacommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand* profilenextcarcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand* profilelikecommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand* profilereportcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand* profilevscommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand* gotchacommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass* leaderboardclasscommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard* leaderboardcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum* responsetournamentnum_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand* responsequickrace_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand* bindingtokencommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand* bindinginfocommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand* energytimecommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand* fansrewardtimecommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand* missionlistcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand* lotterycommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand* popuplistcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand* fleetracecommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand* fleetstartcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand* fleetendcommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand* fleetdoublecommand_;
  ::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand* fixcarlimitcommand_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(64 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static ResponseCommand* default_instance_;
};
// -------------------------------------------------------------------

class LocalUserinfo : public ::google::protobuf::Message {
 public:
  LocalUserinfo();
  virtual ~LocalUserinfo();
  
  LocalUserinfo(const LocalUserinfo& from);
  
  inline LocalUserinfo& operator=(const LocalUserinfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LocalUserinfo& default_instance();
  
  void Swap(LocalUserinfo* other);
  
  // implements Message ----------------------------------------------
  
  LocalUserinfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocalUserinfo& from);
  void MergeFrom(const LocalUserinfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 snsFlag = 1;
  inline bool has_snsflag() const;
  inline void clear_snsflag();
  static const int kSnsFlagFieldNumber = 1;
  inline ::google::protobuf::int32 snsflag() const;
  inline void set_snsflag(::google::protobuf::int32 value);
  
  // optional string session = 2;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 2;
  inline const ::std::string& session() const;
  inline void set_session(const ::std::string& value);
  inline void set_session(const char* value);
  inline void set_session(const char* value, size_t size);
  inline ::std::string* mutable_session();
  inline ::std::string* release_session();
  
  // required string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  
  // repeated string serverUrl = 4;
  inline int serverurl_size() const;
  inline void clear_serverurl();
  static const int kServerUrlFieldNumber = 4;
  inline const ::std::string& serverurl(int index) const;
  inline ::std::string* mutable_serverurl(int index);
  inline void set_serverurl(int index, const ::std::string& value);
  inline void set_serverurl(int index, const char* value);
  inline void set_serverurl(int index, const char* value, size_t size);
  inline ::std::string* add_serverurl();
  inline void add_serverurl(const ::std::string& value);
  inline void add_serverurl(const char* value);
  inline void add_serverurl(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& serverurl() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_serverurl();
  
  // optional string access_token = 5;
  inline bool has_access_token() const;
  inline void clear_access_token();
  static const int kAccessTokenFieldNumber = 5;
  inline const ::std::string& access_token() const;
  inline void set_access_token(const ::std::string& value);
  inline void set_access_token(const char* value);
  inline void set_access_token(const char* value, size_t size);
  inline ::std::string* mutable_access_token();
  inline ::std::string* release_access_token();
  
  // optional string uid = 6;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 6;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  
  // @@protoc_insertion_point(class_scope:com.ea.eamobile.nfsmw.protoc.LocalUserinfo)
 private:
  inline void set_has_snsflag();
  inline void clear_has_snsflag();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_access_token();
  inline void clear_has_access_token();
  inline void set_has_uid();
  inline void clear_has_uid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* session_;
  ::std::string* token_;
  ::google::protobuf::RepeatedPtrField< ::std::string> serverurl_;
  ::std::string* access_token_;
  ::std::string* uid_;
  ::google::protobuf::int32 snsflag_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Commands_2eproto();
  friend void protobuf_AssignDesc_Commands_2eproto();
  friend void protobuf_ShutdownFile_Commands_2eproto();
  
  void InitAsDefaultInstance();
  static LocalUserinfo* default_instance_;
};
// ===================================================================


// ===================================================================

// UserViewInfo

// required int64 userId = 1;
inline bool UserViewInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserViewInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserViewInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserViewInfo::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 UserViewInfo::userid() const {
  return userid_;
}
inline void UserViewInfo::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// required string headUrl = 2;
inline bool UserViewInfo::has_headurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserViewInfo::set_has_headurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserViewInfo::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserViewInfo::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& UserViewInfo::headurl() const {
  return *headurl_;
}
inline void UserViewInfo::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void UserViewInfo::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void UserViewInfo::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserViewInfo::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* UserViewInfo::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 3;
inline bool UserViewInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserViewInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserViewInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserViewInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserViewInfo::name() const {
  return *name_;
}
inline void UserViewInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserViewInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserViewInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserViewInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserViewInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string email = 4;
inline bool UserViewInfo::has_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserViewInfo::set_has_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserViewInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserViewInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserViewInfo::email() const {
  return *email_;
}
inline void UserViewInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserViewInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserViewInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserViewInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* UserViewInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string mobile = 5;
inline bool UserViewInfo::has_mobile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserViewInfo::set_has_mobile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserViewInfo::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserViewInfo::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& UserViewInfo::mobile() const {
  return *mobile_;
}
inline void UserViewInfo::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void UserViewInfo::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void UserViewInfo::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserViewInfo::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* UserViewInfo::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 status = 6;
inline bool UserViewInfo::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserViewInfo::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserViewInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserViewInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 UserViewInfo::status() const {
  return status_;
}
inline void UserViewInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int32 money = 7;
inline bool UserViewInfo::has_money() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserViewInfo::set_has_money() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserViewInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserViewInfo::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 UserViewInfo::money() const {
  return money_;
}
inline void UserViewInfo::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// required int64 createTime = 8;
inline bool UserViewInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserViewInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserViewInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserViewInfo::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 UserViewInfo::createtime() const {
  return createtime_;
}
inline void UserViewInfo::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// required int64 loginTime = 9;
inline bool UserViewInfo::has_logintime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserViewInfo::set_has_logintime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserViewInfo::clear_has_logintime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserViewInfo::clear_logintime() {
  logintime_ = GOOGLE_LONGLONG(0);
  clear_has_logintime();
}
inline ::google::protobuf::int64 UserViewInfo::logintime() const {
  return logintime_;
}
inline void UserViewInfo::set_logintime(::google::protobuf::int64 value) {
  set_has_logintime();
  logintime_ = value;
}

// optional bool isNameChanged = 10;
inline bool UserViewInfo::has_isnamechanged() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserViewInfo::set_has_isnamechanged() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserViewInfo::clear_has_isnamechanged() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserViewInfo::clear_isnamechanged() {
  isnamechanged_ = false;
  clear_has_isnamechanged();
}
inline bool UserViewInfo::isnamechanged() const {
  return isnamechanged_;
}
inline void UserViewInfo::set_isnamechanged(bool value) {
  set_has_isnamechanged();
  isnamechanged_ = value;
}

// -------------------------------------------------------------------

// MissionInfo

// required int32 id = 1;
inline bool MissionInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MissionInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MissionInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MissionInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MissionInfo::id() const {
  return id_;
}
inline void MissionInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool MissionInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MissionInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MissionInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MissionInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MissionInfo::name() const {
  return *name_;
}
inline void MissionInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MissionInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MissionInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MissionInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string des = 3;
inline bool MissionInfo::has_des() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MissionInfo::set_has_des() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MissionInfo::clear_has_des() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MissionInfo::clear_des() {
  if (des_ != &::google::protobuf::internal::kEmptyString) {
    des_->clear();
  }
  clear_has_des();
}
inline const ::std::string& MissionInfo::des() const {
  return *des_;
}
inline void MissionInfo::set_des(const ::std::string& value) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    des_ = new ::std::string;
  }
  des_->assign(value);
}
inline void MissionInfo::set_des(const char* value) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    des_ = new ::std::string;
  }
  des_->assign(value);
}
inline void MissionInfo::set_des(const char* value, size_t size) {
  set_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    des_ = new ::std::string;
  }
  des_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MissionInfo::mutable_des() {
  set_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    des_ = new ::std::string;
  }
  return des_;
}
inline ::std::string* MissionInfo::release_des() {
  clear_has_des();
  if (des_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = des_;
    des_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 rewardCount = 4;
inline int MissionInfo::rewardcount_size() const {
  return rewardcount_.size();
}
inline void MissionInfo::clear_rewardcount() {
  rewardcount_.Clear();
}
inline ::google::protobuf::int32 MissionInfo::rewardcount(int index) const {
  return rewardcount_.Get(index);
}
inline void MissionInfo::set_rewardcount(int index, ::google::protobuf::int32 value) {
  rewardcount_.Set(index, value);
}
inline void MissionInfo::add_rewardcount(::google::protobuf::int32 value) {
  rewardcount_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
MissionInfo::rewardcount() const {
  return rewardcount_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
MissionInfo::mutable_rewardcount() {
  return &rewardcount_;
}

// -------------------------------------------------------------------

// Reward

// optional int32 rmb = 1;
inline bool Reward::has_rmb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reward::set_has_rmb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reward::clear_has_rmb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reward::clear_rmb() {
  rmb_ = 0;
  clear_has_rmb();
}
inline ::google::protobuf::int32 Reward::rmb() const {
  return rmb_;
}
inline void Reward::set_rmb(::google::protobuf::int32 value) {
  set_has_rmb();
  rmb_ = value;
}

// optional int32 money = 2;
inline bool Reward::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reward::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reward::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reward::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 Reward::money() const {
  return money_;
}
inline void Reward::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional int32 rpNum = 3;
inline bool Reward::has_rpnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reward::set_has_rpnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reward::clear_has_rpnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reward::clear_rpnum() {
  rpnum_ = 0;
  clear_has_rpnum();
}
inline ::google::protobuf::int32 Reward::rpnum() const {
  return rpnum_;
}
inline void Reward::set_rpnum(::google::protobuf::int32 value) {
  set_has_rpnum();
  rpnum_ = value;
}

// optional int32 mostwantedNum = 4;
inline bool Reward::has_mostwantednum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reward::set_has_mostwantednum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reward::clear_has_mostwantednum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reward::clear_mostwantednum() {
  mostwantednum_ = 0;
  clear_has_mostwantednum();
}
inline ::google::protobuf::int32 Reward::mostwantednum() const {
  return mostwantednum_;
}
inline void Reward::set_mostwantednum(::google::protobuf::int32 value) {
  set_has_mostwantednum();
  mostwantednum_ = value;
}

// optional int32 finishRatio = 5;
inline bool Reward::has_finishratio() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Reward::set_has_finishratio() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Reward::clear_has_finishratio() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Reward::clear_finishratio() {
  finishratio_ = 0;
  clear_has_finishratio();
}
inline ::google::protobuf::int32 Reward::finishratio() const {
  return finishratio_;
}
inline void Reward::set_finishratio(::google::protobuf::int32 value) {
  set_has_finishratio();
  finishratio_ = value;
}

// optional string displayStrings = 6;
inline bool Reward::has_displaystrings() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Reward::set_has_displaystrings() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Reward::clear_has_displaystrings() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Reward::clear_displaystrings() {
  if (displaystrings_ != &::google::protobuf::internal::kEmptyString) {
    displaystrings_->clear();
  }
  clear_has_displaystrings();
}
inline const ::std::string& Reward::displaystrings() const {
  return *displaystrings_;
}
inline void Reward::set_displaystrings(const ::std::string& value) {
  set_has_displaystrings();
  if (displaystrings_ == &::google::protobuf::internal::kEmptyString) {
    displaystrings_ = new ::std::string;
  }
  displaystrings_->assign(value);
}
inline void Reward::set_displaystrings(const char* value) {
  set_has_displaystrings();
  if (displaystrings_ == &::google::protobuf::internal::kEmptyString) {
    displaystrings_ = new ::std::string;
  }
  displaystrings_->assign(value);
}
inline void Reward::set_displaystrings(const char* value, size_t size) {
  set_has_displaystrings();
  if (displaystrings_ == &::google::protobuf::internal::kEmptyString) {
    displaystrings_ = new ::std::string;
  }
  displaystrings_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Reward::mutable_displaystrings() {
  set_has_displaystrings();
  if (displaystrings_ == &::google::protobuf::internal::kEmptyString) {
    displaystrings_ = new ::std::string;
  }
  return displaystrings_;
}
inline ::std::string* Reward::release_displaystrings() {
  clear_has_displaystrings();
  if (displaystrings_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displaystrings_;
    displaystrings_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RewardN

// optional int32 id = 1;
inline bool RewardN::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RewardN::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RewardN::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RewardN::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RewardN::id() const {
  return id_;
}
inline void RewardN::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 count = 2;
inline bool RewardN::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RewardN::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RewardN::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RewardN::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 RewardN::count() const {
  return count_;
}
inline void RewardN::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// RewardList

// repeated .com.ea.eamobile.nfsmw.protoc.RewardN rewards = 1;
inline int RewardList::rewards_size() const {
  return rewards_.size();
}
inline void RewardList::clear_rewards() {
  rewards_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RewardN& RewardList::rewards(int index) const {
  return rewards_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RewardN* RewardList::mutable_rewards(int index) {
  return rewards_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RewardN* RewardList::add_rewards() {
  return rewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardN >&
RewardList::rewards() const {
  return rewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardN >*
RewardList::mutable_rewards() {
  return &rewards_;
}

// -------------------------------------------------------------------

// Prop

// optional int32 id = 1;
inline bool Prop::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Prop::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Prop::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Prop::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Prop::id() const {
  return id_;
}
inline void Prop::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 count = 2;
inline bool Prop::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Prop::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Prop::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Prop::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Prop::count() const {
  return count_;
}
inline void Prop::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// FleetRace

// required int32 id = 1;
inline bool FleetRace::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FleetRace::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FleetRace::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FleetRace::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 FleetRace::id() const {
  return id_;
}
inline void FleetRace::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 type = 2;
inline bool FleetRace::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FleetRace::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FleetRace::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FleetRace::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 FleetRace::type() const {
  return type_;
}
inline void FleetRace::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 name = 3;
inline bool FleetRace::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FleetRace::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FleetRace::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FleetRace::clear_name() {
  name_ = 0;
  clear_has_name();
}
inline ::google::protobuf::int32 FleetRace::name() const {
  return name_;
}
inline void FleetRace::set_name(::google::protobuf::int32 value) {
  set_has_name();
  name_ = value;
}

// required string carid = 4;
inline bool FleetRace::has_carid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FleetRace::set_has_carid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FleetRace::clear_has_carid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FleetRace::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& FleetRace::carid() const {
  return *carid_;
}
inline void FleetRace::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void FleetRace::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void FleetRace::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FleetRace::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* FleetRace::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 time = 5;
inline bool FleetRace::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FleetRace::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FleetRace::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FleetRace::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 FleetRace::time() const {
  return time_;
}
inline void FleetRace::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// required int32 points = 6;
inline bool FleetRace::has_points() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FleetRace::set_has_points() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FleetRace::clear_has_points() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FleetRace::clear_points() {
  points_ = 0;
  clear_has_points();
}
inline ::google::protobuf::int32 FleetRace::points() const {
  return points_;
}
inline void FleetRace::set_points(::google::protobuf::int32 value) {
  set_has_points();
  points_ = value;
}

// required int32 limitCost = 7;
inline bool FleetRace::has_limitcost() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FleetRace::set_has_limitcost() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FleetRace::clear_has_limitcost() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FleetRace::clear_limitcost() {
  limitcost_ = 0;
  clear_has_limitcost();
}
inline ::google::protobuf::int32 FleetRace::limitcost() const {
  return limitcost_;
}
inline void FleetRace::set_limitcost(::google::protobuf::int32 value) {
  set_has_limitcost();
  limitcost_ = value;
}

// required int32 energyCost = 8;
inline bool FleetRace::has_energycost() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FleetRace::set_has_energycost() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FleetRace::clear_has_energycost() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FleetRace::clear_energycost() {
  energycost_ = 0;
  clear_has_energycost();
}
inline ::google::protobuf::int32 FleetRace::energycost() const {
  return energycost_;
}
inline void FleetRace::set_energycost(::google::protobuf::int32 value) {
  set_has_energycost();
  energycost_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.RewardList rewards = 9;
inline int FleetRace::rewards_size() const {
  return rewards_.size();
}
inline void FleetRace::clear_rewards() {
  rewards_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RewardList& FleetRace::rewards(int index) const {
  return rewards_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RewardList* FleetRace::mutable_rewards(int index) {
  return rewards_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RewardList* FleetRace::add_rewards() {
  return rewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >&
FleetRace::rewards() const {
  return rewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >*
FleetRace::mutable_rewards() {
  return &rewards_;
}

// required int32 count = 10;
inline bool FleetRace::has_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FleetRace::set_has_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FleetRace::clear_has_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FleetRace::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 FleetRace::count() const {
  return count_;
}
inline void FleetRace::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required int32 state = 11;
inline bool FleetRace::has_state() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FleetRace::set_has_state() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FleetRace::clear_has_state() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FleetRace::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 FleetRace::state() const {
  return state_;
}
inline void FleetRace::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// required int32 tier = 12;
inline bool FleetRace::has_tier() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FleetRace::set_has_tier() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FleetRace::clear_has_tier() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FleetRace::clear_tier() {
  tier_ = 0;
  clear_has_tier();
}
inline ::google::protobuf::int32 FleetRace::tier() const {
  return tier_;
}
inline void FleetRace::set_tier(::google::protobuf::int32 value) {
  set_has_tier();
  tier_ = value;
}

// required int32 cartype = 13;
inline bool FleetRace::has_cartype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FleetRace::set_has_cartype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FleetRace::clear_has_cartype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FleetRace::clear_cartype() {
  cartype_ = 0;
  clear_has_cartype();
}
inline ::google::protobuf::int32 FleetRace::cartype() const {
  return cartype_;
}
inline void FleetRace::set_cartype(::google::protobuf::int32 value) {
  set_has_cartype();
  cartype_ = value;
}

// required int32 ramainTime = 14;
inline bool FleetRace::has_ramaintime() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FleetRace::set_has_ramaintime() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FleetRace::clear_has_ramaintime() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FleetRace::clear_ramaintime() {
  ramaintime_ = 0;
  clear_has_ramaintime();
}
inline ::google::protobuf::int32 FleetRace::ramaintime() const {
  return ramaintime_;
}
inline void FleetRace::set_ramaintime(::google::protobuf::int32 value) {
  set_has_ramaintime();
  ramaintime_ = value;
}

// -------------------------------------------------------------------

// Leaderboard

// required string name = 1;
inline bool Leaderboard::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Leaderboard::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Leaderboard::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Leaderboard::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Leaderboard::name() const {
  return *name_;
}
inline void Leaderboard::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Leaderboard::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Leaderboard::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Leaderboard::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Leaderboard::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float raceResult = 2;
inline bool Leaderboard::has_raceresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Leaderboard::set_has_raceresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Leaderboard::clear_has_raceresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Leaderboard::clear_raceresult() {
  raceresult_ = 0;
  clear_has_raceresult();
}
inline float Leaderboard::raceresult() const {
  return raceresult_;
}
inline void Leaderboard::set_raceresult(float value) {
  set_has_raceresult();
  raceresult_ = value;
}

// optional int32 headIndex = 3;
inline bool Leaderboard::has_headindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Leaderboard::set_has_headindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Leaderboard::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Leaderboard::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 Leaderboard::headindex() const {
  return headindex_;
}
inline void Leaderboard::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// optional string headUrl = 4;
inline bool Leaderboard::has_headurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Leaderboard::set_has_headurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Leaderboard::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Leaderboard::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& Leaderboard::headurl() const {
  return *headurl_;
}
inline void Leaderboard::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void Leaderboard::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void Leaderboard::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Leaderboard::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* Leaderboard::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 rank = 5;
inline bool Leaderboard::has_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Leaderboard::set_has_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Leaderboard::clear_has_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Leaderboard::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 Leaderboard::rank() const {
  return rank_;
}
inline void Leaderboard::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional bool isMyself = 6;
inline bool Leaderboard::has_ismyself() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Leaderboard::set_has_ismyself() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Leaderboard::clear_has_ismyself() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Leaderboard::clear_ismyself() {
  ismyself_ = false;
  clear_has_ismyself();
}
inline bool Leaderboard::ismyself() const {
  return ismyself_;
}
inline void Leaderboard::set_ismyself(bool value) {
  set_has_ismyself();
  ismyself_ = value;
}

// optional int64 userId = 7;
inline bool Leaderboard::has_userid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Leaderboard::set_has_userid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Leaderboard::clear_has_userid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Leaderboard::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 Leaderboard::userid() const {
  return userid_;
}
inline void Leaderboard::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// LeaderboardProfile

// required string name = 1;
inline bool LeaderboardProfile::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderboardProfile::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderboardProfile::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderboardProfile::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LeaderboardProfile::name() const {
  return *name_;
}
inline void LeaderboardProfile::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaderboardProfile::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaderboardProfile::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderboardProfile::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LeaderboardProfile::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float raceResult = 2;
inline bool LeaderboardProfile::has_raceresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaderboardProfile::set_has_raceresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaderboardProfile::clear_has_raceresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaderboardProfile::clear_raceresult() {
  raceresult_ = 0;
  clear_has_raceresult();
}
inline float LeaderboardProfile::raceresult() const {
  return raceresult_;
}
inline void LeaderboardProfile::set_raceresult(float value) {
  set_has_raceresult();
  raceresult_ = value;
}

// optional int32 headIndex = 3;
inline bool LeaderboardProfile::has_headindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaderboardProfile::set_has_headindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaderboardProfile::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaderboardProfile::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 LeaderboardProfile::headindex() const {
  return headindex_;
}
inline void LeaderboardProfile::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// optional string headUrl = 4;
inline bool LeaderboardProfile::has_headurl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LeaderboardProfile::set_has_headurl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LeaderboardProfile::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LeaderboardProfile::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& LeaderboardProfile::headurl() const {
  return *headurl_;
}
inline void LeaderboardProfile::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void LeaderboardProfile::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void LeaderboardProfile::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderboardProfile::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* LeaderboardProfile::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 rank = 5;
inline bool LeaderboardProfile::has_rank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LeaderboardProfile::set_has_rank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LeaderboardProfile::clear_has_rank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LeaderboardProfile::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 LeaderboardProfile::rank() const {
  return rank_;
}
inline void LeaderboardProfile::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional bool isMyself = 6;
inline bool LeaderboardProfile::has_ismyself() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LeaderboardProfile::set_has_ismyself() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LeaderboardProfile::clear_has_ismyself() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LeaderboardProfile::clear_ismyself() {
  ismyself_ = false;
  clear_has_ismyself();
}
inline bool LeaderboardProfile::ismyself() const {
  return ismyself_;
}
inline void LeaderboardProfile::set_ismyself(bool value) {
  set_has_ismyself();
  ismyself_ = value;
}

// optional string carID = 7;
inline bool LeaderboardProfile::has_carid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LeaderboardProfile::set_has_carid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LeaderboardProfile::clear_has_carid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LeaderboardProfile::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& LeaderboardProfile::carid() const {
  return *carid_;
}
inline void LeaderboardProfile::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void LeaderboardProfile::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void LeaderboardProfile::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderboardProfile::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* LeaderboardProfile::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 carColorIndex = 8;
inline bool LeaderboardProfile::has_carcolorindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LeaderboardProfile::set_has_carcolorindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LeaderboardProfile::clear_has_carcolorindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LeaderboardProfile::clear_carcolorindex() {
  carcolorindex_ = 0;
  clear_has_carcolorindex();
}
inline ::google::protobuf::int32 LeaderboardProfile::carcolorindex() const {
  return carcolorindex_;
}
inline void LeaderboardProfile::set_carcolorindex(::google::protobuf::int32 value) {
  set_has_carcolorindex();
  carcolorindex_ = value;
}

// repeated int32 carModType = 9;
inline int LeaderboardProfile::carmodtype_size() const {
  return carmodtype_.size();
}
inline void LeaderboardProfile::clear_carmodtype() {
  carmodtype_.Clear();
}
inline ::google::protobuf::int32 LeaderboardProfile::carmodtype(int index) const {
  return carmodtype_.Get(index);
}
inline void LeaderboardProfile::set_carmodtype(int index, ::google::protobuf::int32 value) {
  carmodtype_.Set(index, value);
}
inline void LeaderboardProfile::add_carmodtype(::google::protobuf::int32 value) {
  carmodtype_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LeaderboardProfile::carmodtype() const {
  return carmodtype_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LeaderboardProfile::mutable_carmodtype() {
  return &carmodtype_;
}

// repeated float carModValue = 10;
inline int LeaderboardProfile::carmodvalue_size() const {
  return carmodvalue_.size();
}
inline void LeaderboardProfile::clear_carmodvalue() {
  carmodvalue_.Clear();
}
inline float LeaderboardProfile::carmodvalue(int index) const {
  return carmodvalue_.Get(index);
}
inline void LeaderboardProfile::set_carmodvalue(int index, float value) {
  carmodvalue_.Set(index, value);
}
inline void LeaderboardProfile::add_carmodvalue(float value) {
  carmodvalue_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
LeaderboardProfile::carmodvalue() const {
  return carmodvalue_;
}
inline ::google::protobuf::RepeatedField< float >*
LeaderboardProfile::mutable_carmodvalue() {
  return &carmodvalue_;
}

// optional int32 carScore = 11;
inline bool LeaderboardProfile::has_carscore() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LeaderboardProfile::set_has_carscore() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LeaderboardProfile::clear_has_carscore() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LeaderboardProfile::clear_carscore() {
  carscore_ = 0;
  clear_has_carscore();
}
inline ::google::protobuf::int32 LeaderboardProfile::carscore() const {
  return carscore_;
}
inline void LeaderboardProfile::set_carscore(::google::protobuf::int32 value) {
  set_has_carscore();
  carscore_ = value;
}

// repeated int32 carModId = 12;
inline int LeaderboardProfile::carmodid_size() const {
  return carmodid_.size();
}
inline void LeaderboardProfile::clear_carmodid() {
  carmodid_.Clear();
}
inline ::google::protobuf::int32 LeaderboardProfile::carmodid(int index) const {
  return carmodid_.Get(index);
}
inline void LeaderboardProfile::set_carmodid(int index, ::google::protobuf::int32 value) {
  carmodid_.Set(index, value);
}
inline void LeaderboardProfile::add_carmodid(::google::protobuf::int32 value) {
  carmodid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LeaderboardProfile::carmodid() const {
  return carmodid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LeaderboardProfile::mutable_carmodid() {
  return &carmodid_;
}

// repeated int32 carModLevel = 13;
inline int LeaderboardProfile::carmodlevel_size() const {
  return carmodlevel_.size();
}
inline void LeaderboardProfile::clear_carmodlevel() {
  carmodlevel_.Clear();
}
inline ::google::protobuf::int32 LeaderboardProfile::carmodlevel(int index) const {
  return carmodlevel_.Get(index);
}
inline void LeaderboardProfile::set_carmodlevel(int index, ::google::protobuf::int32 value) {
  carmodlevel_.Set(index, value);
}
inline void LeaderboardProfile::add_carmodlevel(::google::protobuf::int32 value) {
  carmodlevel_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
LeaderboardProfile::carmodlevel() const {
  return carmodlevel_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
LeaderboardProfile::mutable_carmodlevel() {
  return &carmodlevel_;
}

// optional int64 userid = 14;
inline bool LeaderboardProfile::has_userid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LeaderboardProfile::set_has_userid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LeaderboardProfile::clear_has_userid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LeaderboardProfile::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 LeaderboardProfile::userid() const {
  return userid_;
}
inline void LeaderboardProfile::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// ModeInfo

// required int32 modeId = 1;
inline bool ModeInfo::has_modeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModeInfo::set_has_modeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModeInfo::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModeInfo::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 ModeInfo::modeid() const {
  return modeid_;
}
inline void ModeInfo::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// required string modeName = 2;
inline bool ModeInfo::has_modename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModeInfo::set_has_modename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModeInfo::clear_has_modename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModeInfo::clear_modename() {
  if (modename_ != &::google::protobuf::internal::kEmptyString) {
    modename_->clear();
  }
  clear_has_modename();
}
inline const ::std::string& ModeInfo::modename() const {
  return *modename_;
}
inline void ModeInfo::set_modename(const ::std::string& value) {
  set_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    modename_ = new ::std::string;
  }
  modename_->assign(value);
}
inline void ModeInfo::set_modename(const char* value) {
  set_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    modename_ = new ::std::string;
  }
  modename_->assign(value);
}
inline void ModeInfo::set_modename(const char* value, size_t size) {
  set_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    modename_ = new ::std::string;
  }
  modename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModeInfo::mutable_modename() {
  set_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    modename_ = new ::std::string;
  }
  return modename_;
}
inline ::std::string* ModeInfo::release_modename() {
  clear_has_modename();
  if (modename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modename_;
    modename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 modeType = 3;
inline bool ModeInfo::has_modetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModeInfo::set_has_modetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModeInfo::clear_has_modetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModeInfo::clear_modetype() {
  modetype_ = 0;
  clear_has_modetype();
}
inline ::google::protobuf::int32 ModeInfo::modetype() const {
  return modetype_;
}
inline void ModeInfo::set_modetype(::google::protobuf::int32 value) {
  set_has_modetype();
  modetype_ = value;
}

// required int32 finishRatio = 4;
inline bool ModeInfo::has_finishratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ModeInfo::set_has_finishratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ModeInfo::clear_has_finishratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ModeInfo::clear_finishratio() {
  finishratio_ = 0;
  clear_has_finishratio();
}
inline ::google::protobuf::int32 ModeInfo::finishratio() const {
  return finishratio_;
}
inline void ModeInfo::set_finishratio(::google::protobuf::int32 value) {
  set_has_finishratio();
  finishratio_ = value;
}

// required int32 mostwantedNum = 5;
inline bool ModeInfo::has_mostwantednum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ModeInfo::set_has_mostwantednum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ModeInfo::clear_has_mostwantednum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ModeInfo::clear_mostwantednum() {
  mostwantednum_ = 0;
  clear_has_mostwantednum();
}
inline ::google::protobuf::int32 ModeInfo::mostwantednum() const {
  return mostwantednum_;
}
inline void ModeInfo::set_mostwantednum(::google::protobuf::int32 value) {
  set_has_mostwantednum();
  mostwantednum_ = value;
}

// required bool isNew = 6;
inline bool ModeInfo::has_isnew() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ModeInfo::set_has_isnew() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ModeInfo::clear_has_isnew() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ModeInfo::clear_isnew() {
  isnew_ = false;
  clear_has_isnew();
}
inline bool ModeInfo::isnew() const {
  return isnew_;
}
inline void ModeInfo::set_isnew(bool value) {
  set_has_isnew();
  isnew_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard leaderboard = 7;
inline int ModeInfo::leaderboard_size() const {
  return leaderboard_.size();
}
inline void ModeInfo::clear_leaderboard() {
  leaderboard_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& ModeInfo::leaderboard(int index) const {
  return leaderboard_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ModeInfo::mutable_leaderboard(int index) {
  return leaderboard_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ModeInfo::add_leaderboard() {
  return leaderboard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
ModeInfo::leaderboard() const {
  return leaderboard_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
ModeInfo::mutable_leaderboard() {
  return &leaderboard_;
}

// optional int32 realTrackIndex = 8;
inline bool ModeInfo::has_realtrackindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ModeInfo::set_has_realtrackindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ModeInfo::clear_has_realtrackindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ModeInfo::clear_realtrackindex() {
  realtrackindex_ = 0;
  clear_has_realtrackindex();
}
inline ::google::protobuf::int32 ModeInfo::realtrackindex() const {
  return realtrackindex_;
}
inline void ModeInfo::set_realtrackindex(::google::protobuf::int32 value) {
  set_has_realtrackindex();
  realtrackindex_ = value;
}

// optional int32 energyCost = 9;
inline bool ModeInfo::has_energycost() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ModeInfo::set_has_energycost() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ModeInfo::clear_has_energycost() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ModeInfo::clear_energycost() {
  energycost_ = 0;
  clear_has_energycost();
}
inline ::google::protobuf::int32 ModeInfo::energycost() const {
  return energycost_;
}
inline void ModeInfo::set_energycost(::google::protobuf::int32 value) {
  set_has_energycost();
  energycost_ = value;
}

// optional string carLimitDisplayString = 10;
inline bool ModeInfo::has_carlimitdisplaystring() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ModeInfo::set_has_carlimitdisplaystring() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ModeInfo::clear_has_carlimitdisplaystring() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ModeInfo::clear_carlimitdisplaystring() {
  if (carlimitdisplaystring_ != &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_->clear();
  }
  clear_has_carlimitdisplaystring();
}
inline const ::std::string& ModeInfo::carlimitdisplaystring() const {
  return *carlimitdisplaystring_;
}
inline void ModeInfo::set_carlimitdisplaystring(const ::std::string& value) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(value);
}
inline void ModeInfo::set_carlimitdisplaystring(const char* value) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(value);
}
inline void ModeInfo::set_carlimitdisplaystring(const char* value, size_t size) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModeInfo::mutable_carlimitdisplaystring() {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  return carlimitdisplaystring_;
}
inline ::std::string* ModeInfo::release_carlimitdisplaystring() {
  clear_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carlimitdisplaystring_;
    carlimitdisplaystring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .com.ea.eamobile.nfsmw.protoc.LeaderboardProfile leaderboard2 = 11;
inline int ModeInfo::leaderboard2_size() const {
  return leaderboard2_.size();
}
inline void ModeInfo::clear_leaderboard2() {
  leaderboard2_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile& ModeInfo::leaderboard2(int index) const {
  return leaderboard2_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile* ModeInfo::mutable_leaderboard2(int index) {
  return leaderboard2_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile* ModeInfo::add_leaderboard2() {
  return leaderboard2_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile >&
ModeInfo::leaderboard2() const {
  return leaderboard2_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile >*
ModeInfo::mutable_leaderboard2() {
  return &leaderboard2_;
}

// -------------------------------------------------------------------

// TrackInfo

// required string trackId = 1;
inline bool TrackInfo::has_trackid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrackInfo::set_has_trackid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrackInfo::clear_has_trackid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrackInfo::clear_trackid() {
  if (trackid_ != &::google::protobuf::internal::kEmptyString) {
    trackid_->clear();
  }
  clear_has_trackid();
}
inline const ::std::string& TrackInfo::trackid() const {
  return *trackid_;
}
inline void TrackInfo::set_trackid(const ::std::string& value) {
  set_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    trackid_ = new ::std::string;
  }
  trackid_->assign(value);
}
inline void TrackInfo::set_trackid(const char* value) {
  set_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    trackid_ = new ::std::string;
  }
  trackid_->assign(value);
}
inline void TrackInfo::set_trackid(const char* value, size_t size) {
  set_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    trackid_ = new ::std::string;
  }
  trackid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackInfo::mutable_trackid() {
  set_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    trackid_ = new ::std::string;
  }
  return trackid_;
}
inline ::std::string* TrackInfo::release_trackid() {
  clear_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trackid_;
    trackid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 finishRatio = 2;
inline bool TrackInfo::has_finishratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackInfo::set_has_finishratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackInfo::clear_has_finishratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackInfo::clear_finishratio() {
  finishratio_ = 0;
  clear_has_finishratio();
}
inline ::google::protobuf::int32 TrackInfo::finishratio() const {
  return finishratio_;
}
inline void TrackInfo::set_finishratio(::google::protobuf::int32 value) {
  set_has_finishratio();
  finishratio_ = value;
}

// repeated int32 carTypes = 3;
inline int TrackInfo::cartypes_size() const {
  return cartypes_.size();
}
inline void TrackInfo::clear_cartypes() {
  cartypes_.Clear();
}
inline ::google::protobuf::int32 TrackInfo::cartypes(int index) const {
  return cartypes_.Get(index);
}
inline void TrackInfo::set_cartypes(int index, ::google::protobuf::int32 value) {
  cartypes_.Set(index, value);
}
inline void TrackInfo::add_cartypes(::google::protobuf::int32 value) {
  cartypes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TrackInfo::cartypes() const {
  return cartypes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TrackInfo::mutable_cartypes() {
  return &cartypes_;
}

// required int32 difficulty = 4;
inline bool TrackInfo::has_difficulty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackInfo::set_has_difficulty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackInfo::clear_has_difficulty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackInfo::clear_difficulty() {
  difficulty_ = 0;
  clear_has_difficulty();
}
inline ::google::protobuf::int32 TrackInfo::difficulty() const {
  return difficulty_;
}
inline void TrackInfo::set_difficulty(::google::protobuf::int32 value) {
  set_has_difficulty();
  difficulty_ = value;
}

// required bool unlock = 5;
inline bool TrackInfo::has_unlock() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrackInfo::set_has_unlock() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrackInfo::clear_has_unlock() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrackInfo::clear_unlock() {
  unlock_ = false;
  clear_has_unlock();
}
inline bool TrackInfo::unlock() const {
  return unlock_;
}
inline void TrackInfo::set_unlock(bool value) {
  set_has_unlock();
  unlock_ = value;
}

// optional int32 userMostwantedNum = 6;
inline bool TrackInfo::has_usermostwantednum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrackInfo::set_has_usermostwantednum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrackInfo::clear_has_usermostwantednum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrackInfo::clear_usermostwantednum() {
  usermostwantednum_ = 0;
  clear_has_usermostwantednum();
}
inline ::google::protobuf::int32 TrackInfo::usermostwantednum() const {
  return usermostwantednum_;
}
inline void TrackInfo::set_usermostwantednum(::google::protobuf::int32 value) {
  set_has_usermostwantednum();
  usermostwantednum_ = value;
}

// optional bool isNew = 7;
inline bool TrackInfo::has_isnew() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrackInfo::set_has_isnew() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrackInfo::clear_has_isnew() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrackInfo::clear_isnew() {
  isnew_ = false;
  clear_has_isnew();
}
inline bool TrackInfo::isnew() const {
  return isnew_;
}
inline void TrackInfo::set_isnew(bool value) {
  set_has_isnew();
  isnew_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.ModeInfo modes = 8;
inline int TrackInfo::modes_size() const {
  return modes_.size();
}
inline void TrackInfo::clear_modes() {
  modes_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ModeInfo& TrackInfo::modes(int index) const {
  return modes_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ModeInfo* TrackInfo::mutable_modes(int index) {
  return modes_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ModeInfo* TrackInfo::add_modes() {
  return modes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ModeInfo >&
TrackInfo::modes() const {
  return modes_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ModeInfo >*
TrackInfo::mutable_modes() {
  return &modes_;
}

// required string trackName = 9;
inline bool TrackInfo::has_trackname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrackInfo::set_has_trackname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrackInfo::clear_has_trackname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrackInfo::clear_trackname() {
  if (trackname_ != &::google::protobuf::internal::kEmptyString) {
    trackname_->clear();
  }
  clear_has_trackname();
}
inline const ::std::string& TrackInfo::trackname() const {
  return *trackname_;
}
inline void TrackInfo::set_trackname(const ::std::string& value) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(value);
}
inline void TrackInfo::set_trackname(const char* value) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(value);
}
inline void TrackInfo::set_trackname(const char* value, size_t size) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackInfo::mutable_trackname() {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  return trackname_;
}
inline ::std::string* TrackInfo::release_trackname() {
  clear_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trackname_;
    trackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string carTypeForDisplay = 10;
inline bool TrackInfo::has_cartypefordisplay() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrackInfo::set_has_cartypefordisplay() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrackInfo::clear_has_cartypefordisplay() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrackInfo::clear_cartypefordisplay() {
  if (cartypefordisplay_ != &::google::protobuf::internal::kEmptyString) {
    cartypefordisplay_->clear();
  }
  clear_has_cartypefordisplay();
}
inline const ::std::string& TrackInfo::cartypefordisplay() const {
  return *cartypefordisplay_;
}
inline void TrackInfo::set_cartypefordisplay(const ::std::string& value) {
  set_has_cartypefordisplay();
  if (cartypefordisplay_ == &::google::protobuf::internal::kEmptyString) {
    cartypefordisplay_ = new ::std::string;
  }
  cartypefordisplay_->assign(value);
}
inline void TrackInfo::set_cartypefordisplay(const char* value) {
  set_has_cartypefordisplay();
  if (cartypefordisplay_ == &::google::protobuf::internal::kEmptyString) {
    cartypefordisplay_ = new ::std::string;
  }
  cartypefordisplay_->assign(value);
}
inline void TrackInfo::set_cartypefordisplay(const char* value, size_t size) {
  set_has_cartypefordisplay();
  if (cartypefordisplay_ == &::google::protobuf::internal::kEmptyString) {
    cartypefordisplay_ = new ::std::string;
  }
  cartypefordisplay_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackInfo::mutable_cartypefordisplay() {
  set_has_cartypefordisplay();
  if (cartypefordisplay_ == &::google::protobuf::internal::kEmptyString) {
    cartypefordisplay_ = new ::std::string;
  }
  return cartypefordisplay_;
}
inline ::std::string* TrackInfo::release_cartypefordisplay() {
  clear_has_cartypefordisplay();
  if (cartypefordisplay_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cartypefordisplay_;
    cartypefordisplay_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool trackStatusUpdated = 11;
inline bool TrackInfo::has_trackstatusupdated() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TrackInfo::set_has_trackstatusupdated() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TrackInfo::clear_has_trackstatusupdated() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TrackInfo::clear_trackstatusupdated() {
  trackstatusupdated_ = false;
  clear_has_trackstatusupdated();
}
inline bool TrackInfo::trackstatusupdated() const {
  return trackstatusupdated_;
}
inline void TrackInfo::set_trackstatusupdated(bool value) {
  set_has_trackstatusupdated();
  trackstatusupdated_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.Reward reward = 12;
inline bool TrackInfo::has_reward() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TrackInfo::set_has_reward() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TrackInfo::clear_has_reward() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TrackInfo::clear_reward() {
  if (reward_ != NULL) reward_->::com::ea::eamobile::nfsmw::protoc::Reward::Clear();
  clear_has_reward();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Reward& TrackInfo::reward() const {
  return reward_ != NULL ? *reward_ : *default_instance_->reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* TrackInfo::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) reward_ = new ::com::ea::eamobile::nfsmw::protoc::Reward;
  return reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* TrackInfo::release_reward() {
  clear_has_reward();
  ::com::ea::eamobile::nfsmw::protoc::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}

// optional bool isHasNewMode = 13;
inline bool TrackInfo::has_ishasnewmode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TrackInfo::set_has_ishasnewmode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TrackInfo::clear_has_ishasnewmode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TrackInfo::clear_ishasnewmode() {
  ishasnewmode_ = false;
  clear_has_ishasnewmode();
}
inline bool TrackInfo::ishasnewmode() const {
  return ishasnewmode_;
}
inline void TrackInfo::set_ishasnewmode(bool value) {
  set_has_ishasnewmode();
  ishasnewmode_ = value;
}

// -------------------------------------------------------------------

// CheckPointInfo

// required int32 modeId = 1;
inline bool CheckPointInfo::has_modeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckPointInfo::set_has_modeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckPointInfo::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckPointInfo::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 CheckPointInfo::modeid() const {
  return modeid_;
}
inline void CheckPointInfo::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// required int32 status = 2;
inline bool CheckPointInfo::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckPointInfo::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckPointInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckPointInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 CheckPointInfo::status() const {
  return status_;
}
inline void CheckPointInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required int32 unlockMostwantedNum = 3;
inline bool CheckPointInfo::has_unlockmostwantednum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckPointInfo::set_has_unlockmostwantednum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckPointInfo::clear_has_unlockmostwantednum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckPointInfo::clear_unlockmostwantednum() {
  unlockmostwantednum_ = 0;
  clear_has_unlockmostwantednum();
}
inline ::google::protobuf::int32 CheckPointInfo::unlockmostwantednum() const {
  return unlockmostwantednum_;
}
inline void CheckPointInfo::set_unlockmostwantednum(::google::protobuf::int32 value) {
  set_has_unlockmostwantednum();
  unlockmostwantednum_ = value;
}

// required string eventName = 4;
inline bool CheckPointInfo::has_eventname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckPointInfo::set_has_eventname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckPointInfo::clear_has_eventname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckPointInfo::clear_eventname() {
  if (eventname_ != &::google::protobuf::internal::kEmptyString) {
    eventname_->clear();
  }
  clear_has_eventname();
}
inline const ::std::string& CheckPointInfo::eventname() const {
  return *eventname_;
}
inline void CheckPointInfo::set_eventname(const ::std::string& value) {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  eventname_->assign(value);
}
inline void CheckPointInfo::set_eventname(const char* value) {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  eventname_->assign(value);
}
inline void CheckPointInfo::set_eventname(const char* value, size_t size) {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  eventname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckPointInfo::mutable_eventname() {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  return eventname_;
}
inline ::std::string* CheckPointInfo::release_eventname() {
  clear_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventname_;
    eventname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string acceptableCarIDs = 5;
inline int CheckPointInfo::acceptablecarids_size() const {
  return acceptablecarids_.size();
}
inline void CheckPointInfo::clear_acceptablecarids() {
  acceptablecarids_.Clear();
}
inline const ::std::string& CheckPointInfo::acceptablecarids(int index) const {
  return acceptablecarids_.Get(index);
}
inline ::std::string* CheckPointInfo::mutable_acceptablecarids(int index) {
  return acceptablecarids_.Mutable(index);
}
inline void CheckPointInfo::set_acceptablecarids(int index, const ::std::string& value) {
  acceptablecarids_.Mutable(index)->assign(value);
}
inline void CheckPointInfo::set_acceptablecarids(int index, const char* value) {
  acceptablecarids_.Mutable(index)->assign(value);
}
inline void CheckPointInfo::set_acceptablecarids(int index, const char* value, size_t size) {
  acceptablecarids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckPointInfo::add_acceptablecarids() {
  return acceptablecarids_.Add();
}
inline void CheckPointInfo::add_acceptablecarids(const ::std::string& value) {
  acceptablecarids_.Add()->assign(value);
}
inline void CheckPointInfo::add_acceptablecarids(const char* value) {
  acceptablecarids_.Add()->assign(value);
}
inline void CheckPointInfo::add_acceptablecarids(const char* value, size_t size) {
  acceptablecarids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CheckPointInfo::acceptablecarids() const {
  return acceptablecarids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CheckPointInfo::mutable_acceptablecarids() {
  return &acceptablecarids_;
}

// required string carLimitDisplayString = 6;
inline bool CheckPointInfo::has_carlimitdisplaystring() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CheckPointInfo::set_has_carlimitdisplaystring() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CheckPointInfo::clear_has_carlimitdisplaystring() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CheckPointInfo::clear_carlimitdisplaystring() {
  if (carlimitdisplaystring_ != &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_->clear();
  }
  clear_has_carlimitdisplaystring();
}
inline const ::std::string& CheckPointInfo::carlimitdisplaystring() const {
  return *carlimitdisplaystring_;
}
inline void CheckPointInfo::set_carlimitdisplaystring(const ::std::string& value) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(value);
}
inline void CheckPointInfo::set_carlimitdisplaystring(const char* value) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(value);
}
inline void CheckPointInfo::set_carlimitdisplaystring(const char* value, size_t size) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckPointInfo::mutable_carlimitdisplaystring() {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  return carlimitdisplaystring_;
}
inline ::std::string* CheckPointInfo::release_carlimitdisplaystring() {
  clear_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carlimitdisplaystring_;
    carlimitdisplaystring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 staminaCost = 7;
inline bool CheckPointInfo::has_staminacost() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CheckPointInfo::set_has_staminacost() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CheckPointInfo::clear_has_staminacost() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CheckPointInfo::clear_staminacost() {
  staminacost_ = 0;
  clear_has_staminacost();
}
inline ::google::protobuf::int32 CheckPointInfo::staminacost() const {
  return staminacost_;
}
inline void CheckPointInfo::set_staminacost(::google::protobuf::int32 value) {
  set_has_staminacost();
  staminacost_ = value;
}

// required .com.ea.eamobile.nfsmw.protoc.Reward reward = 8;
inline bool CheckPointInfo::has_reward() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CheckPointInfo::set_has_reward() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CheckPointInfo::clear_has_reward() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CheckPointInfo::clear_reward() {
  if (reward_ != NULL) reward_->::com::ea::eamobile::nfsmw::protoc::Reward::Clear();
  clear_has_reward();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Reward& CheckPointInfo::reward() const {
  return reward_ != NULL ? *reward_ : *default_instance_->reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* CheckPointInfo::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) reward_ = new ::com::ea::eamobile::nfsmw::protoc::Reward;
  return reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* CheckPointInfo::release_reward() {
  clear_has_reward();
  ::com::ea::eamobile::nfsmw::protoc::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// NewbieTierCheckList

// required string text = 1;
inline bool NewbieTierCheckList::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewbieTierCheckList::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewbieTierCheckList::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewbieTierCheckList::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& NewbieTierCheckList::text() const {
  return *text_;
}
inline void NewbieTierCheckList::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void NewbieTierCheckList::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void NewbieTierCheckList::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewbieTierCheckList::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* NewbieTierCheckList::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool isFinished = 2;
inline bool NewbieTierCheckList::has_isfinished() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewbieTierCheckList::set_has_isfinished() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewbieTierCheckList::clear_has_isfinished() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewbieTierCheckList::clear_isfinished() {
  isfinished_ = false;
  clear_has_isfinished();
}
inline bool NewbieTierCheckList::isfinished() const {
  return isfinished_;
}
inline void NewbieTierCheckList::set_isfinished(bool value) {
  set_has_isfinished();
  isfinished_ = value;
}

// -------------------------------------------------------------------

// TierInfo

// required int32 tierIndex = 1;
inline bool TierInfo::has_tierindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TierInfo::set_has_tierindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TierInfo::clear_has_tierindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TierInfo::clear_tierindex() {
  tierindex_ = 0;
  clear_has_tierindex();
}
inline ::google::protobuf::int32 TierInfo::tierindex() const {
  return tierindex_;
}
inline void TierInfo::set_tierindex(::google::protobuf::int32 value) {
  set_has_tierindex();
  tierindex_ = value;
}

// required int32 tierAmount = 2;
inline bool TierInfo::has_tieramount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TierInfo::set_has_tieramount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TierInfo::clear_has_tieramount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TierInfo::clear_tieramount() {
  tieramount_ = 0;
  clear_has_tieramount();
}
inline ::google::protobuf::int32 TierInfo::tieramount() const {
  return tieramount_;
}
inline void TierInfo::set_tieramount(::google::protobuf::int32 value) {
  set_has_tieramount();
  tieramount_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.NewbieTierCheckList newbieTierCheckList = 3;
inline int TierInfo::newbietierchecklist_size() const {
  return newbietierchecklist_.size();
}
inline void TierInfo::clear_newbietierchecklist() {
  newbietierchecklist_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList& TierInfo::newbietierchecklist(int index) const {
  return newbietierchecklist_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList* TierInfo::mutable_newbietierchecklist(int index) {
  return newbietierchecklist_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList* TierInfo::add_newbietierchecklist() {
  return newbietierchecklist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList >&
TierInfo::newbietierchecklist() const {
  return newbietierchecklist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::NewbieTierCheckList >*
TierInfo::mutable_newbietierchecklist() {
  return &newbietierchecklist_;
}

// -------------------------------------------------------------------

// GPSInfo

// required double latitude = 1;
inline bool GPSInfo::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSInfo::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSInfo::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSInfo::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double GPSInfo::latitude() const {
  return latitude_;
}
inline void GPSInfo::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
}

// required double longitude = 2;
inline bool GPSInfo::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSInfo::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSInfo::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSInfo::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double GPSInfo::longitude() const {
  return longitude_;
}
inline void GPSInfo::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
}

// required string country = 3;
inline bool GPSInfo::has_country() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPSInfo::set_has_country() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPSInfo::clear_has_country() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPSInfo::clear_country() {
  if (country_ != &::google::protobuf::internal::kEmptyString) {
    country_->clear();
  }
  clear_has_country();
}
inline const ::std::string& GPSInfo::country() const {
  return *country_;
}
inline void GPSInfo::set_country(const ::std::string& value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void GPSInfo::set_country(const char* value) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(value);
}
inline void GPSInfo::set_country(const char* value, size_t size) {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  country_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSInfo::mutable_country() {
  set_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    country_ = new ::std::string;
  }
  return country_;
}
inline ::std::string* GPSInfo::release_country() {
  clear_has_country();
  if (country_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_;
    country_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string locality = 4;
inline bool GPSInfo::has_locality() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPSInfo::set_has_locality() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPSInfo::clear_has_locality() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPSInfo::clear_locality() {
  if (locality_ != &::google::protobuf::internal::kEmptyString) {
    locality_->clear();
  }
  clear_has_locality();
}
inline const ::std::string& GPSInfo::locality() const {
  return *locality_;
}
inline void GPSInfo::set_locality(const ::std::string& value) {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  locality_->assign(value);
}
inline void GPSInfo::set_locality(const char* value) {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  locality_->assign(value);
}
inline void GPSInfo::set_locality(const char* value, size_t size) {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  locality_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSInfo::mutable_locality() {
  set_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    locality_ = new ::std::string;
  }
  return locality_;
}
inline ::std::string* GPSInfo::release_locality() {
  clear_has_locality();
  if (locality_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locality_;
    locality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string subLocality = 5;
inline bool GPSInfo::has_sublocality() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPSInfo::set_has_sublocality() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPSInfo::clear_has_sublocality() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPSInfo::clear_sublocality() {
  if (sublocality_ != &::google::protobuf::internal::kEmptyString) {
    sublocality_->clear();
  }
  clear_has_sublocality();
}
inline const ::std::string& GPSInfo::sublocality() const {
  return *sublocality_;
}
inline void GPSInfo::set_sublocality(const ::std::string& value) {
  set_has_sublocality();
  if (sublocality_ == &::google::protobuf::internal::kEmptyString) {
    sublocality_ = new ::std::string;
  }
  sublocality_->assign(value);
}
inline void GPSInfo::set_sublocality(const char* value) {
  set_has_sublocality();
  if (sublocality_ == &::google::protobuf::internal::kEmptyString) {
    sublocality_ = new ::std::string;
  }
  sublocality_->assign(value);
}
inline void GPSInfo::set_sublocality(const char* value, size_t size) {
  set_has_sublocality();
  if (sublocality_ == &::google::protobuf::internal::kEmptyString) {
    sublocality_ = new ::std::string;
  }
  sublocality_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSInfo::mutable_sublocality() {
  set_has_sublocality();
  if (sublocality_ == &::google::protobuf::internal::kEmptyString) {
    sublocality_ = new ::std::string;
  }
  return sublocality_;
}
inline ::std::string* GPSInfo::release_sublocality() {
  clear_has_sublocality();
  if (sublocality_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sublocality_;
    sublocality_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string thoroughfare = 6;
inline bool GPSInfo::has_thoroughfare() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPSInfo::set_has_thoroughfare() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPSInfo::clear_has_thoroughfare() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPSInfo::clear_thoroughfare() {
  if (thoroughfare_ != &::google::protobuf::internal::kEmptyString) {
    thoroughfare_->clear();
  }
  clear_has_thoroughfare();
}
inline const ::std::string& GPSInfo::thoroughfare() const {
  return *thoroughfare_;
}
inline void GPSInfo::set_thoroughfare(const ::std::string& value) {
  set_has_thoroughfare();
  if (thoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    thoroughfare_ = new ::std::string;
  }
  thoroughfare_->assign(value);
}
inline void GPSInfo::set_thoroughfare(const char* value) {
  set_has_thoroughfare();
  if (thoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    thoroughfare_ = new ::std::string;
  }
  thoroughfare_->assign(value);
}
inline void GPSInfo::set_thoroughfare(const char* value, size_t size) {
  set_has_thoroughfare();
  if (thoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    thoroughfare_ = new ::std::string;
  }
  thoroughfare_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSInfo::mutable_thoroughfare() {
  set_has_thoroughfare();
  if (thoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    thoroughfare_ = new ::std::string;
  }
  return thoroughfare_;
}
inline ::std::string* GPSInfo::release_thoroughfare() {
  clear_has_thoroughfare();
  if (thoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thoroughfare_;
    thoroughfare_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string subThoroughfare = 7;
inline bool GPSInfo::has_subthoroughfare() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GPSInfo::set_has_subthoroughfare() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GPSInfo::clear_has_subthoroughfare() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GPSInfo::clear_subthoroughfare() {
  if (subthoroughfare_ != &::google::protobuf::internal::kEmptyString) {
    subthoroughfare_->clear();
  }
  clear_has_subthoroughfare();
}
inline const ::std::string& GPSInfo::subthoroughfare() const {
  return *subthoroughfare_;
}
inline void GPSInfo::set_subthoroughfare(const ::std::string& value) {
  set_has_subthoroughfare();
  if (subthoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    subthoroughfare_ = new ::std::string;
  }
  subthoroughfare_->assign(value);
}
inline void GPSInfo::set_subthoroughfare(const char* value) {
  set_has_subthoroughfare();
  if (subthoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    subthoroughfare_ = new ::std::string;
  }
  subthoroughfare_->assign(value);
}
inline void GPSInfo::set_subthoroughfare(const char* value, size_t size) {
  set_has_subthoroughfare();
  if (subthoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    subthoroughfare_ = new ::std::string;
  }
  subthoroughfare_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GPSInfo::mutable_subthoroughfare() {
  set_has_subthoroughfare();
  if (subthoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    subthoroughfare_ = new ::std::string;
  }
  return subthoroughfare_;
}
inline ::std::string* GPSInfo::release_subthoroughfare() {
  clear_has_subthoroughfare();
  if (subthoroughfare_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subthoroughfare_;
    subthoroughfare_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestResourceCommand

// required int32 clientVersion = 1;
inline bool RequestResourceCommand::has_clientversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestResourceCommand::set_has_clientversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestResourceCommand::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestResourceCommand::clear_clientversion() {
  clientversion_ = 0;
  clear_has_clientversion();
}
inline ::google::protobuf::int32 RequestResourceCommand::clientversion() const {
  return clientversion_;
}
inline void RequestResourceCommand::set_clientversion(::google::protobuf::int32 value) {
  set_has_clientversion();
  clientversion_ = value;
}

// -------------------------------------------------------------------

// ResourceItemInfo

// required string path = 1;
inline bool ResourceItemInfo::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceItemInfo::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceItemInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceItemInfo::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& ResourceItemInfo::path() const {
  return *path_;
}
inline void ResourceItemInfo::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void ResourceItemInfo::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void ResourceItemInfo::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceItemInfo::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* ResourceItemInfo::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 size = 2;
inline bool ResourceItemInfo::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceItemInfo::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceItemInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceItemInfo::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 ResourceItemInfo::size() const {
  return size_;
}
inline void ResourceItemInfo::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
}

// required string md5 = 3;
inline bool ResourceItemInfo::has_md5() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceItemInfo::set_has_md5() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceItemInfo::clear_has_md5() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceItemInfo::clear_md5() {
  if (md5_ != &::google::protobuf::internal::kEmptyString) {
    md5_->clear();
  }
  clear_has_md5();
}
inline const ::std::string& ResourceItemInfo::md5() const {
  return *md5_;
}
inline void ResourceItemInfo::set_md5(const ::std::string& value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void ResourceItemInfo::set_md5(const char* value) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(value);
}
inline void ResourceItemInfo::set_md5(const char* value, size_t size) {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  md5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceItemInfo::mutable_md5() {
  set_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    md5_ = new ::std::string;
  }
  return md5_;
}
inline ::std::string* ResourceItemInfo::release_md5() {
  clear_has_md5();
  if (md5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md5_;
    md5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 action = 4;
inline bool ResourceItemInfo::has_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceItemInfo::set_has_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceItemInfo::clear_has_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceItemInfo::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::google::protobuf::int32 ResourceItemInfo::action() const {
  return action_;
}
inline void ResourceItemInfo::set_action(::google::protobuf::int32 value) {
  set_has_action();
  action_ = value;
}

// optional int32 version = 5;
inline bool ResourceItemInfo::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResourceItemInfo::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResourceItemInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResourceItemInfo::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 ResourceItemInfo::version() const {
  return version_;
}
inline void ResourceItemInfo::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// ResponseResourceCommand

// required string rootPath = 1;
inline bool ResponseResourceCommand::has_rootpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseResourceCommand::set_has_rootpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseResourceCommand::clear_has_rootpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseResourceCommand::clear_rootpath() {
  if (rootpath_ != &::google::protobuf::internal::kEmptyString) {
    rootpath_->clear();
  }
  clear_has_rootpath();
}
inline const ::std::string& ResponseResourceCommand::rootpath() const {
  return *rootpath_;
}
inline void ResponseResourceCommand::set_rootpath(const ::std::string& value) {
  set_has_rootpath();
  if (rootpath_ == &::google::protobuf::internal::kEmptyString) {
    rootpath_ = new ::std::string;
  }
  rootpath_->assign(value);
}
inline void ResponseResourceCommand::set_rootpath(const char* value) {
  set_has_rootpath();
  if (rootpath_ == &::google::protobuf::internal::kEmptyString) {
    rootpath_ = new ::std::string;
  }
  rootpath_->assign(value);
}
inline void ResponseResourceCommand::set_rootpath(const char* value, size_t size) {
  set_has_rootpath();
  if (rootpath_ == &::google::protobuf::internal::kEmptyString) {
    rootpath_ = new ::std::string;
  }
  rootpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseResourceCommand::mutable_rootpath() {
  set_has_rootpath();
  if (rootpath_ == &::google::protobuf::internal::kEmptyString) {
    rootpath_ = new ::std::string;
  }
  return rootpath_;
}
inline ::std::string* ResponseResourceCommand::release_rootpath() {
  clear_has_rootpath();
  if (rootpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rootpath_;
    rootpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 version = 2;
inline bool ResponseResourceCommand::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseResourceCommand::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseResourceCommand::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseResourceCommand::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 ResponseResourceCommand::version() const {
  return version_;
}
inline void ResponseResourceCommand::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.ResourceItemInfo items = 3;
inline int ResponseResourceCommand::items_size() const {
  return items_.size();
}
inline void ResponseResourceCommand::clear_items() {
  items_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo& ResponseResourceCommand::items(int index) const {
  return items_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo* ResponseResourceCommand::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo* ResponseResourceCommand::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo >&
ResponseResourceCommand::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResourceItemInfo >*
ResponseResourceCommand::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// RequestTrackCommand

// required int32 requestTier = 2;
inline bool RequestTrackCommand::has_requesttier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestTrackCommand::set_has_requesttier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestTrackCommand::clear_has_requesttier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestTrackCommand::clear_requesttier() {
  requesttier_ = 0;
  clear_has_requesttier();
}
inline ::google::protobuf::int32 RequestTrackCommand::requesttier() const {
  return requesttier_;
}
inline void RequestTrackCommand::set_requesttier(::google::protobuf::int32 value) {
  set_has_requesttier();
  requesttier_ = value;
}

// -------------------------------------------------------------------

// ResponseTrackCommand

// optional .com.ea.eamobile.nfsmw.protoc.TierInfo tier = 1;
inline bool ResponseTrackCommand::has_tier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseTrackCommand::set_has_tier() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseTrackCommand::clear_has_tier() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseTrackCommand::clear_tier() {
  if (tier_ != NULL) tier_->::com::ea::eamobile::nfsmw::protoc::TierInfo::Clear();
  clear_has_tier();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TierInfo& ResponseTrackCommand::tier() const {
  return tier_ != NULL ? *tier_ : *default_instance_->tier_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TierInfo* ResponseTrackCommand::mutable_tier() {
  set_has_tier();
  if (tier_ == NULL) tier_ = new ::com::ea::eamobile::nfsmw::protoc::TierInfo;
  return tier_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TierInfo* ResponseTrackCommand::release_tier() {
  clear_has_tier();
  ::com::ea::eamobile::nfsmw::protoc::TierInfo* temp = tier_;
  tier_ = NULL;
  return temp;
}

// repeated .com.ea.eamobile.nfsmw.protoc.TrackInfo tracks = 2;
inline int ResponseTrackCommand::tracks_size() const {
  return tracks_.size();
}
inline void ResponseTrackCommand::clear_tracks() {
  tracks_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TrackInfo& ResponseTrackCommand::tracks(int index) const {
  return tracks_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TrackInfo* ResponseTrackCommand::mutable_tracks(int index) {
  return tracks_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TrackInfo* ResponseTrackCommand::add_tracks() {
  return tracks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TrackInfo >&
ResponseTrackCommand::tracks() const {
  return tracks_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TrackInfo >*
ResponseTrackCommand::mutable_tracks() {
  return &tracks_;
}

// optional .com.ea.eamobile.nfsmw.protoc.CheckPointInfo checkPointInfo = 3;
inline bool ResponseTrackCommand::has_checkpointinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseTrackCommand::set_has_checkpointinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseTrackCommand::clear_has_checkpointinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseTrackCommand::clear_checkpointinfo() {
  if (checkpointinfo_ != NULL) checkpointinfo_->::com::ea::eamobile::nfsmw::protoc::CheckPointInfo::Clear();
  clear_has_checkpointinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo& ResponseTrackCommand::checkpointinfo() const {
  return checkpointinfo_ != NULL ? *checkpointinfo_ : *default_instance_->checkpointinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* ResponseTrackCommand::mutable_checkpointinfo() {
  set_has_checkpointinfo();
  if (checkpointinfo_ == NULL) checkpointinfo_ = new ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo;
  return checkpointinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* ResponseTrackCommand::release_checkpointinfo() {
  clear_has_checkpointinfo();
  ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* temp = checkpointinfo_;
  checkpointinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RequestUserInfoCommand

// required string mac = 1;
inline bool RequestUserInfoCommand::has_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUserInfoCommand::set_has_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUserInfoCommand::clear_has_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUserInfoCommand::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& RequestUserInfoCommand::mac() const {
  return *mac_;
}
inline void RequestUserInfoCommand::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void RequestUserInfoCommand::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void RequestUserInfoCommand::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUserInfoCommand::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* RequestUserInfoCommand::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string deviceName = 2;
inline bool RequestUserInfoCommand::has_devicename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUserInfoCommand::set_has_devicename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUserInfoCommand::clear_has_devicename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUserInfoCommand::clear_devicename() {
  if (devicename_ != &::google::protobuf::internal::kEmptyString) {
    devicename_->clear();
  }
  clear_has_devicename();
}
inline const ::std::string& RequestUserInfoCommand::devicename() const {
  return *devicename_;
}
inline void RequestUserInfoCommand::set_devicename(const ::std::string& value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void RequestUserInfoCommand::set_devicename(const char* value) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(value);
}
inline void RequestUserInfoCommand::set_devicename(const char* value, size_t size) {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  devicename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUserInfoCommand::mutable_devicename() {
  set_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    devicename_ = new ::std::string;
  }
  return devicename_;
}
inline ::std::string* RequestUserInfoCommand::release_devicename() {
  clear_has_devicename();
  if (devicename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devicename_;
    devicename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string token = 3;
inline bool RequestUserInfoCommand::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestUserInfoCommand::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestUserInfoCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestUserInfoCommand::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& RequestUserInfoCommand::token() const {
  return *token_;
}
inline void RequestUserInfoCommand::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestUserInfoCommand::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestUserInfoCommand::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUserInfoCommand::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* RequestUserInfoCommand::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .com.ea.eamobile.nfsmw.protoc.GPSInfo gpsInfo = 4;
inline bool RequestUserInfoCommand::has_gpsinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestUserInfoCommand::set_has_gpsinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestUserInfoCommand::clear_has_gpsinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestUserInfoCommand::clear_gpsinfo() {
  if (gpsinfo_ != NULL) gpsinfo_->::com::ea::eamobile::nfsmw::protoc::GPSInfo::Clear();
  clear_has_gpsinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::GPSInfo& RequestUserInfoCommand::gpsinfo() const {
  return gpsinfo_ != NULL ? *gpsinfo_ : *default_instance_->gpsinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::GPSInfo* RequestUserInfoCommand::mutable_gpsinfo() {
  set_has_gpsinfo();
  if (gpsinfo_ == NULL) gpsinfo_ = new ::com::ea::eamobile::nfsmw::protoc::GPSInfo;
  return gpsinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::GPSInfo* RequestUserInfoCommand::release_gpsinfo() {
  clear_has_gpsinfo();
  ::com::ea::eamobile::nfsmw::protoc::GPSInfo* temp = gpsinfo_;
  gpsinfo_ = NULL;
  return temp;
}

// optional bool isOld = 5;
inline bool RequestUserInfoCommand::has_isold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestUserInfoCommand::set_has_isold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestUserInfoCommand::clear_has_isold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestUserInfoCommand::clear_isold() {
  isold_ = false;
  clear_has_isold();
}
inline bool RequestUserInfoCommand::isold() const {
  return isold_;
}
inline void RequestUserInfoCommand::set_isold(bool value) {
  set_has_isold();
  isold_ = value;
}

// -------------------------------------------------------------------

// ResponseWeiboShareLocksCommand

// required bool isRaceRewardShareOpen = 1;
inline bool ResponseWeiboShareLocksCommand::has_isracerewardshareopen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseWeiboShareLocksCommand::set_has_isracerewardshareopen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseWeiboShareLocksCommand::clear_has_isracerewardshareopen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseWeiboShareLocksCommand::clear_isracerewardshareopen() {
  isracerewardshareopen_ = false;
  clear_has_isracerewardshareopen();
}
inline bool ResponseWeiboShareLocksCommand::isracerewardshareopen() const {
  return isracerewardshareopen_;
}
inline void ResponseWeiboShareLocksCommand::set_isracerewardshareopen(bool value) {
  set_has_isracerewardshareopen();
  isracerewardshareopen_ = value;
}

// required bool isTrackUnlockInfoShareOpen = 2;
inline bool ResponseWeiboShareLocksCommand::has_istrackunlockinfoshareopen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseWeiboShareLocksCommand::set_has_istrackunlockinfoshareopen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseWeiboShareLocksCommand::clear_has_istrackunlockinfoshareopen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseWeiboShareLocksCommand::clear_istrackunlockinfoshareopen() {
  istrackunlockinfoshareopen_ = false;
  clear_has_istrackunlockinfoshareopen();
}
inline bool ResponseWeiboShareLocksCommand::istrackunlockinfoshareopen() const {
  return istrackunlockinfoshareopen_;
}
inline void ResponseWeiboShareLocksCommand::set_istrackunlockinfoshareopen(bool value) {
  set_has_istrackunlockinfoshareopen();
  istrackunlockinfoshareopen_ = value;
}

// required bool isCarUnlockInfoShareOpen = 3;
inline bool ResponseWeiboShareLocksCommand::has_iscarunlockinfoshareopen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseWeiboShareLocksCommand::set_has_iscarunlockinfoshareopen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseWeiboShareLocksCommand::clear_has_iscarunlockinfoshareopen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseWeiboShareLocksCommand::clear_iscarunlockinfoshareopen() {
  iscarunlockinfoshareopen_ = false;
  clear_has_iscarunlockinfoshareopen();
}
inline bool ResponseWeiboShareLocksCommand::iscarunlockinfoshareopen() const {
  return iscarunlockinfoshareopen_;
}
inline void ResponseWeiboShareLocksCommand::set_iscarunlockinfoshareopen(bool value) {
  set_has_iscarunlockinfoshareopen();
  iscarunlockinfoshareopen_ = value;
}

// required bool isSpeedWallShareOpen = 4;
inline bool ResponseWeiboShareLocksCommand::has_isspeedwallshareopen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseWeiboShareLocksCommand::set_has_isspeedwallshareopen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseWeiboShareLocksCommand::clear_has_isspeedwallshareopen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseWeiboShareLocksCommand::clear_isspeedwallshareopen() {
  isspeedwallshareopen_ = false;
  clear_has_isspeedwallshareopen();
}
inline bool ResponseWeiboShareLocksCommand::isspeedwallshareopen() const {
  return isspeedwallshareopen_;
}
inline void ResponseWeiboShareLocksCommand::set_isspeedwallshareopen(bool value) {
  set_has_isspeedwallshareopen();
  isspeedwallshareopen_ = value;
}

// required bool isBindingWeiboShareOpen = 5;
inline bool ResponseWeiboShareLocksCommand::has_isbindingweiboshareopen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseWeiboShareLocksCommand::set_has_isbindingweiboshareopen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseWeiboShareLocksCommand::clear_has_isbindingweiboshareopen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseWeiboShareLocksCommand::clear_isbindingweiboshareopen() {
  isbindingweiboshareopen_ = false;
  clear_has_isbindingweiboshareopen();
}
inline bool ResponseWeiboShareLocksCommand::isbindingweiboshareopen() const {
  return isbindingweiboshareopen_;
}
inline void ResponseWeiboShareLocksCommand::set_isbindingweiboshareopen(bool value) {
  set_has_isbindingweiboshareopen();
  isbindingweiboshareopen_ = value;
}

// required bool isTournamentRewardShareOpen = 6;
inline bool ResponseWeiboShareLocksCommand::has_istournamentrewardshareopen() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseWeiboShareLocksCommand::set_has_istournamentrewardshareopen() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseWeiboShareLocksCommand::clear_has_istournamentrewardshareopen() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseWeiboShareLocksCommand::clear_istournamentrewardshareopen() {
  istournamentrewardshareopen_ = false;
  clear_has_istournamentrewardshareopen();
}
inline bool ResponseWeiboShareLocksCommand::istournamentrewardshareopen() const {
  return istournamentrewardshareopen_;
}
inline void ResponseWeiboShareLocksCommand::set_istournamentrewardshareopen(bool value) {
  set_has_istournamentrewardshareopen();
  istournamentrewardshareopen_ = value;
}

// required bool isBuyCarShareOpen = 7;
inline bool ResponseWeiboShareLocksCommand::has_isbuycarshareopen() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseWeiboShareLocksCommand::set_has_isbuycarshareopen() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseWeiboShareLocksCommand::clear_has_isbuycarshareopen() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseWeiboShareLocksCommand::clear_isbuycarshareopen() {
  isbuycarshareopen_ = false;
  clear_has_isbuycarshareopen();
}
inline bool ResponseWeiboShareLocksCommand::isbuycarshareopen() const {
  return isbuycarshareopen_;
}
inline void ResponseWeiboShareLocksCommand::set_isbuycarshareopen(bool value) {
  set_has_isbuycarshareopen();
  isbuycarshareopen_ = value;
}

// required bool isUpdateConsumableShareOpen = 8;
inline bool ResponseWeiboShareLocksCommand::has_isupdateconsumableshareopen() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseWeiboShareLocksCommand::set_has_isupdateconsumableshareopen() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseWeiboShareLocksCommand::clear_has_isupdateconsumableshareopen() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseWeiboShareLocksCommand::clear_isupdateconsumableshareopen() {
  isupdateconsumableshareopen_ = false;
  clear_has_isupdateconsumableshareopen();
}
inline bool ResponseWeiboShareLocksCommand::isupdateconsumableshareopen() const {
  return isupdateconsumableshareopen_;
}
inline void ResponseWeiboShareLocksCommand::set_isupdateconsumableshareopen(bool value) {
  set_has_isupdateconsumableshareopen();
  isupdateconsumableshareopen_ = value;
}

// optional bool isJaguarShareOpen = 9;
inline bool ResponseWeiboShareLocksCommand::has_isjaguarshareopen() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseWeiboShareLocksCommand::set_has_isjaguarshareopen() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseWeiboShareLocksCommand::clear_has_isjaguarshareopen() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseWeiboShareLocksCommand::clear_isjaguarshareopen() {
  isjaguarshareopen_ = false;
  clear_has_isjaguarshareopen();
}
inline bool ResponseWeiboShareLocksCommand::isjaguarshareopen() const {
  return isjaguarshareopen_;
}
inline void ResponseWeiboShareLocksCommand::set_isjaguarshareopen(bool value) {
  set_has_isjaguarshareopen();
  isjaguarshareopen_ = value;
}

// -------------------------------------------------------------------

// UserWeiboInfo

// required string access_token = 1;
inline bool UserWeiboInfo::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserWeiboInfo::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserWeiboInfo::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserWeiboInfo::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UserWeiboInfo::access_token() const {
  return *access_token_;
}
inline void UserWeiboInfo::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void UserWeiboInfo::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void UserWeiboInfo::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserWeiboInfo::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  return access_token_;
}
inline ::std::string* UserWeiboInfo::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string uid = 2;
inline bool UserWeiboInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserWeiboInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserWeiboInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserWeiboInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& UserWeiboInfo::uid() const {
  return *uid_;
}
inline void UserWeiboInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void UserWeiboInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void UserWeiboInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserWeiboInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* UserWeiboInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UserInfo

// required string nickname = 1;
inline bool UserInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& UserInfo::nickname() const {
  return *nickname_;
}
inline void UserInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void UserInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void UserInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* UserInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string headUrl = 2;
inline bool UserInfo::has_headurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_headurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& UserInfo::headurl() const {
  return *headurl_;
}
inline void UserInfo::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void UserInfo::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void UserInfo::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* UserInfo::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 headIndex = 3;
inline bool UserInfo::has_headindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_headindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 UserInfo::headindex() const {
  return headindex_;
}
inline void UserInfo::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// required int32 tier = 4;
inline bool UserInfo::has_tier() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_tier() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_tier() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_tier() {
  tier_ = 0;
  clear_has_tier();
}
inline ::google::protobuf::int32 UserInfo::tier() const {
  return tier_;
}
inline void UserInfo::set_tier(::google::protobuf::int32 value) {
  set_has_tier();
  tier_ = value;
}

// required int32 rpLevel = 5;
inline bool UserInfo::has_rplevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_rplevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_rplevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_rplevel() {
  rplevel_ = 0;
  clear_has_rplevel();
}
inline ::google::protobuf::int32 UserInfo::rplevel() const {
  return rplevel_;
}
inline void UserInfo::set_rplevel(::google::protobuf::int32 value) {
  set_has_rplevel();
  rplevel_ = value;
}

// required int32 rpExp = 6;
inline bool UserInfo::has_rpexp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_rpexp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_rpexp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_rpexp() {
  rpexp_ = 0;
  clear_has_rpexp();
}
inline ::google::protobuf::int32 UserInfo::rpexp() const {
  return rpexp_;
}
inline void UserInfo::set_rpexp(::google::protobuf::int32 value) {
  set_has_rpexp();
  rpexp_ = value;
}

// required int32 mostwantedNum = 7;
inline bool UserInfo::has_mostwantednum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_mostwantednum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_mostwantednum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_mostwantednum() {
  mostwantednum_ = 0;
  clear_has_mostwantednum();
}
inline ::google::protobuf::int32 UserInfo::mostwantednum() const {
  return mostwantednum_;
}
inline void UserInfo::set_mostwantednum(::google::protobuf::int32 value) {
  set_has_mostwantednum();
  mostwantednum_ = value;
}

// required int32 currency = 8;
inline bool UserInfo::has_currency() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_currency() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_currency() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_currency() {
  currency_ = 0;
  clear_has_currency();
}
inline ::google::protobuf::int32 UserInfo::currency() const {
  return currency_;
}
inline void UserInfo::set_currency(::google::protobuf::int32 value) {
  set_has_currency();
  currency_ = value;
}

// required int32 rmb = 9;
inline bool UserInfo::has_rmb() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_rmb() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_rmb() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_rmb() {
  rmb_ = 0;
  clear_has_rmb();
}
inline ::google::protobuf::int32 UserInfo::rmb() const {
  return rmb_;
}
inline void UserInfo::set_rmb(::google::protobuf::int32 value) {
  set_has_rmb();
  rmb_ = value;
}

// required int32 energy = 10;
inline bool UserInfo::has_energy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_energy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_energy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline ::google::protobuf::int32 UserInfo::energy() const {
  return energy_;
}
inline void UserInfo::set_energy(::google::protobuf::int32 value) {
  set_has_energy();
  energy_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.AccountInfo accountInfos = 11;
inline int UserInfo::accountinfos_size() const {
  return accountinfos_.size();
}
inline void UserInfo::clear_accountinfos() {
  accountinfos_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::AccountInfo& UserInfo::accountinfos(int index) const {
  return accountinfos_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::AccountInfo* UserInfo::mutable_accountinfos(int index) {
  return accountinfos_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::AccountInfo* UserInfo::add_accountinfos() {
  return accountinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::AccountInfo >&
UserInfo::accountinfos() const {
  return accountinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::AccountInfo >*
UserInfo::mutable_accountinfos() {
  return &accountinfos_;
}

// optional int32 expMax = 12;
inline bool UserInfo::has_expmax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_expmax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_expmax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_expmax() {
  expmax_ = 0;
  clear_has_expmax();
}
inline ::google::protobuf::int32 UserInfo::expmax() const {
  return expmax_;
}
inline void UserInfo::set_expmax(::google::protobuf::int32 value) {
  set_has_expmax();
  expmax_ = value;
}

// optional int32 expMin = 13;
inline bool UserInfo::has_expmin() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserInfo::set_has_expmin() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserInfo::clear_has_expmin() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserInfo::clear_expmin() {
  expmin_ = 0;
  clear_has_expmin();
}
inline ::google::protobuf::int32 UserInfo::expmin() const {
  return expmin_;
}
inline void UserInfo::set_expmin(::google::protobuf::int32 value) {
  set_has_expmin();
  expmin_ = value;
}

// optional bool finishedFirstRace = 14;
inline bool UserInfo::has_finishedfirstrace() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserInfo::set_has_finishedfirstrace() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserInfo::clear_has_finishedfirstrace() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserInfo::clear_finishedfirstrace() {
  finishedfirstrace_ = false;
  clear_has_finishedfirstrace();
}
inline bool UserInfo::finishedfirstrace() const {
  return finishedfirstrace_;
}
inline void UserInfo::set_finishedfirstrace(bool value) {
  set_has_finishedfirstrace();
  finishedfirstrace_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.UserWeiboInfo weiboInfo = 15;
inline bool UserInfo::has_weiboinfo() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserInfo::set_has_weiboinfo() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserInfo::clear_has_weiboinfo() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserInfo::clear_weiboinfo() {
  if (weiboinfo_ != NULL) weiboinfo_->::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo::Clear();
  clear_has_weiboinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo& UserInfo::weiboinfo() const {
  return weiboinfo_ != NULL ? *weiboinfo_ : *default_instance_->weiboinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo* UserInfo::mutable_weiboinfo() {
  set_has_weiboinfo();
  if (weiboinfo_ == NULL) weiboinfo_ = new ::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo;
  return weiboinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo* UserInfo::release_weiboinfo() {
  clear_has_weiboinfo();
  ::com::ea::eamobile::nfsmw::protoc::UserWeiboInfo* temp = weiboinfo_;
  weiboinfo_ = NULL;
  return temp;
}

// optional bool tutorialRewardIsGiven = 16;
inline bool UserInfo::has_tutorialrewardisgiven() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserInfo::set_has_tutorialrewardisgiven() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserInfo::clear_has_tutorialrewardisgiven() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserInfo::clear_tutorialrewardisgiven() {
  tutorialrewardisgiven_ = false;
  clear_has_tutorialrewardisgiven();
}
inline bool UserInfo::tutorialrewardisgiven() const {
  return tutorialrewardisgiven_;
}
inline void UserInfo::set_tutorialrewardisgiven(bool value) {
  set_has_tutorialrewardisgiven();
  tutorialrewardisgiven_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.RPMessage rpMessage = 17;
inline bool UserInfo::has_rpmessage() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserInfo::set_has_rpmessage() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserInfo::clear_has_rpmessage() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserInfo::clear_rpmessage() {
  if (rpmessage_ != NULL) rpmessage_->::com::ea::eamobile::nfsmw::protoc::RPMessage::Clear();
  clear_has_rpmessage();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RPMessage& UserInfo::rpmessage() const {
  return rpmessage_ != NULL ? *rpmessage_ : *default_instance_->rpmessage_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* UserInfo::mutable_rpmessage() {
  set_has_rpmessage();
  if (rpmessage_ == NULL) rpmessage_ = new ::com::ea::eamobile::nfsmw::protoc::RPMessage;
  return rpmessage_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* UserInfo::release_rpmessage() {
  clear_has_rpmessage();
  ::com::ea::eamobile::nfsmw::protoc::RPMessage* temp = rpmessage_;
  rpmessage_ = NULL;
  return temp;
}

// optional bool isNameChanged = 18;
inline bool UserInfo::has_isnamechanged() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UserInfo::set_has_isnamechanged() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UserInfo::clear_has_isnamechanged() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UserInfo::clear_isnamechanged() {
  isnamechanged_ = false;
  clear_has_isnamechanged();
}
inline bool UserInfo::isnamechanged() const {
  return isnamechanged_;
}
inline void UserInfo::set_isnamechanged(bool value) {
  set_has_isnamechanged();
  isnamechanged_ = value;
}

// optional string access_token = 19;
inline bool UserInfo::has_access_token() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UserInfo::set_has_access_token() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UserInfo::clear_has_access_token() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UserInfo::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& UserInfo::access_token() const {
  return *access_token_;
}
inline void UserInfo::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void UserInfo::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void UserInfo::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  return access_token_;
}
inline ::std::string* UserInfo::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uid = 20;
inline bool UserInfo::has_uid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void UserInfo::set_has_uid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void UserInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void UserInfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& UserInfo::uid() const {
  return *uid_;
}
inline void UserInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void UserInfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void UserInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* UserInfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 energytime = 21;
inline bool UserInfo::has_energytime() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void UserInfo::set_has_energytime() {
  _has_bits_[0] |= 0x00100000u;
}
inline void UserInfo::clear_has_energytime() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void UserInfo::clear_energytime() {
  energytime_ = 0;
  clear_has_energytime();
}
inline ::google::protobuf::int32 UserInfo::energytime() const {
  return energytime_;
}
inline void UserInfo::set_energytime(::google::protobuf::int32 value) {
  set_has_energytime();
  energytime_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.Prop propnum = 22;
inline int UserInfo::propnum_size() const {
  return propnum_.size();
}
inline void UserInfo::clear_propnum() {
  propnum_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Prop& UserInfo::propnum(int index) const {
  return propnum_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Prop* UserInfo::mutable_propnum(int index) {
  return propnum_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Prop* UserInfo::add_propnum() {
  return propnum_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop >&
UserInfo::propnum() const {
  return propnum_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop >*
UserInfo::mutable_propnum() {
  return &propnum_;
}

// optional int32 packageStatus = 23;
inline bool UserInfo::has_packagestatus() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void UserInfo::set_has_packagestatus() {
  _has_bits_[0] |= 0x00400000u;
}
inline void UserInfo::clear_has_packagestatus() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void UserInfo::clear_packagestatus() {
  packagestatus_ = 0;
  clear_has_packagestatus();
}
inline ::google::protobuf::int32 UserInfo::packagestatus() const {
  return packagestatus_;
}
inline void UserInfo::set_packagestatus(::google::protobuf::int32 value) {
  set_has_packagestatus();
  packagestatus_ = value;
}

// optional bool isNoble = 24;
inline bool UserInfo::has_isnoble() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void UserInfo::set_has_isnoble() {
  _has_bits_[0] |= 0x00800000u;
}
inline void UserInfo::clear_has_isnoble() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void UserInfo::clear_isnoble() {
  isnoble_ = false;
  clear_has_isnoble();
}
inline bool UserInfo::isnoble() const {
  return isnoble_;
}
inline void UserInfo::set_isnoble(bool value) {
  set_has_isnoble();
  isnoble_ = value;
}

// optional int32 leftNobleTime = 25;
inline bool UserInfo::has_leftnobletime() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void UserInfo::set_has_leftnobletime() {
  _has_bits_[0] |= 0x01000000u;
}
inline void UserInfo::clear_has_leftnobletime() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void UserInfo::clear_leftnobletime() {
  leftnobletime_ = 0;
  clear_has_leftnobletime();
}
inline ::google::protobuf::int32 UserInfo::leftnobletime() const {
  return leftnobletime_;
}
inline void UserInfo::set_leftnobletime(::google::protobuf::int32 value) {
  set_has_leftnobletime();
  leftnobletime_ = value;
}

// optional int32 leftGoldTime = 26;
inline bool UserInfo::has_leftgoldtime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void UserInfo::set_has_leftgoldtime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void UserInfo::clear_has_leftgoldtime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void UserInfo::clear_leftgoldtime() {
  leftgoldtime_ = 0;
  clear_has_leftgoldtime();
}
inline ::google::protobuf::int32 UserInfo::leftgoldtime() const {
  return leftgoldtime_;
}
inline void UserInfo::set_leftgoldtime(::google::protobuf::int32 value) {
  set_has_leftgoldtime();
  leftgoldtime_ = value;
}

// optional bool isGoldUnlocked = 27;
inline bool UserInfo::has_isgoldunlocked() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void UserInfo::set_has_isgoldunlocked() {
  _has_bits_[0] |= 0x04000000u;
}
inline void UserInfo::clear_has_isgoldunlocked() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void UserInfo::clear_isgoldunlocked() {
  isgoldunlocked_ = false;
  clear_has_isgoldunlocked();
}
inline bool UserInfo::isgoldunlocked() const {
  return isgoldunlocked_;
}
inline void UserInfo::set_isgoldunlocked(bool value) {
  set_has_isgoldunlocked();
  isgoldunlocked_ = value;
}

// optional int32 fansRewardStatus = 28;
inline bool UserInfo::has_fansrewardstatus() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void UserInfo::set_has_fansrewardstatus() {
  _has_bits_[0] |= 0x08000000u;
}
inline void UserInfo::clear_has_fansrewardstatus() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void UserInfo::clear_fansrewardstatus() {
  fansrewardstatus_ = 0;
  clear_has_fansrewardstatus();
}
inline ::google::protobuf::int32 UserInfo::fansrewardstatus() const {
  return fansrewardstatus_;
}
inline void UserInfo::set_fansrewardstatus(::google::protobuf::int32 value) {
  set_has_fansrewardstatus();
  fansrewardstatus_ = value;
}

// optional int32 fansRewardLastTime = 29;
inline bool UserInfo::has_fansrewardlasttime() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void UserInfo::set_has_fansrewardlasttime() {
  _has_bits_[0] |= 0x10000000u;
}
inline void UserInfo::clear_has_fansrewardlasttime() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void UserInfo::clear_fansrewardlasttime() {
  fansrewardlasttime_ = 0;
  clear_has_fansrewardlasttime();
}
inline ::google::protobuf::int32 UserInfo::fansrewardlasttime() const {
  return fansrewardlasttime_;
}
inline void UserInfo::set_fansrewardlasttime(::google::protobuf::int32 value) {
  set_has_fansrewardlasttime();
  fansrewardlasttime_ = value;
}

// optional int32 missionRewardStatus = 30;
inline bool UserInfo::has_missionrewardstatus() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void UserInfo::set_has_missionrewardstatus() {
  _has_bits_[0] |= 0x20000000u;
}
inline void UserInfo::clear_has_missionrewardstatus() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void UserInfo::clear_missionrewardstatus() {
  missionrewardstatus_ = 0;
  clear_has_missionrewardstatus();
}
inline ::google::protobuf::int32 UserInfo::missionrewardstatus() const {
  return missionrewardstatus_;
}
inline void UserInfo::set_missionrewardstatus(::google::protobuf::int32 value) {
  set_has_missionrewardstatus();
  missionrewardstatus_ = value;
}

// optional int32 missionFinishStatus = 31;
inline bool UserInfo::has_missionfinishstatus() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void UserInfo::set_has_missionfinishstatus() {
  _has_bits_[0] |= 0x40000000u;
}
inline void UserInfo::clear_has_missionfinishstatus() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void UserInfo::clear_missionfinishstatus() {
  missionfinishstatus_ = 0;
  clear_has_missionfinishstatus();
}
inline ::google::protobuf::int32 UserInfo::missionfinishstatus() const {
  return missionfinishstatus_;
}
inline void UserInfo::set_missionfinishstatus(::google::protobuf::int32 value) {
  set_has_missionfinishstatus();
  missionfinishstatus_ = value;
}

// optional int32 raceTimes = 32;
inline bool UserInfo::has_racetimes() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void UserInfo::set_has_racetimes() {
  _has_bits_[0] |= 0x80000000u;
}
inline void UserInfo::clear_has_racetimes() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void UserInfo::clear_racetimes() {
  racetimes_ = 0;
  clear_has_racetimes();
}
inline ::google::protobuf::int32 UserInfo::racetimes() const {
  return racetimes_;
}
inline void UserInfo::set_racetimes(::google::protobuf::int32 value) {
  set_has_racetimes();
  racetimes_ = value;
}

// optional bool isNewUser = 33;
inline bool UserInfo::has_isnewuser() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_isnewuser() {
  _has_bits_[1] |= 0x00000001u;
}
inline void UserInfo::clear_has_isnewuser() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void UserInfo::clear_isnewuser() {
  isnewuser_ = false;
  clear_has_isnewuser();
}
inline bool UserInfo::isnewuser() const {
  return isnewuser_;
}
inline void UserInfo::set_isnewuser(bool value) {
  set_has_isnewuser();
  isnewuser_ = value;
}

// optional int32 lotteryTimes = 34;
inline bool UserInfo::has_lotterytimes() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_lotterytimes() {
  _has_bits_[1] |= 0x00000002u;
}
inline void UserInfo::clear_has_lotterytimes() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void UserInfo::clear_lotterytimes() {
  lotterytimes_ = 0;
  clear_has_lotterytimes();
}
inline ::google::protobuf::int32 UserInfo::lotterytimes() const {
  return lotterytimes_;
}
inline void UserInfo::set_lotterytimes(::google::protobuf::int32 value) {
  set_has_lotterytimes();
  lotterytimes_ = value;
}

// -------------------------------------------------------------------

// RequestModifyUserInfoCommand

// optional int32 headIndex = 1;
inline bool RequestModifyUserInfoCommand::has_headindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestModifyUserInfoCommand::set_has_headindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestModifyUserInfoCommand::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestModifyUserInfoCommand::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 RequestModifyUserInfoCommand::headindex() const {
  return headindex_;
}
inline void RequestModifyUserInfoCommand::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// optional string nickname = 2;
inline bool RequestModifyUserInfoCommand::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestModifyUserInfoCommand::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestModifyUserInfoCommand::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestModifyUserInfoCommand::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RequestModifyUserInfoCommand::nickname() const {
  return *nickname_;
}
inline void RequestModifyUserInfoCommand::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RequestModifyUserInfoCommand::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RequestModifyUserInfoCommand::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestModifyUserInfoCommand::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* RequestModifyUserInfoCommand::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseModifyUserInfoCommand

// optional .com.ea.eamobile.nfsmw.protoc.ErrorCommand result = 1;
inline bool ResponseModifyUserInfoCommand::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseModifyUserInfoCommand::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseModifyUserInfoCommand::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseModifyUserInfoCommand::clear_result() {
  if (result_ != NULL) result_->::com::ea::eamobile::nfsmw::protoc::ErrorCommand::Clear();
  clear_has_result();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ErrorCommand& ResponseModifyUserInfoCommand::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* ResponseModifyUserInfoCommand::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::com::ea::eamobile::nfsmw::protoc::ErrorCommand;
  return result_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* ResponseModifyUserInfoCommand::release_result() {
  clear_has_result();
  ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* temp = result_;
  result_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.UserInfo userinfo = 2;
inline bool ResponseModifyUserInfoCommand::has_userinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseModifyUserInfoCommand::set_has_userinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseModifyUserInfoCommand::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseModifyUserInfoCommand::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::com::ea::eamobile::nfsmw::protoc::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::UserInfo& ResponseModifyUserInfoCommand::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* ResponseModifyUserInfoCommand::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::com::ea::eamobile::nfsmw::protoc::UserInfo;
  return userinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* ResponseModifyUserInfoCommand::release_userinfo() {
  clear_has_userinfo();
  ::com::ea::eamobile::nfsmw::protoc::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ResponseUserInfoCommand

// required .com.ea.eamobile.nfsmw.protoc.UserInfo userInfo = 1;
inline bool ResponseUserInfoCommand::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUserInfoCommand::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUserInfoCommand::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUserInfoCommand::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::com::ea::eamobile::nfsmw::protoc::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::UserInfo& ResponseUserInfoCommand::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* ResponseUserInfoCommand::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::com::ea::eamobile::nfsmw::protoc::UserInfo;
  return userinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* ResponseUserInfoCommand::release_userinfo() {
  clear_has_userinfo();
  ::com::ea::eamobile::nfsmw::protoc::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}

// required string token = 2;
inline bool ResponseUserInfoCommand::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseUserInfoCommand::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseUserInfoCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseUserInfoCommand::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ResponseUserInfoCommand::token() const {
  return *token_;
}
inline void ResponseUserInfoCommand::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ResponseUserInfoCommand::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ResponseUserInfoCommand::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseUserInfoCommand::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ResponseUserInfoCommand::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string defaultHint = 3;
inline bool ResponseUserInfoCommand::has_defaulthint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseUserInfoCommand::set_has_defaulthint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseUserInfoCommand::clear_has_defaulthint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseUserInfoCommand::clear_defaulthint() {
  if (defaulthint_ != &::google::protobuf::internal::kEmptyString) {
    defaulthint_->clear();
  }
  clear_has_defaulthint();
}
inline const ::std::string& ResponseUserInfoCommand::defaulthint() const {
  return *defaulthint_;
}
inline void ResponseUserInfoCommand::set_defaulthint(const ::std::string& value) {
  set_has_defaulthint();
  if (defaulthint_ == &::google::protobuf::internal::kEmptyString) {
    defaulthint_ = new ::std::string;
  }
  defaulthint_->assign(value);
}
inline void ResponseUserInfoCommand::set_defaulthint(const char* value) {
  set_has_defaulthint();
  if (defaulthint_ == &::google::protobuf::internal::kEmptyString) {
    defaulthint_ = new ::std::string;
  }
  defaulthint_->assign(value);
}
inline void ResponseUserInfoCommand::set_defaulthint(const char* value, size_t size) {
  set_has_defaulthint();
  if (defaulthint_ == &::google::protobuf::internal::kEmptyString) {
    defaulthint_ = new ::std::string;
  }
  defaulthint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseUserInfoCommand::mutable_defaulthint() {
  set_has_defaulthint();
  if (defaulthint_ == &::google::protobuf::internal::kEmptyString) {
    defaulthint_ = new ::std::string;
  }
  return defaulthint_;
}
inline ::std::string* ResponseUserInfoCommand::release_defaulthint() {
  clear_has_defaulthint();
  if (defaulthint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = defaulthint_;
    defaulthint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GhostInfo

// required bool success = 1;
inline bool GhostInfo::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GhostInfo::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GhostInfo::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GhostInfo::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool GhostInfo::success() const {
  return success_;
}
inline void GhostInfo::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required float raceTime = 2;
inline bool GhostInfo::has_racetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GhostInfo::set_has_racetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GhostInfo::clear_has_racetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GhostInfo::clear_racetime() {
  racetime_ = 0;
  clear_has_racetime();
}
inline float GhostInfo::racetime() const {
  return racetime_;
}
inline void GhostInfo::set_racetime(float value) {
  set_has_racetime();
  racetime_ = value;
}

// required float averageSpd = 3;
inline bool GhostInfo::has_averagespd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GhostInfo::set_has_averagespd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GhostInfo::clear_has_averagespd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GhostInfo::clear_averagespd() {
  averagespd_ = 0;
  clear_has_averagespd();
}
inline float GhostInfo::averagespd() const {
  return averagespd_;
}
inline void GhostInfo::set_averagespd(float value) {
  set_has_averagespd();
  averagespd_ = value;
}

// required int32 position = 4;
inline bool GhostInfo::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GhostInfo::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GhostInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GhostInfo::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 GhostInfo::position() const {
  return position_;
}
inline void GhostInfo::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
}

// required int32 modeId = 5;
inline bool GhostInfo::has_modeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GhostInfo::set_has_modeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GhostInfo::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GhostInfo::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 GhostInfo::modeid() const {
  return modeid_;
}
inline void GhostInfo::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// required string raceEventName = 6;
inline bool GhostInfo::has_raceeventname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GhostInfo::set_has_raceeventname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GhostInfo::clear_has_raceeventname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GhostInfo::clear_raceeventname() {
  if (raceeventname_ != &::google::protobuf::internal::kEmptyString) {
    raceeventname_->clear();
  }
  clear_has_raceeventname();
}
inline const ::std::string& GhostInfo::raceeventname() const {
  return *raceeventname_;
}
inline void GhostInfo::set_raceeventname(const ::std::string& value) {
  set_has_raceeventname();
  if (raceeventname_ == &::google::protobuf::internal::kEmptyString) {
    raceeventname_ = new ::std::string;
  }
  raceeventname_->assign(value);
}
inline void GhostInfo::set_raceeventname(const char* value) {
  set_has_raceeventname();
  if (raceeventname_ == &::google::protobuf::internal::kEmptyString) {
    raceeventname_ = new ::std::string;
  }
  raceeventname_->assign(value);
}
inline void GhostInfo::set_raceeventname(const char* value, size_t size) {
  set_has_raceeventname();
  if (raceeventname_ == &::google::protobuf::internal::kEmptyString) {
    raceeventname_ = new ::std::string;
  }
  raceeventname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GhostInfo::mutable_raceeventname() {
  set_has_raceeventname();
  if (raceeventname_ == &::google::protobuf::internal::kEmptyString) {
    raceeventname_ = new ::std::string;
  }
  return raceeventname_;
}
inline ::std::string* GhostInfo::release_raceeventname() {
  clear_has_raceeventname();
  if (raceeventname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = raceeventname_;
    raceeventname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string carID = 7;
inline bool GhostInfo::has_carid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GhostInfo::set_has_carid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GhostInfo::clear_has_carid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GhostInfo::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& GhostInfo::carid() const {
  return *carid_;
}
inline void GhostInfo::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void GhostInfo::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void GhostInfo::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GhostInfo::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* GhostInfo::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 carColorIndex = 8;
inline bool GhostInfo::has_carcolorindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GhostInfo::set_has_carcolorindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GhostInfo::clear_has_carcolorindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GhostInfo::clear_carcolorindex() {
  carcolorindex_ = 0;
  clear_has_carcolorindex();
}
inline ::google::protobuf::int32 GhostInfo::carcolorindex() const {
  return carcolorindex_;
}
inline void GhostInfo::set_carcolorindex(::google::protobuf::int32 value) {
  set_has_carcolorindex();
  carcolorindex_ = value;
}

// repeated int32 carModType = 9;
inline int GhostInfo::carmodtype_size() const {
  return carmodtype_.size();
}
inline void GhostInfo::clear_carmodtype() {
  carmodtype_.Clear();
}
inline ::google::protobuf::int32 GhostInfo::carmodtype(int index) const {
  return carmodtype_.Get(index);
}
inline void GhostInfo::set_carmodtype(int index, ::google::protobuf::int32 value) {
  carmodtype_.Set(index, value);
}
inline void GhostInfo::add_carmodtype(::google::protobuf::int32 value) {
  carmodtype_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GhostInfo::carmodtype() const {
  return carmodtype_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GhostInfo::mutable_carmodtype() {
  return &carmodtype_;
}

// repeated float carModValue = 10;
inline int GhostInfo::carmodvalue_size() const {
  return carmodvalue_.size();
}
inline void GhostInfo::clear_carmodvalue() {
  carmodvalue_.Clear();
}
inline float GhostInfo::carmodvalue(int index) const {
  return carmodvalue_.Get(index);
}
inline void GhostInfo::set_carmodvalue(int index, float value) {
  carmodvalue_.Set(index, value);
}
inline void GhostInfo::add_carmodvalue(float value) {
  carmodvalue_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
GhostInfo::carmodvalue() const {
  return carmodvalue_;
}
inline ::google::protobuf::RepeatedField< float >*
GhostInfo::mutable_carmodvalue() {
  return &carmodvalue_;
}

// optional int32 carScore = 11;
inline bool GhostInfo::has_carscore() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GhostInfo::set_has_carscore() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GhostInfo::clear_has_carscore() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GhostInfo::clear_carscore() {
  carscore_ = 0;
  clear_has_carscore();
}
inline ::google::protobuf::int32 GhostInfo::carscore() const {
  return carscore_;
}
inline void GhostInfo::set_carscore(::google::protobuf::int32 value) {
  set_has_carscore();
  carscore_ = value;
}

// repeated int32 carModId = 12;
inline int GhostInfo::carmodid_size() const {
  return carmodid_.size();
}
inline void GhostInfo::clear_carmodid() {
  carmodid_.Clear();
}
inline ::google::protobuf::int32 GhostInfo::carmodid(int index) const {
  return carmodid_.Get(index);
}
inline void GhostInfo::set_carmodid(int index, ::google::protobuf::int32 value) {
  carmodid_.Set(index, value);
}
inline void GhostInfo::add_carmodid(::google::protobuf::int32 value) {
  carmodid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GhostInfo::carmodid() const {
  return carmodid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GhostInfo::mutable_carmodid() {
  return &carmodid_;
}

// repeated int32 carModLevel = 13;
inline int GhostInfo::carmodlevel_size() const {
  return carmodlevel_.size();
}
inline void GhostInfo::clear_carmodlevel() {
  carmodlevel_.Clear();
}
inline ::google::protobuf::int32 GhostInfo::carmodlevel(int index) const {
  return carmodlevel_.Get(index);
}
inline void GhostInfo::set_carmodlevel(int index, ::google::protobuf::int32 value) {
  carmodlevel_.Set(index, value);
}
inline void GhostInfo::add_carmodlevel(::google::protobuf::int32 value) {
  carmodlevel_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GhostInfo::carmodlevel() const {
  return carmodlevel_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GhostInfo::mutable_carmodlevel() {
  return &carmodlevel_;
}

// optional int32 raceResultState = 14;
inline bool GhostInfo::has_raceresultstate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GhostInfo::set_has_raceresultstate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GhostInfo::clear_has_raceresultstate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GhostInfo::clear_raceresultstate() {
  raceresultstate_ = 0;
  clear_has_raceresultstate();
}
inline ::google::protobuf::int32 GhostInfo::raceresultstate() const {
  return raceresultstate_;
}
inline void GhostInfo::set_raceresultstate(::google::protobuf::int32 value) {
  set_has_raceresultstate();
  raceresultstate_ = value;
}

// optional string carPrefabFile = 15;
inline bool GhostInfo::has_carprefabfile() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GhostInfo::set_has_carprefabfile() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GhostInfo::clear_has_carprefabfile() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GhostInfo::clear_carprefabfile() {
  if (carprefabfile_ != &::google::protobuf::internal::kEmptyString) {
    carprefabfile_->clear();
  }
  clear_has_carprefabfile();
}
inline const ::std::string& GhostInfo::carprefabfile() const {
  return *carprefabfile_;
}
inline void GhostInfo::set_carprefabfile(const ::std::string& value) {
  set_has_carprefabfile();
  if (carprefabfile_ == &::google::protobuf::internal::kEmptyString) {
    carprefabfile_ = new ::std::string;
  }
  carprefabfile_->assign(value);
}
inline void GhostInfo::set_carprefabfile(const char* value) {
  set_has_carprefabfile();
  if (carprefabfile_ == &::google::protobuf::internal::kEmptyString) {
    carprefabfile_ = new ::std::string;
  }
  carprefabfile_->assign(value);
}
inline void GhostInfo::set_carprefabfile(const char* value, size_t size) {
  set_has_carprefabfile();
  if (carprefabfile_ == &::google::protobuf::internal::kEmptyString) {
    carprefabfile_ = new ::std::string;
  }
  carprefabfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GhostInfo::mutable_carprefabfile() {
  set_has_carprefabfile();
  if (carprefabfile_ == &::google::protobuf::internal::kEmptyString) {
    carprefabfile_ = new ::std::string;
  }
  return carprefabfile_;
}
inline ::std::string* GhostInfo::release_carprefabfile() {
  clear_has_carprefabfile();
  if (carprefabfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carprefabfile_;
    carprefabfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 carTopSpd = 16;
inline bool GhostInfo::has_cartopspd() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GhostInfo::set_has_cartopspd() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GhostInfo::clear_has_cartopspd() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GhostInfo::clear_cartopspd() {
  cartopspd_ = 0;
  clear_has_cartopspd();
}
inline ::google::protobuf::int32 GhostInfo::cartopspd() const {
  return cartopspd_;
}
inline void GhostInfo::set_cartopspd(::google::protobuf::int32 value) {
  set_has_cartopspd();
  cartopspd_ = value;
}

// optional int32 carMidSpd = 17;
inline bool GhostInfo::has_carmidspd() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GhostInfo::set_has_carmidspd() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GhostInfo::clear_has_carmidspd() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GhostInfo::clear_carmidspd() {
  carmidspd_ = 0;
  clear_has_carmidspd();
}
inline ::google::protobuf::int32 GhostInfo::carmidspd() const {
  return carmidspd_;
}
inline void GhostInfo::set_carmidspd(::google::protobuf::int32 value) {
  set_has_carmidspd();
  carmidspd_ = value;
}

// optional float trackLength = 18;
inline bool GhostInfo::has_tracklength() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GhostInfo::set_has_tracklength() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GhostInfo::clear_has_tracklength() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GhostInfo::clear_tracklength() {
  tracklength_ = 0;
  clear_has_tracklength();
}
inline float GhostInfo::tracklength() const {
  return tracklength_;
}
inline void GhostInfo::set_tracklength(float value) {
  set_has_tracklength();
  tracklength_ = value;
}

// -------------------------------------------------------------------

// RacerInfo

// required string name = 1;
inline bool RacerInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RacerInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RacerInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RacerInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RacerInfo::name() const {
  return *name_;
}
inline void RacerInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RacerInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RacerInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RacerInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RacerInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 headIndex = 2;
inline bool RacerInfo::has_headindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RacerInfo::set_has_headindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RacerInfo::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RacerInfo::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 RacerInfo::headindex() const {
  return headindex_;
}
inline void RacerInfo::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// optional string headUrl = 3;
inline bool RacerInfo::has_headurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RacerInfo::set_has_headurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RacerInfo::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RacerInfo::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& RacerInfo::headurl() const {
  return *headurl_;
}
inline void RacerInfo::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void RacerInfo::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void RacerInfo::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RacerInfo::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* RacerInfo::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required .com.ea.eamobile.nfsmw.protoc.GhostInfo ghost = 4;
inline bool RacerInfo::has_ghost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RacerInfo::set_has_ghost() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RacerInfo::clear_has_ghost() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RacerInfo::clear_ghost() {
  if (ghost_ != NULL) ghost_->::com::ea::eamobile::nfsmw::protoc::GhostInfo::Clear();
  clear_has_ghost();
}
inline const ::com::ea::eamobile::nfsmw::protoc::GhostInfo& RacerInfo::ghost() const {
  return ghost_ != NULL ? *ghost_ : *default_instance_->ghost_;
}
inline ::com::ea::eamobile::nfsmw::protoc::GhostInfo* RacerInfo::mutable_ghost() {
  set_has_ghost();
  if (ghost_ == NULL) ghost_ = new ::com::ea::eamobile::nfsmw::protoc::GhostInfo;
  return ghost_;
}
inline ::com::ea::eamobile::nfsmw::protoc::GhostInfo* RacerInfo::release_ghost() {
  clear_has_ghost();
  ::com::ea::eamobile::nfsmw::protoc::GhostInfo* temp = ghost_;
  ghost_ = NULL;
  return temp;
}

// optional int32 rpLv = 5;
inline bool RacerInfo::has_rplv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RacerInfo::set_has_rplv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RacerInfo::clear_has_rplv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RacerInfo::clear_rplv() {
  rplv_ = 0;
  clear_has_rplv();
}
inline ::google::protobuf::int32 RacerInfo::rplv() const {
  return rplv_;
}
inline void RacerInfo::set_rplv(::google::protobuf::int32 value) {
  set_has_rplv();
  rplv_ = value;
}

// -------------------------------------------------------------------

// RequestModeInfoCommand

// required int32 gameMode = 1;
inline bool RequestModeInfoCommand::has_gamemode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestModeInfoCommand::set_has_gamemode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestModeInfoCommand::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestModeInfoCommand::clear_gamemode() {
  gamemode_ = 0;
  clear_has_gamemode();
}
inline ::google::protobuf::int32 RequestModeInfoCommand::gamemode() const {
  return gamemode_;
}
inline void RequestModeInfoCommand::set_gamemode(::google::protobuf::int32 value) {
  set_has_gamemode();
  gamemode_ = value;
}

// required int32 modeId = 2;
inline bool RequestModeInfoCommand::has_modeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestModeInfoCommand::set_has_modeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestModeInfoCommand::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestModeInfoCommand::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 RequestModeInfoCommand::modeid() const {
  return modeid_;
}
inline void RequestModeInfoCommand::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// required int32 raceType = 3;
inline bool RequestModeInfoCommand::has_racetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestModeInfoCommand::set_has_racetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestModeInfoCommand::clear_has_racetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestModeInfoCommand::clear_racetype() {
  racetype_ = 0;
  clear_has_racetype();
}
inline ::google::protobuf::int32 RequestModeInfoCommand::racetype() const {
  return racetype_;
}
inline void RequestModeInfoCommand::set_racetype(::google::protobuf::int32 value) {
  set_has_racetype();
  racetype_ = value;
}

// -------------------------------------------------------------------

// ResponseRacerForGhostCommand

// repeated .com.ea.eamobile.nfsmw.protoc.RacerInfo racers = 1;
inline int ResponseRacerForGhostCommand::racers_size() const {
  return racers_.size();
}
inline void ResponseRacerForGhostCommand::clear_racers() {
  racers_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RacerInfo& ResponseRacerForGhostCommand::racers(int index) const {
  return racers_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RacerInfo* ResponseRacerForGhostCommand::mutable_racers(int index) {
  return racers_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RacerInfo* ResponseRacerForGhostCommand::add_racers() {
  return racers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RacerInfo >&
ResponseRacerForGhostCommand::racers() const {
  return racers_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RacerInfo >*
ResponseRacerForGhostCommand::mutable_racers() {
  return &racers_;
}

// optional int32 ghostAvergeEol = 2;
inline bool ResponseRacerForGhostCommand::has_ghostavergeeol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseRacerForGhostCommand::set_has_ghostavergeeol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseRacerForGhostCommand::clear_has_ghostavergeeol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseRacerForGhostCommand::clear_ghostavergeeol() {
  ghostavergeeol_ = 0;
  clear_has_ghostavergeeol();
}
inline ::google::protobuf::int32 ResponseRacerForGhostCommand::ghostavergeeol() const {
  return ghostavergeeol_;
}
inline void ResponseRacerForGhostCommand::set_ghostavergeeol(::google::protobuf::int32 value) {
  set_has_ghostavergeeol();
  ghostavergeeol_ = value;
}

// -------------------------------------------------------------------

// ResponseModeInfoCommand

// required int32 energyCost = 1;
inline bool ResponseModeInfoCommand::has_energycost() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseModeInfoCommand::set_has_energycost() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseModeInfoCommand::clear_has_energycost() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseModeInfoCommand::clear_energycost() {
  energycost_ = 0;
  clear_has_energycost();
}
inline ::google::protobuf::int32 ResponseModeInfoCommand::energycost() const {
  return energycost_;
}
inline void ResponseModeInfoCommand::set_energycost(::google::protobuf::int32 value) {
  set_has_energycost();
  energycost_ = value;
}

// required .com.ea.eamobile.nfsmw.protoc.Reward reward = 2;
inline bool ResponseModeInfoCommand::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseModeInfoCommand::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseModeInfoCommand::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseModeInfoCommand::clear_reward() {
  if (reward_ != NULL) reward_->::com::ea::eamobile::nfsmw::protoc::Reward::Clear();
  clear_has_reward();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Reward& ResponseModeInfoCommand::reward() const {
  return reward_ != NULL ? *reward_ : *default_instance_->reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseModeInfoCommand::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) reward_ = new ::com::ea::eamobile::nfsmw::protoc::Reward;
  return reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseModeInfoCommand::release_reward() {
  clear_has_reward();
  ::com::ea::eamobile::nfsmw::protoc::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}

// required string carLimitDisplayString = 3;
inline bool ResponseModeInfoCommand::has_carlimitdisplaystring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseModeInfoCommand::set_has_carlimitdisplaystring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseModeInfoCommand::clear_has_carlimitdisplaystring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseModeInfoCommand::clear_carlimitdisplaystring() {
  if (carlimitdisplaystring_ != &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_->clear();
  }
  clear_has_carlimitdisplaystring();
}
inline const ::std::string& ResponseModeInfoCommand::carlimitdisplaystring() const {
  return *carlimitdisplaystring_;
}
inline void ResponseModeInfoCommand::set_carlimitdisplaystring(const ::std::string& value) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(value);
}
inline void ResponseModeInfoCommand::set_carlimitdisplaystring(const char* value) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(value);
}
inline void ResponseModeInfoCommand::set_carlimitdisplaystring(const char* value, size_t size) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseModeInfoCommand::mutable_carlimitdisplaystring() {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  return carlimitdisplaystring_;
}
inline ::std::string* ResponseModeInfoCommand::release_carlimitdisplaystring() {
  clear_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carlimitdisplaystring_;
    carlimitdisplaystring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string acceptableCarIDs = 4;
inline int ResponseModeInfoCommand::acceptablecarids_size() const {
  return acceptablecarids_.size();
}
inline void ResponseModeInfoCommand::clear_acceptablecarids() {
  acceptablecarids_.Clear();
}
inline const ::std::string& ResponseModeInfoCommand::acceptablecarids(int index) const {
  return acceptablecarids_.Get(index);
}
inline ::std::string* ResponseModeInfoCommand::mutable_acceptablecarids(int index) {
  return acceptablecarids_.Mutable(index);
}
inline void ResponseModeInfoCommand::set_acceptablecarids(int index, const ::std::string& value) {
  acceptablecarids_.Mutable(index)->assign(value);
}
inline void ResponseModeInfoCommand::set_acceptablecarids(int index, const char* value) {
  acceptablecarids_.Mutable(index)->assign(value);
}
inline void ResponseModeInfoCommand::set_acceptablecarids(int index, const char* value, size_t size) {
  acceptablecarids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseModeInfoCommand::add_acceptablecarids() {
  return acceptablecarids_.Add();
}
inline void ResponseModeInfoCommand::add_acceptablecarids(const ::std::string& value) {
  acceptablecarids_.Add()->assign(value);
}
inline void ResponseModeInfoCommand::add_acceptablecarids(const char* value) {
  acceptablecarids_.Add()->assign(value);
}
inline void ResponseModeInfoCommand::add_acceptablecarids(const char* value, size_t size) {
  acceptablecarids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseModeInfoCommand::acceptablecarids() const {
  return acceptablecarids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseModeInfoCommand::mutable_acceptablecarids() {
  return &acceptablecarids_;
}

// optional int32 personalRank = 5;
inline bool ResponseModeInfoCommand::has_personalrank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseModeInfoCommand::set_has_personalrank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseModeInfoCommand::clear_has_personalrank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseModeInfoCommand::clear_personalrank() {
  personalrank_ = 0;
  clear_has_personalrank();
}
inline ::google::protobuf::int32 ResponseModeInfoCommand::personalrank() const {
  return personalrank_;
}
inline void ResponseModeInfoCommand::set_personalrank(::google::protobuf::int32 value) {
  set_has_personalrank();
  personalrank_ = value;
}

// optional int32 currentEnergy = 6;
inline bool ResponseModeInfoCommand::has_currentenergy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseModeInfoCommand::set_has_currentenergy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseModeInfoCommand::clear_has_currentenergy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseModeInfoCommand::clear_currentenergy() {
  currentenergy_ = 0;
  clear_has_currentenergy();
}
inline ::google::protobuf::int32 ResponseModeInfoCommand::currentenergy() const {
  return currentenergy_;
}
inline void ResponseModeInfoCommand::set_currentenergy(::google::protobuf::int32 value) {
  set_has_currentenergy();
  currentenergy_ = value;
}

// optional float personalBestTime = 7;
inline bool ResponseModeInfoCommand::has_personalbesttime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseModeInfoCommand::set_has_personalbesttime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseModeInfoCommand::clear_has_personalbesttime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseModeInfoCommand::clear_personalbesttime() {
  personalbesttime_ = 0;
  clear_has_personalbesttime();
}
inline float ResponseModeInfoCommand::personalbesttime() const {
  return personalbesttime_;
}
inline void ResponseModeInfoCommand::set_personalbesttime(float value) {
  set_has_personalbesttime();
  personalbesttime_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 8;
inline int ResponseModeInfoCommand::friendleaderboard_size() const {
  return friendleaderboard_.size();
}
inline void ResponseModeInfoCommand::clear_friendleaderboard() {
  friendleaderboard_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& ResponseModeInfoCommand::friendleaderboard(int index) const {
  return friendleaderboard_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseModeInfoCommand::mutable_friendleaderboard(int index) {
  return friendleaderboard_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseModeInfoCommand::add_friendleaderboard() {
  return friendleaderboard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
ResponseModeInfoCommand::friendleaderboard() const {
  return friendleaderboard_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
ResponseModeInfoCommand::mutable_friendleaderboard() {
  return &friendleaderboard_;
}

// repeated .com.ea.eamobile.nfsmw.protoc.Reward rewards = 9;
inline int ResponseModeInfoCommand::rewards_size() const {
  return rewards_.size();
}
inline void ResponseModeInfoCommand::clear_rewards() {
  rewards_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Reward& ResponseModeInfoCommand::rewards(int index) const {
  return rewards_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseModeInfoCommand::mutable_rewards(int index) {
  return rewards_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseModeInfoCommand::add_rewards() {
  return rewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward >&
ResponseModeInfoCommand::rewards() const {
  return rewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward >*
ResponseModeInfoCommand::mutable_rewards() {
  return &rewards_;
}

// repeated .com.ea.eamobile.nfsmw.protoc.LeaderboardProfile friendLeaderboard2 = 10;
inline int ResponseModeInfoCommand::friendleaderboard2_size() const {
  return friendleaderboard2_.size();
}
inline void ResponseModeInfoCommand::clear_friendleaderboard2() {
  friendleaderboard2_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile& ResponseModeInfoCommand::friendleaderboard2(int index) const {
  return friendleaderboard2_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile* ResponseModeInfoCommand::mutable_friendleaderboard2(int index) {
  return friendleaderboard2_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile* ResponseModeInfoCommand::add_friendleaderboard2() {
  return friendleaderboard2_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile >&
ResponseModeInfoCommand::friendleaderboard2() const {
  return friendleaderboard2_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardProfile >*
ResponseModeInfoCommand::mutable_friendleaderboard2() {
  return &friendleaderboard2_;
}

// optional int64 userId = 11;
inline bool ResponseModeInfoCommand::has_userid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResponseModeInfoCommand::set_has_userid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResponseModeInfoCommand::clear_has_userid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResponseModeInfoCommand::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 ResponseModeInfoCommand::userid() const {
  return userid_;
}
inline void ResponseModeInfoCommand::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// RequestRaceResultCommand

// required int32 gameMode = 1;
inline bool RequestRaceResultCommand::has_gamemode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRaceResultCommand::set_has_gamemode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRaceResultCommand::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRaceResultCommand::clear_gamemode() {
  gamemode_ = 0;
  clear_has_gamemode();
}
inline ::google::protobuf::int32 RequestRaceResultCommand::gamemode() const {
  return gamemode_;
}
inline void RequestRaceResultCommand::set_gamemode(::google::protobuf::int32 value) {
  set_has_gamemode();
  gamemode_ = value;
}

// required string trackId = 2;
inline bool RequestRaceResultCommand::has_trackid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRaceResultCommand::set_has_trackid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRaceResultCommand::clear_has_trackid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRaceResultCommand::clear_trackid() {
  if (trackid_ != &::google::protobuf::internal::kEmptyString) {
    trackid_->clear();
  }
  clear_has_trackid();
}
inline const ::std::string& RequestRaceResultCommand::trackid() const {
  return *trackid_;
}
inline void RequestRaceResultCommand::set_trackid(const ::std::string& value) {
  set_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    trackid_ = new ::std::string;
  }
  trackid_->assign(value);
}
inline void RequestRaceResultCommand::set_trackid(const char* value) {
  set_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    trackid_ = new ::std::string;
  }
  trackid_->assign(value);
}
inline void RequestRaceResultCommand::set_trackid(const char* value, size_t size) {
  set_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    trackid_ = new ::std::string;
  }
  trackid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestRaceResultCommand::mutable_trackid() {
  set_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    trackid_ = new ::std::string;
  }
  return trackid_;
}
inline ::std::string* RequestRaceResultCommand::release_trackid() {
  clear_has_trackid();
  if (trackid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trackid_;
    trackid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 modeId = 3;
inline bool RequestRaceResultCommand::has_modeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRaceResultCommand::set_has_modeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRaceResultCommand::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRaceResultCommand::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 RequestRaceResultCommand::modeid() const {
  return modeid_;
}
inline void RequestRaceResultCommand::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// required int32 rank = 4;
inline bool RequestRaceResultCommand::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRaceResultCommand::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRaceResultCommand::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRaceResultCommand::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 RequestRaceResultCommand::rank() const {
  return rank_;
}
inline void RequestRaceResultCommand::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// required .com.ea.eamobile.nfsmw.protoc.GhostInfo ghosts = 5;
inline bool RequestRaceResultCommand::has_ghosts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestRaceResultCommand::set_has_ghosts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestRaceResultCommand::clear_has_ghosts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestRaceResultCommand::clear_ghosts() {
  if (ghosts_ != NULL) ghosts_->::com::ea::eamobile::nfsmw::protoc::GhostInfo::Clear();
  clear_has_ghosts();
}
inline const ::com::ea::eamobile::nfsmw::protoc::GhostInfo& RequestRaceResultCommand::ghosts() const {
  return ghosts_ != NULL ? *ghosts_ : *default_instance_->ghosts_;
}
inline ::com::ea::eamobile::nfsmw::protoc::GhostInfo* RequestRaceResultCommand::mutable_ghosts() {
  set_has_ghosts();
  if (ghosts_ == NULL) ghosts_ = new ::com::ea::eamobile::nfsmw::protoc::GhostInfo;
  return ghosts_;
}
inline ::com::ea::eamobile::nfsmw::protoc::GhostInfo* RequestRaceResultCommand::release_ghosts() {
  clear_has_ghosts();
  ::com::ea::eamobile::nfsmw::protoc::GhostInfo* temp = ghosts_;
  ghosts_ = NULL;
  return temp;
}

// required int32 raceType = 6;
inline bool RequestRaceResultCommand::has_racetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestRaceResultCommand::set_has_racetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestRaceResultCommand::clear_has_racetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestRaceResultCommand::clear_racetype() {
  racetype_ = 0;
  clear_has_racetype();
}
inline ::google::protobuf::int32 RequestRaceResultCommand::racetype() const {
  return racetype_;
}
inline void RequestRaceResultCommand::set_racetype(::google::protobuf::int32 value) {
  set_has_racetype();
  racetype_ = value;
}

// optional int32 ghostAvergeEol = 7;
inline bool RequestRaceResultCommand::has_ghostavergeeol() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestRaceResultCommand::set_has_ghostavergeeol() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestRaceResultCommand::clear_has_ghostavergeeol() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestRaceResultCommand::clear_ghostavergeeol() {
  ghostavergeeol_ = 0;
  clear_has_ghostavergeeol();
}
inline ::google::protobuf::int32 RequestRaceResultCommand::ghostavergeeol() const {
  return ghostavergeeol_;
}
inline void RequestRaceResultCommand::set_ghostavergeeol(::google::protobuf::int32 value) {
  set_has_ghostavergeeol();
  ghostavergeeol_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.Prop propnum = 8;
inline int RequestRaceResultCommand::propnum_size() const {
  return propnum_.size();
}
inline void RequestRaceResultCommand::clear_propnum() {
  propnum_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Prop& RequestRaceResultCommand::propnum(int index) const {
  return propnum_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Prop* RequestRaceResultCommand::mutable_propnum(int index) {
  return propnum_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Prop* RequestRaceResultCommand::add_propnum() {
  return propnum_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop >&
RequestRaceResultCommand::propnum() const {
  return propnum_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Prop >*
RequestRaceResultCommand::mutable_propnum() {
  return &propnum_;
}

// -------------------------------------------------------------------

// RPMessage

// required int32 level = 1;
inline bool RPMessage::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RPMessage::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RPMessage::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RPMessage::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 RPMessage::level() const {
  return level_;
}
inline void RPMessage::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// optional string iconname = 2;
inline bool RPMessage::has_iconname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RPMessage::set_has_iconname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RPMessage::clear_has_iconname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RPMessage::clear_iconname() {
  if (iconname_ != &::google::protobuf::internal::kEmptyString) {
    iconname_->clear();
  }
  clear_has_iconname();
}
inline const ::std::string& RPMessage::iconname() const {
  return *iconname_;
}
inline void RPMessage::set_iconname(const ::std::string& value) {
  set_has_iconname();
  if (iconname_ == &::google::protobuf::internal::kEmptyString) {
    iconname_ = new ::std::string;
  }
  iconname_->assign(value);
}
inline void RPMessage::set_iconname(const char* value) {
  set_has_iconname();
  if (iconname_ == &::google::protobuf::internal::kEmptyString) {
    iconname_ = new ::std::string;
  }
  iconname_->assign(value);
}
inline void RPMessage::set_iconname(const char* value, size_t size) {
  set_has_iconname();
  if (iconname_ == &::google::protobuf::internal::kEmptyString) {
    iconname_ = new ::std::string;
  }
  iconname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPMessage::mutable_iconname() {
  set_has_iconname();
  if (iconname_ == &::google::protobuf::internal::kEmptyString) {
    iconname_ = new ::std::string;
  }
  return iconname_;
}
inline ::std::string* RPMessage::release_iconname() {
  clear_has_iconname();
  if (iconname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iconname_;
    iconname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string title = 3;
inline bool RPMessage::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RPMessage::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RPMessage::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RPMessage::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& RPMessage::title() const {
  return *title_;
}
inline void RPMessage::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void RPMessage::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void RPMessage::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPMessage::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* RPMessage::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float percentage = 4;
inline bool RPMessage::has_percentage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RPMessage::set_has_percentage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RPMessage::clear_has_percentage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RPMessage::clear_percentage() {
  percentage_ = 0;
  clear_has_percentage();
}
inline float RPMessage::percentage() const {
  return percentage_;
}
inline void RPMessage::set_percentage(float value) {
  set_has_percentage();
  percentage_ = value;
}

// optional int32 currentExp = 5;
inline bool RPMessage::has_currentexp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RPMessage::set_has_currentexp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RPMessage::clear_has_currentexp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RPMessage::clear_currentexp() {
  currentexp_ = 0;
  clear_has_currentexp();
}
inline ::google::protobuf::int32 RPMessage::currentexp() const {
  return currentexp_;
}
inline void RPMessage::set_currentexp(::google::protobuf::int32 value) {
  set_has_currentexp();
  currentexp_ = value;
}

// optional int32 minExp = 6;
inline bool RPMessage::has_minexp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RPMessage::set_has_minexp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RPMessage::clear_has_minexp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RPMessage::clear_minexp() {
  minexp_ = 0;
  clear_has_minexp();
}
inline ::google::protobuf::int32 RPMessage::minexp() const {
  return minexp_;
}
inline void RPMessage::set_minexp(::google::protobuf::int32 value) {
  set_has_minexp();
  minexp_ = value;
}

// optional int32 maxExp = 7;
inline bool RPMessage::has_maxexp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RPMessage::set_has_maxexp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RPMessage::clear_has_maxexp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RPMessage::clear_maxexp() {
  maxexp_ = 0;
  clear_has_maxexp();
}
inline ::google::protobuf::int32 RPMessage::maxexp() const {
  return maxexp_;
}
inline void RPMessage::set_maxexp(::google::protobuf::int32 value) {
  set_has_maxexp();
  maxexp_ = value;
}

// -------------------------------------------------------------------

// UnlockInfoMessage

// optional int32 tierUnlocked = 1;
inline bool UnlockInfoMessage::has_tierunlocked() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnlockInfoMessage::set_has_tierunlocked() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnlockInfoMessage::clear_has_tierunlocked() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnlockInfoMessage::clear_tierunlocked() {
  tierunlocked_ = 0;
  clear_has_tierunlocked();
}
inline ::google::protobuf::int32 UnlockInfoMessage::tierunlocked() const {
  return tierunlocked_;
}
inline void UnlockInfoMessage::set_tierunlocked(::google::protobuf::int32 value) {
  set_has_tierunlocked();
  tierunlocked_ = value;
}

// optional bool isTrackUnlocked = 2;
inline bool UnlockInfoMessage::has_istrackunlocked() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnlockInfoMessage::set_has_istrackunlocked() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnlockInfoMessage::clear_has_istrackunlocked() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnlockInfoMessage::clear_istrackunlocked() {
  istrackunlocked_ = false;
  clear_has_istrackunlocked();
}
inline bool UnlockInfoMessage::istrackunlocked() const {
  return istrackunlocked_;
}
inline void UnlockInfoMessage::set_istrackunlocked(bool value) {
  set_has_istrackunlocked();
  istrackunlocked_ = value;
}

// optional bool isModeUnlocked = 3;
inline bool UnlockInfoMessage::has_ismodeunlocked() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnlockInfoMessage::set_has_ismodeunlocked() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnlockInfoMessage::clear_has_ismodeunlocked() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnlockInfoMessage::clear_ismodeunlocked() {
  ismodeunlocked_ = false;
  clear_has_ismodeunlocked();
}
inline bool UnlockInfoMessage::ismodeunlocked() const {
  return ismodeunlocked_;
}
inline void UnlockInfoMessage::set_ismodeunlocked(bool value) {
  set_has_ismodeunlocked();
  ismodeunlocked_ = value;
}

// repeated string unlockedCar = 4;
inline int UnlockInfoMessage::unlockedcar_size() const {
  return unlockedcar_.size();
}
inline void UnlockInfoMessage::clear_unlockedcar() {
  unlockedcar_.Clear();
}
inline const ::std::string& UnlockInfoMessage::unlockedcar(int index) const {
  return unlockedcar_.Get(index);
}
inline ::std::string* UnlockInfoMessage::mutable_unlockedcar(int index) {
  return unlockedcar_.Mutable(index);
}
inline void UnlockInfoMessage::set_unlockedcar(int index, const ::std::string& value) {
  unlockedcar_.Mutable(index)->assign(value);
}
inline void UnlockInfoMessage::set_unlockedcar(int index, const char* value) {
  unlockedcar_.Mutable(index)->assign(value);
}
inline void UnlockInfoMessage::set_unlockedcar(int index, const char* value, size_t size) {
  unlockedcar_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnlockInfoMessage::add_unlockedcar() {
  return unlockedcar_.Add();
}
inline void UnlockInfoMessage::add_unlockedcar(const ::std::string& value) {
  unlockedcar_.Add()->assign(value);
}
inline void UnlockInfoMessage::add_unlockedcar(const char* value) {
  unlockedcar_.Add()->assign(value);
}
inline void UnlockInfoMessage::add_unlockedcar(const char* value, size_t size) {
  unlockedcar_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UnlockInfoMessage::unlockedcar() const {
  return unlockedcar_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UnlockInfoMessage::mutable_unlockedcar() {
  return &unlockedcar_;
}

// -------------------------------------------------------------------

// ResponseRaceResultCommand

// required int32 trackFinishRatio = 1;
inline bool ResponseRaceResultCommand::has_trackfinishratio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRaceResultCommand::set_has_trackfinishratio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRaceResultCommand::clear_has_trackfinishratio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRaceResultCommand::clear_trackfinishratio() {
  trackfinishratio_ = 0;
  clear_has_trackfinishratio();
}
inline ::google::protobuf::int32 ResponseRaceResultCommand::trackfinishratio() const {
  return trackfinishratio_;
}
inline void ResponseRaceResultCommand::set_trackfinishratio(::google::protobuf::int32 value) {
  set_has_trackfinishratio();
  trackfinishratio_ = value;
}

// required int32 modeFinishRatio = 2;
inline bool ResponseRaceResultCommand::has_modefinishratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseRaceResultCommand::set_has_modefinishratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseRaceResultCommand::clear_has_modefinishratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseRaceResultCommand::clear_modefinishratio() {
  modefinishratio_ = 0;
  clear_has_modefinishratio();
}
inline ::google::protobuf::int32 ResponseRaceResultCommand::modefinishratio() const {
  return modefinishratio_;
}
inline void ResponseRaceResultCommand::set_modefinishratio(::google::protobuf::int32 value) {
  set_has_modefinishratio();
  modefinishratio_ = value;
}

// required int32 gainMostWantedNum = 3;
inline bool ResponseRaceResultCommand::has_gainmostwantednum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseRaceResultCommand::set_has_gainmostwantednum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseRaceResultCommand::clear_has_gainmostwantednum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseRaceResultCommand::clear_gainmostwantednum() {
  gainmostwantednum_ = 0;
  clear_has_gainmostwantednum();
}
inline ::google::protobuf::int32 ResponseRaceResultCommand::gainmostwantednum() const {
  return gainmostwantednum_;
}
inline void ResponseRaceResultCommand::set_gainmostwantednum(::google::protobuf::int32 value) {
  set_has_gainmostwantednum();
  gainmostwantednum_ = value;
}

// repeated string unlockTracks = 4;
inline int ResponseRaceResultCommand::unlocktracks_size() const {
  return unlocktracks_.size();
}
inline void ResponseRaceResultCommand::clear_unlocktracks() {
  unlocktracks_.Clear();
}
inline const ::std::string& ResponseRaceResultCommand::unlocktracks(int index) const {
  return unlocktracks_.Get(index);
}
inline ::std::string* ResponseRaceResultCommand::mutable_unlocktracks(int index) {
  return unlocktracks_.Mutable(index);
}
inline void ResponseRaceResultCommand::set_unlocktracks(int index, const ::std::string& value) {
  unlocktracks_.Mutable(index)->assign(value);
}
inline void ResponseRaceResultCommand::set_unlocktracks(int index, const char* value) {
  unlocktracks_.Mutable(index)->assign(value);
}
inline void ResponseRaceResultCommand::set_unlocktracks(int index, const char* value, size_t size) {
  unlocktracks_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseRaceResultCommand::add_unlocktracks() {
  return unlocktracks_.Add();
}
inline void ResponseRaceResultCommand::add_unlocktracks(const ::std::string& value) {
  unlocktracks_.Add()->assign(value);
}
inline void ResponseRaceResultCommand::add_unlocktracks(const char* value) {
  unlocktracks_.Add()->assign(value);
}
inline void ResponseRaceResultCommand::add_unlocktracks(const char* value, size_t size) {
  unlocktracks_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseRaceResultCommand::unlocktracks() const {
  return unlocktracks_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseRaceResultCommand::mutable_unlocktracks() {
  return &unlocktracks_;
}

// repeated int32 unlockModes = 5;
inline int ResponseRaceResultCommand::unlockmodes_size() const {
  return unlockmodes_.size();
}
inline void ResponseRaceResultCommand::clear_unlockmodes() {
  unlockmodes_.Clear();
}
inline ::google::protobuf::int32 ResponseRaceResultCommand::unlockmodes(int index) const {
  return unlockmodes_.Get(index);
}
inline void ResponseRaceResultCommand::set_unlockmodes(int index, ::google::protobuf::int32 value) {
  unlockmodes_.Set(index, value);
}
inline void ResponseRaceResultCommand::add_unlockmodes(::google::protobuf::int32 value) {
  unlockmodes_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ResponseRaceResultCommand::unlockmodes() const {
  return unlockmodes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ResponseRaceResultCommand::mutable_unlockmodes() {
  return &unlockmodes_;
}

// optional .com.ea.eamobile.nfsmw.protoc.Reward rewards = 6;
inline bool ResponseRaceResultCommand::has_rewards() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseRaceResultCommand::set_has_rewards() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseRaceResultCommand::clear_has_rewards() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseRaceResultCommand::clear_rewards() {
  if (rewards_ != NULL) rewards_->::com::ea::eamobile::nfsmw::protoc::Reward::Clear();
  clear_has_rewards();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Reward& ResponseRaceResultCommand::rewards() const {
  return rewards_ != NULL ? *rewards_ : *default_instance_->rewards_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseRaceResultCommand::mutable_rewards() {
  set_has_rewards();
  if (rewards_ == NULL) rewards_ = new ::com::ea::eamobile::nfsmw::protoc::Reward;
  return rewards_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseRaceResultCommand::release_rewards() {
  clear_has_rewards();
  ::com::ea::eamobile::nfsmw::protoc::Reward* temp = rewards_;
  rewards_ = NULL;
  return temp;
}

// optional bool isNewRecord = 7;
inline bool ResponseRaceResultCommand::has_isnewrecord() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseRaceResultCommand::set_has_isnewrecord() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseRaceResultCommand::clear_has_isnewrecord() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseRaceResultCommand::clear_isnewrecord() {
  isnewrecord_ = false;
  clear_has_isnewrecord();
}
inline bool ResponseRaceResultCommand::isnewrecord() const {
  return isnewrecord_;
}
inline void ResponseRaceResultCommand::set_isnewrecord(bool value) {
  set_has_isnewrecord();
  isnewrecord_ = value;
}

// optional int32 newRank = 8;
inline bool ResponseRaceResultCommand::has_newrank() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseRaceResultCommand::set_has_newrank() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseRaceResultCommand::clear_has_newrank() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseRaceResultCommand::clear_newrank() {
  newrank_ = 0;
  clear_has_newrank();
}
inline ::google::protobuf::int32 ResponseRaceResultCommand::newrank() const {
  return newrank_;
}
inline void ResponseRaceResultCommand::set_newrank(::google::protobuf::int32 value) {
  set_has_newrank();
  newrank_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard leaderBoard = 9;
inline int ResponseRaceResultCommand::leaderboard_size() const {
  return leaderboard_.size();
}
inline void ResponseRaceResultCommand::clear_leaderboard() {
  leaderboard_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& ResponseRaceResultCommand::leaderboard(int index) const {
  return leaderboard_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseRaceResultCommand::mutable_leaderboard(int index) {
  return leaderboard_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseRaceResultCommand::add_leaderboard() {
  return leaderboard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
ResponseRaceResultCommand::leaderboard() const {
  return leaderboard_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
ResponseRaceResultCommand::mutable_leaderboard() {
  return &leaderboard_;
}

// optional .com.ea.eamobile.nfsmw.protoc.TierInfo tier = 10;
inline bool ResponseRaceResultCommand::has_tier() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseRaceResultCommand::set_has_tier() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseRaceResultCommand::clear_has_tier() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseRaceResultCommand::clear_tier() {
  if (tier_ != NULL) tier_->::com::ea::eamobile::nfsmw::protoc::TierInfo::Clear();
  clear_has_tier();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TierInfo& ResponseRaceResultCommand::tier() const {
  return tier_ != NULL ? *tier_ : *default_instance_->tier_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TierInfo* ResponseRaceResultCommand::mutable_tier() {
  set_has_tier();
  if (tier_ == NULL) tier_ = new ::com::ea::eamobile::nfsmw::protoc::TierInfo;
  return tier_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TierInfo* ResponseRaceResultCommand::release_tier() {
  clear_has_tier();
  ::com::ea::eamobile::nfsmw::protoc::TierInfo* temp = tier_;
  tier_ = NULL;
  return temp;
}

// optional float personalBestTime = 11;
inline bool ResponseRaceResultCommand::has_personalbesttime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResponseRaceResultCommand::set_has_personalbesttime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResponseRaceResultCommand::clear_has_personalbesttime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResponseRaceResultCommand::clear_personalbesttime() {
  personalbesttime_ = 0;
  clear_has_personalbesttime();
}
inline float ResponseRaceResultCommand::personalbesttime() const {
  return personalbesttime_;
}
inline void ResponseRaceResultCommand::set_personalbesttime(float value) {
  set_has_personalbesttime();
  personalbesttime_ = value;
}

// optional int32 bestRank = 12;
inline bool ResponseRaceResultCommand::has_bestrank() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResponseRaceResultCommand::set_has_bestrank() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResponseRaceResultCommand::clear_has_bestrank() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResponseRaceResultCommand::clear_bestrank() {
  bestrank_ = 0;
  clear_has_bestrank();
}
inline ::google::protobuf::int32 ResponseRaceResultCommand::bestrank() const {
  return bestrank_;
}
inline void ResponseRaceResultCommand::set_bestrank(::google::protobuf::int32 value) {
  set_has_bestrank();
  bestrank_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.RPMessage rpmessages = 13;
inline int ResponseRaceResultCommand::rpmessages_size() const {
  return rpmessages_.size();
}
inline void ResponseRaceResultCommand::clear_rpmessages() {
  rpmessages_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RPMessage& ResponseRaceResultCommand::rpmessages(int index) const {
  return rpmessages_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* ResponseRaceResultCommand::mutable_rpmessages(int index) {
  return rpmessages_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* ResponseRaceResultCommand::add_rpmessages() {
  return rpmessages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage >&
ResponseRaceResultCommand::rpmessages() const {
  return rpmessages_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage >*
ResponseRaceResultCommand::mutable_rpmessages() {
  return &rpmessages_;
}

// optional .com.ea.eamobile.nfsmw.protoc.UnlockInfoMessage unlockInfo = 14;
inline bool ResponseRaceResultCommand::has_unlockinfo() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResponseRaceResultCommand::set_has_unlockinfo() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResponseRaceResultCommand::clear_has_unlockinfo() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResponseRaceResultCommand::clear_unlockinfo() {
  if (unlockinfo_ != NULL) unlockinfo_->::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage::Clear();
  clear_has_unlockinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage& ResponseRaceResultCommand::unlockinfo() const {
  return unlockinfo_ != NULL ? *unlockinfo_ : *default_instance_->unlockinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage* ResponseRaceResultCommand::mutable_unlockinfo() {
  set_has_unlockinfo();
  if (unlockinfo_ == NULL) unlockinfo_ = new ::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage;
  return unlockinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage* ResponseRaceResultCommand::release_unlockinfo() {
  clear_has_unlockinfo();
  ::com::ea::eamobile::nfsmw::protoc::UnlockInfoMessage* temp = unlockinfo_;
  unlockinfo_ = NULL;
  return temp;
}

// repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 15;
inline int ResponseRaceResultCommand::friendleaderboard_size() const {
  return friendleaderboard_.size();
}
inline void ResponseRaceResultCommand::clear_friendleaderboard() {
  friendleaderboard_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& ResponseRaceResultCommand::friendleaderboard(int index) const {
  return friendleaderboard_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseRaceResultCommand::mutable_friendleaderboard(int index) {
  return friendleaderboard_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseRaceResultCommand::add_friendleaderboard() {
  return friendleaderboard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
ResponseRaceResultCommand::friendleaderboard() const {
  return friendleaderboard_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
ResponseRaceResultCommand::mutable_friendleaderboard() {
  return &friendleaderboard_;
}

// -------------------------------------------------------------------

// ResponseTournamentRaceResultCommand

// optional .com.ea.eamobile.nfsmw.protoc.Reward rewards = 6;
inline bool ResponseTournamentRaceResultCommand::has_rewards() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_rewards() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_rewards() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseTournamentRaceResultCommand::clear_rewards() {
  if (rewards_ != NULL) rewards_->::com::ea::eamobile::nfsmw::protoc::Reward::Clear();
  clear_has_rewards();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Reward& ResponseTournamentRaceResultCommand::rewards() const {
  return rewards_ != NULL ? *rewards_ : *default_instance_->rewards_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseTournamentRaceResultCommand::mutable_rewards() {
  set_has_rewards();
  if (rewards_ == NULL) rewards_ = new ::com::ea::eamobile::nfsmw::protoc::Reward;
  return rewards_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseTournamentRaceResultCommand::release_rewards() {
  clear_has_rewards();
  ::com::ea::eamobile::nfsmw::protoc::Reward* temp = rewards_;
  rewards_ = NULL;
  return temp;
}

// repeated .com.ea.eamobile.nfsmw.protoc.RPMessage rpmessages = 13;
inline int ResponseTournamentRaceResultCommand::rpmessages_size() const {
  return rpmessages_.size();
}
inline void ResponseTournamentRaceResultCommand::clear_rpmessages() {
  rpmessages_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RPMessage& ResponseTournamentRaceResultCommand::rpmessages(int index) const {
  return rpmessages_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* ResponseTournamentRaceResultCommand::mutable_rpmessages(int index) {
  return rpmessages_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RPMessage* ResponseTournamentRaceResultCommand::add_rpmessages() {
  return rpmessages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage >&
ResponseTournamentRaceResultCommand::rpmessages() const {
  return rpmessages_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RPMessage >*
ResponseTournamentRaceResultCommand::mutable_rpmessages() {
  return &rpmessages_;
}

// optional float tournamentRemainTime = 15;
inline bool ResponseTournamentRaceResultCommand::has_tournamentremaintime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_tournamentremaintime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_tournamentremaintime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseTournamentRaceResultCommand::clear_tournamentremaintime() {
  tournamentremaintime_ = 0;
  clear_has_tournamentremaintime();
}
inline float ResponseTournamentRaceResultCommand::tournamentremaintime() const {
  return tournamentremaintime_;
}
inline void ResponseTournamentRaceResultCommand::set_tournamentremaintime(float value) {
  set_has_tournamentremaintime();
  tournamentremaintime_ = value;
}

// optional int32 tournamentLeftTimes = 16;
inline bool ResponseTournamentRaceResultCommand::has_tournamentlefttimes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_tournamentlefttimes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_tournamentlefttimes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseTournamentRaceResultCommand::clear_tournamentlefttimes() {
  tournamentlefttimes_ = 0;
  clear_has_tournamentlefttimes();
}
inline ::google::protobuf::int32 ResponseTournamentRaceResultCommand::tournamentlefttimes() const {
  return tournamentlefttimes_;
}
inline void ResponseTournamentRaceResultCommand::set_tournamentlefttimes(::google::protobuf::int32 value) {
  set_has_tournamentlefttimes();
  tournamentlefttimes_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard board = 17;
inline int ResponseTournamentRaceResultCommand::board_size() const {
  return board_.size();
}
inline void ResponseTournamentRaceResultCommand::clear_board() {
  board_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& ResponseTournamentRaceResultCommand::board(int index) const {
  return board_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseTournamentRaceResultCommand::mutable_board(int index) {
  return board_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseTournamentRaceResultCommand::add_board() {
  return board_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
ResponseTournamentRaceResultCommand::board() const {
  return board_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
ResponseTournamentRaceResultCommand::mutable_board() {
  return &board_;
}

// required int32 selfRank = 18;
inline bool ResponseTournamentRaceResultCommand::has_selfrank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_selfrank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_selfrank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseTournamentRaceResultCommand::clear_selfrank() {
  selfrank_ = 0;
  clear_has_selfrank();
}
inline ::google::protobuf::int32 ResponseTournamentRaceResultCommand::selfrank() const {
  return selfrank_;
}
inline void ResponseTournamentRaceResultCommand::set_selfrank(::google::protobuf::int32 value) {
  set_has_selfrank();
  selfrank_ = value;
}

// required string selfName = 19;
inline bool ResponseTournamentRaceResultCommand::has_selfname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_selfname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_selfname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseTournamentRaceResultCommand::clear_selfname() {
  if (selfname_ != &::google::protobuf::internal::kEmptyString) {
    selfname_->clear();
  }
  clear_has_selfname();
}
inline const ::std::string& ResponseTournamentRaceResultCommand::selfname() const {
  return *selfname_;
}
inline void ResponseTournamentRaceResultCommand::set_selfname(const ::std::string& value) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(value);
}
inline void ResponseTournamentRaceResultCommand::set_selfname(const char* value) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(value);
}
inline void ResponseTournamentRaceResultCommand::set_selfname(const char* value, size_t size) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentRaceResultCommand::mutable_selfname() {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  return selfname_;
}
inline ::std::string* ResponseTournamentRaceResultCommand::release_selfname() {
  clear_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfname_;
    selfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float selfRaceResult = 20;
inline bool ResponseTournamentRaceResultCommand::has_selfraceresult() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_selfraceresult() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_selfraceresult() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseTournamentRaceResultCommand::clear_selfraceresult() {
  selfraceresult_ = 0;
  clear_has_selfraceresult();
}
inline float ResponseTournamentRaceResultCommand::selfraceresult() const {
  return selfraceresult_;
}
inline void ResponseTournamentRaceResultCommand::set_selfraceresult(float value) {
  set_has_selfraceresult();
  selfraceresult_ = value;
}

// optional int32 upRank = 21;
inline bool ResponseTournamentRaceResultCommand::has_uprank() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_uprank() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_uprank() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseTournamentRaceResultCommand::clear_uprank() {
  uprank_ = 0;
  clear_has_uprank();
}
inline ::google::protobuf::int32 ResponseTournamentRaceResultCommand::uprank() const {
  return uprank_;
}
inline void ResponseTournamentRaceResultCommand::set_uprank(::google::protobuf::int32 value) {
  set_has_uprank();
  uprank_ = value;
}

// optional bool isNewRecode = 22;
inline bool ResponseTournamentRaceResultCommand::has_isnewrecode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_isnewrecode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_isnewrecode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseTournamentRaceResultCommand::clear_isnewrecode() {
  isnewrecode_ = false;
  clear_has_isnewrecode();
}
inline bool ResponseTournamentRaceResultCommand::isnewrecode() const {
  return isnewrecode_;
}
inline void ResponseTournamentRaceResultCommand::set_isnewrecode(bool value) {
  set_has_isnewrecode();
  isnewrecode_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 23;
inline int ResponseTournamentRaceResultCommand::friendleaderboard_size() const {
  return friendleaderboard_.size();
}
inline void ResponseTournamentRaceResultCommand::clear_friendleaderboard() {
  friendleaderboard_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& ResponseTournamentRaceResultCommand::friendleaderboard(int index) const {
  return friendleaderboard_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseTournamentRaceResultCommand::mutable_friendleaderboard(int index) {
  return friendleaderboard_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseTournamentRaceResultCommand::add_friendleaderboard() {
  return friendleaderboard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
ResponseTournamentRaceResultCommand::friendleaderboard() const {
  return friendleaderboard_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
ResponseTournamentRaceResultCommand::mutable_friendleaderboard() {
  return &friendleaderboard_;
}

// optional int32 tournamentOnlineId = 24;
inline bool ResponseTournamentRaceResultCommand::has_tournamentonlineid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_tournamentonlineid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_tournamentonlineid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResponseTournamentRaceResultCommand::clear_tournamentonlineid() {
  tournamentonlineid_ = 0;
  clear_has_tournamentonlineid();
}
inline ::google::protobuf::int32 ResponseTournamentRaceResultCommand::tournamentonlineid() const {
  return tournamentonlineid_;
}
inline void ResponseTournamentRaceResultCommand::set_tournamentonlineid(::google::protobuf::int32 value) {
  set_has_tournamentonlineid();
  tournamentonlineid_ = value;
}

// optional bool isTournamentOnlineFinish = 25;
inline bool ResponseTournamentRaceResultCommand::has_istournamentonlinefinish() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResponseTournamentRaceResultCommand::set_has_istournamentonlinefinish() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResponseTournamentRaceResultCommand::clear_has_istournamentonlinefinish() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResponseTournamentRaceResultCommand::clear_istournamentonlinefinish() {
  istournamentonlinefinish_ = false;
  clear_has_istournamentonlinefinish();
}
inline bool ResponseTournamentRaceResultCommand::istournamentonlinefinish() const {
  return istournamentonlinefinish_;
}
inline void ResponseTournamentRaceResultCommand::set_istournamentonlinefinish(bool value) {
  set_has_istournamentonlinefinish();
  istournamentonlinefinish_ = value;
}

// -------------------------------------------------------------------

// TournamentMessage

// required int32 type = 1;
inline bool TournamentMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TournamentMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TournamentMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TournamentMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 TournamentMessage::type() const {
  return type_;
}
inline void TournamentMessage::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string name = 2;
inline bool TournamentMessage::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TournamentMessage::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TournamentMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TournamentMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TournamentMessage::name() const {
  return *name_;
}
inline void TournamentMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TournamentMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 startTime = 3;
inline bool TournamentMessage::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TournamentMessage::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TournamentMessage::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TournamentMessage::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 TournamentMessage::starttime() const {
  return starttime_;
}
inline void TournamentMessage::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional int64 remainTime = 4;
inline bool TournamentMessage::has_remaintime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TournamentMessage::set_has_remaintime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TournamentMessage::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TournamentMessage::clear_remaintime() {
  remaintime_ = GOOGLE_LONGLONG(0);
  clear_has_remaintime();
}
inline ::google::protobuf::int64 TournamentMessage::remaintime() const {
  return remaintime_;
}
inline void TournamentMessage::set_remaintime(::google::protobuf::int64 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// optional int32 signUpType = 5;
inline bool TournamentMessage::has_signuptype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TournamentMessage::set_has_signuptype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TournamentMessage::clear_has_signuptype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TournamentMessage::clear_signuptype() {
  signuptype_ = 0;
  clear_has_signuptype();
}
inline ::google::protobuf::int32 TournamentMessage::signuptype() const {
  return signuptype_;
}
inline void TournamentMessage::set_signuptype(::google::protobuf::int32 value) {
  set_has_signuptype();
  signuptype_ = value;
}

// optional int32 signUp = 6;
inline bool TournamentMessage::has_signup() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TournamentMessage::set_has_signup() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TournamentMessage::clear_has_signup() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TournamentMessage::clear_signup() {
  signup_ = 0;
  clear_has_signup();
}
inline ::google::protobuf::int32 TournamentMessage::signup() const {
  return signup_;
}
inline void TournamentMessage::set_signup(::google::protobuf::int32 value) {
  set_has_signup();
  signup_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.TournamentRankingListMessage rankList = 7;
inline int TournamentMessage::ranklist_size() const {
  return ranklist_.size();
}
inline void TournamentMessage::clear_ranklist() {
  ranklist_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage& TournamentMessage::ranklist(int index) const {
  return ranklist_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage* TournamentMessage::mutable_ranklist(int index) {
  return ranklist_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage* TournamentMessage::add_ranklist() {
  return ranklist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage >&
TournamentMessage::ranklist() const {
  return ranklist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRankingListMessage >*
TournamentMessage::mutable_ranklist() {
  return &ranklist_;
}

// optional int32 rankingHighLight = 13;
inline bool TournamentMessage::has_rankinghighlight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TournamentMessage::set_has_rankinghighlight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TournamentMessage::clear_has_rankinghighlight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TournamentMessage::clear_rankinghighlight() {
  rankinghighlight_ = 0;
  clear_has_rankinghighlight();
}
inline ::google::protobuf::int32 TournamentMessage::rankinghighlight() const {
  return rankinghighlight_;
}
inline void TournamentMessage::set_rankinghighlight(::google::protobuf::int32 value) {
  set_has_rankinghighlight();
  rankinghighlight_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.TournamentRewardListMessage rewardList = 14;
inline int TournamentMessage::rewardlist_size() const {
  return rewardlist_.size();
}
inline void TournamentMessage::clear_rewardlist() {
  rewardlist_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage& TournamentMessage::rewardlist(int index) const {
  return rewardlist_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage* TournamentMessage::mutable_rewardlist(int index) {
  return rewardlist_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage* TournamentMessage::add_rewardlist() {
  return rewardlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage >&
TournamentMessage::rewardlist() const {
  return rewardlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardListMessage >*
TournamentMessage::mutable_rewardlist() {
  return &rewardlist_;
}

// optional int32 leftTimes = 17;
inline bool TournamentMessage::has_lefttimes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TournamentMessage::set_has_lefttimes() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TournamentMessage::clear_has_lefttimes() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TournamentMessage::clear_lefttimes() {
  lefttimes_ = 0;
  clear_has_lefttimes();
}
inline ::google::protobuf::int32 TournamentMessage::lefttimes() const {
  return lefttimes_;
}
inline void TournamentMessage::set_lefttimes(::google::protobuf::int32 value) {
  set_has_lefttimes();
  lefttimes_ = value;
}

// required string id = 18;
inline bool TournamentMessage::has_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TournamentMessage::set_has_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TournamentMessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TournamentMessage::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& TournamentMessage::id() const {
  return *id_;
}
inline void TournamentMessage::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TournamentMessage::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void TournamentMessage::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentMessage::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* TournamentMessage::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 energy = 22;
inline bool TournamentMessage::has_energy() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TournamentMessage::set_has_energy() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TournamentMessage::clear_has_energy() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TournamentMessage::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline ::google::protobuf::int32 TournamentMessage::energy() const {
  return energy_;
}
inline void TournamentMessage::set_energy(::google::protobuf::int32 value) {
  set_has_energy();
  energy_ = value;
}

// required int32 onlineId = 23;
inline bool TournamentMessage::has_onlineid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TournamentMessage::set_has_onlineid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TournamentMessage::clear_has_onlineid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TournamentMessage::clear_onlineid() {
  onlineid_ = 0;
  clear_has_onlineid();
}
inline ::google::protobuf::int32 TournamentMessage::onlineid() const {
  return onlineid_;
}
inline void TournamentMessage::set_onlineid(::google::protobuf::int32 value) {
  set_has_onlineid();
  onlineid_ = value;
}

// required int32 eventId = 24;
inline bool TournamentMessage::has_eventid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TournamentMessage::set_has_eventid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TournamentMessage::clear_has_eventid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TournamentMessage::clear_eventid() {
  eventid_ = 0;
  clear_has_eventid();
}
inline ::google::protobuf::int32 TournamentMessage::eventid() const {
  return eventid_;
}
inline void TournamentMessage::set_eventid(::google::protobuf::int32 value) {
  set_has_eventid();
  eventid_ = value;
}

// optional int32 signUpPrice = 25;
inline bool TournamentMessage::has_signupprice() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TournamentMessage::set_has_signupprice() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TournamentMessage::clear_has_signupprice() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TournamentMessage::clear_signupprice() {
  signupprice_ = 0;
  clear_has_signupprice();
}
inline ::google::protobuf::int32 TournamentMessage::signupprice() const {
  return signupprice_;
}
inline void TournamentMessage::set_signupprice(::google::protobuf::int32 value) {
  set_has_signupprice();
  signupprice_ = value;
}

// optional string backgroundPictureId = 26;
inline bool TournamentMessage::has_backgroundpictureid() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TournamentMessage::set_has_backgroundpictureid() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TournamentMessage::clear_has_backgroundpictureid() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TournamentMessage::clear_backgroundpictureid() {
  if (backgroundpictureid_ != &::google::protobuf::internal::kEmptyString) {
    backgroundpictureid_->clear();
  }
  clear_has_backgroundpictureid();
}
inline const ::std::string& TournamentMessage::backgroundpictureid() const {
  return *backgroundpictureid_;
}
inline void TournamentMessage::set_backgroundpictureid(const ::std::string& value) {
  set_has_backgroundpictureid();
  if (backgroundpictureid_ == &::google::protobuf::internal::kEmptyString) {
    backgroundpictureid_ = new ::std::string;
  }
  backgroundpictureid_->assign(value);
}
inline void TournamentMessage::set_backgroundpictureid(const char* value) {
  set_has_backgroundpictureid();
  if (backgroundpictureid_ == &::google::protobuf::internal::kEmptyString) {
    backgroundpictureid_ = new ::std::string;
  }
  backgroundpictureid_->assign(value);
}
inline void TournamentMessage::set_backgroundpictureid(const char* value, size_t size) {
  set_has_backgroundpictureid();
  if (backgroundpictureid_ == &::google::protobuf::internal::kEmptyString) {
    backgroundpictureid_ = new ::std::string;
  }
  backgroundpictureid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentMessage::mutable_backgroundpictureid() {
  set_has_backgroundpictureid();
  if (backgroundpictureid_ == &::google::protobuf::internal::kEmptyString) {
    backgroundpictureid_ = new ::std::string;
  }
  return backgroundpictureid_;
}
inline ::std::string* TournamentMessage::release_backgroundpictureid() {
  clear_has_backgroundpictureid();
  if (backgroundpictureid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backgroundpictureid_;
    backgroundpictureid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 adId = 27;
inline bool TournamentMessage::has_adid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TournamentMessage::set_has_adid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TournamentMessage::clear_has_adid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TournamentMessage::clear_adid() {
  adid_ = 0;
  clear_has_adid();
}
inline ::google::protobuf::int32 TournamentMessage::adid() const {
  return adid_;
}
inline void TournamentMessage::set_adid(::google::protobuf::int32 value) {
  set_has_adid();
  adid_ = value;
}

// optional bool isAlreadyGetReward = 28;
inline bool TournamentMessage::has_isalreadygetreward() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TournamentMessage::set_has_isalreadygetreward() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TournamentMessage::clear_has_isalreadygetreward() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TournamentMessage::clear_isalreadygetreward() {
  isalreadygetreward_ = false;
  clear_has_isalreadygetreward();
}
inline bool TournamentMessage::isalreadygetreward() const {
  return isalreadygetreward_;
}
inline void TournamentMessage::set_isalreadygetreward(bool value) {
  set_has_isalreadygetreward();
  isalreadygetreward_ = value;
}

// optional string tournamentGroup = 29;
inline bool TournamentMessage::has_tournamentgroup() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TournamentMessage::set_has_tournamentgroup() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TournamentMessage::clear_has_tournamentgroup() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TournamentMessage::clear_tournamentgroup() {
  if (tournamentgroup_ != &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_->clear();
  }
  clear_has_tournamentgroup();
}
inline const ::std::string& TournamentMessage::tournamentgroup() const {
  return *tournamentgroup_;
}
inline void TournamentMessage::set_tournamentgroup(const ::std::string& value) {
  set_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_ = new ::std::string;
  }
  tournamentgroup_->assign(value);
}
inline void TournamentMessage::set_tournamentgroup(const char* value) {
  set_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_ = new ::std::string;
  }
  tournamentgroup_->assign(value);
}
inline void TournamentMessage::set_tournamentgroup(const char* value, size_t size) {
  set_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_ = new ::std::string;
  }
  tournamentgroup_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentMessage::mutable_tournamentgroup() {
  set_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_ = new ::std::string;
  }
  return tournamentgroup_;
}
inline ::std::string* TournamentMessage::release_tournamentgroup() {
  clear_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tournamentgroup_;
    tournamentgroup_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string tournamentCarName = 30;
inline bool TournamentMessage::has_tournamentcarname() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TournamentMessage::set_has_tournamentcarname() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TournamentMessage::clear_has_tournamentcarname() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TournamentMessage::clear_tournamentcarname() {
  if (tournamentcarname_ != &::google::protobuf::internal::kEmptyString) {
    tournamentcarname_->clear();
  }
  clear_has_tournamentcarname();
}
inline const ::std::string& TournamentMessage::tournamentcarname() const {
  return *tournamentcarname_;
}
inline void TournamentMessage::set_tournamentcarname(const ::std::string& value) {
  set_has_tournamentcarname();
  if (tournamentcarname_ == &::google::protobuf::internal::kEmptyString) {
    tournamentcarname_ = new ::std::string;
  }
  tournamentcarname_->assign(value);
}
inline void TournamentMessage::set_tournamentcarname(const char* value) {
  set_has_tournamentcarname();
  if (tournamentcarname_ == &::google::protobuf::internal::kEmptyString) {
    tournamentcarname_ = new ::std::string;
  }
  tournamentcarname_->assign(value);
}
inline void TournamentMessage::set_tournamentcarname(const char* value, size_t size) {
  set_has_tournamentcarname();
  if (tournamentcarname_ == &::google::protobuf::internal::kEmptyString) {
    tournamentcarname_ = new ::std::string;
  }
  tournamentcarname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentMessage::mutable_tournamentcarname() {
  set_has_tournamentcarname();
  if (tournamentcarname_ == &::google::protobuf::internal::kEmptyString) {
    tournamentcarname_ = new ::std::string;
  }
  return tournamentcarname_;
}
inline ::std::string* TournamentMessage::release_tournamentcarname() {
  clear_has_tournamentcarname();
  if (tournamentcarname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tournamentcarname_;
    tournamentcarname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TournamentRankingListMessage

// required string rank = 1;
inline bool TournamentRankingListMessage::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TournamentRankingListMessage::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TournamentRankingListMessage::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TournamentRankingListMessage::clear_rank() {
  if (rank_ != &::google::protobuf::internal::kEmptyString) {
    rank_->clear();
  }
  clear_has_rank();
}
inline const ::std::string& TournamentRankingListMessage::rank() const {
  return *rank_;
}
inline void TournamentRankingListMessage::set_rank(const ::std::string& value) {
  set_has_rank();
  if (rank_ == &::google::protobuf::internal::kEmptyString) {
    rank_ = new ::std::string;
  }
  rank_->assign(value);
}
inline void TournamentRankingListMessage::set_rank(const char* value) {
  set_has_rank();
  if (rank_ == &::google::protobuf::internal::kEmptyString) {
    rank_ = new ::std::string;
  }
  rank_->assign(value);
}
inline void TournamentRankingListMessage::set_rank(const char* value, size_t size) {
  set_has_rank();
  if (rank_ == &::google::protobuf::internal::kEmptyString) {
    rank_ = new ::std::string;
  }
  rank_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentRankingListMessage::mutable_rank() {
  set_has_rank();
  if (rank_ == &::google::protobuf::internal::kEmptyString) {
    rank_ = new ::std::string;
  }
  return rank_;
}
inline ::std::string* TournamentRankingListMessage::release_rank() {
  clear_has_rank();
  if (rank_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rank_;
    rank_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool TournamentRankingListMessage::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TournamentRankingListMessage::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TournamentRankingListMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TournamentRankingListMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TournamentRankingListMessage::name() const {
  return *name_;
}
inline void TournamentRankingListMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentRankingListMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentRankingListMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentRankingListMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TournamentRankingListMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TournamentRewardListMessage

// required string num = 1;
inline bool TournamentRewardListMessage::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TournamentRewardListMessage::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TournamentRewardListMessage::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TournamentRewardListMessage::clear_num() {
  if (num_ != &::google::protobuf::internal::kEmptyString) {
    num_->clear();
  }
  clear_has_num();
}
inline const ::std::string& TournamentRewardListMessage::num() const {
  return *num_;
}
inline void TournamentRewardListMessage::set_num(const ::std::string& value) {
  set_has_num();
  if (num_ == &::google::protobuf::internal::kEmptyString) {
    num_ = new ::std::string;
  }
  num_->assign(value);
}
inline void TournamentRewardListMessage::set_num(const char* value) {
  set_has_num();
  if (num_ == &::google::protobuf::internal::kEmptyString) {
    num_ = new ::std::string;
  }
  num_->assign(value);
}
inline void TournamentRewardListMessage::set_num(const char* value, size_t size) {
  set_has_num();
  if (num_ == &::google::protobuf::internal::kEmptyString) {
    num_ = new ::std::string;
  }
  num_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentRewardListMessage::mutable_num() {
  set_has_num();
  if (num_ == &::google::protobuf::internal::kEmptyString) {
    num_ = new ::std::string;
  }
  return num_;
}
inline ::std::string* TournamentRewardListMessage::release_num() {
  clear_has_num();
  if (num_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = num_;
    num_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 2;
inline bool TournamentRewardListMessage::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TournamentRewardListMessage::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TournamentRewardListMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TournamentRewardListMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TournamentRewardListMessage::name() const {
  return *name_;
}
inline void TournamentRewardListMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentRewardListMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentRewardListMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentRewardListMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TournamentRewardListMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TournamentRewardDetailMessage

// required int32 rank = 1;
inline bool TournamentRewardDetailMessage::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TournamentRewardDetailMessage::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TournamentRewardDetailMessage::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TournamentRewardDetailMessage::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 TournamentRewardDetailMessage::rank() const {
  return rank_;
}
inline void TournamentRewardDetailMessage::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// required string name = 2;
inline bool TournamentRewardDetailMessage::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TournamentRewardDetailMessage::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TournamentRewardDetailMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TournamentRewardDetailMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TournamentRewardDetailMessage::name() const {
  return *name_;
}
inline void TournamentRewardDetailMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentRewardDetailMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentRewardDetailMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentRewardDetailMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TournamentRewardDetailMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float raceTime = 3;
inline bool TournamentRewardDetailMessage::has_racetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TournamentRewardDetailMessage::set_has_racetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TournamentRewardDetailMessage::clear_has_racetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TournamentRewardDetailMessage::clear_racetime() {
  racetime_ = 0;
  clear_has_racetime();
}
inline float TournamentRewardDetailMessage::racetime() const {
  return racetime_;
}
inline void TournamentRewardDetailMessage::set_racetime(float value) {
  set_has_racetime();
  racetime_ = value;
}

// required string reward = 4;
inline bool TournamentRewardDetailMessage::has_reward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TournamentRewardDetailMessage::set_has_reward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TournamentRewardDetailMessage::clear_has_reward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TournamentRewardDetailMessage::clear_reward() {
  if (reward_ != &::google::protobuf::internal::kEmptyString) {
    reward_->clear();
  }
  clear_has_reward();
}
inline const ::std::string& TournamentRewardDetailMessage::reward() const {
  return *reward_;
}
inline void TournamentRewardDetailMessage::set_reward(const ::std::string& value) {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  reward_->assign(value);
}
inline void TournamentRewardDetailMessage::set_reward(const char* value) {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  reward_->assign(value);
}
inline void TournamentRewardDetailMessage::set_reward(const char* value, size_t size) {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  reward_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentRewardDetailMessage::mutable_reward() {
  set_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    reward_ = new ::std::string;
  }
  return reward_;
}
inline ::std::string* TournamentRewardDetailMessage::release_reward() {
  clear_has_reward();
  if (reward_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reward_;
    reward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 headIndex = 5;
inline bool TournamentRewardDetailMessage::has_headindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TournamentRewardDetailMessage::set_has_headindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TournamentRewardDetailMessage::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TournamentRewardDetailMessage::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 TournamentRewardDetailMessage::headindex() const {
  return headindex_;
}
inline void TournamentRewardDetailMessage::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// optional string headUrl = 6;
inline bool TournamentRewardDetailMessage::has_headurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TournamentRewardDetailMessage::set_has_headurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TournamentRewardDetailMessage::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TournamentRewardDetailMessage::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& TournamentRewardDetailMessage::headurl() const {
  return *headurl_;
}
inline void TournamentRewardDetailMessage::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void TournamentRewardDetailMessage::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void TournamentRewardDetailMessage::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentRewardDetailMessage::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* TournamentRewardDetailMessage::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string displayName = 7;
inline bool TournamentRewardDetailMessage::has_displayname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TournamentRewardDetailMessage::set_has_displayname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TournamentRewardDetailMessage::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TournamentRewardDetailMessage::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& TournamentRewardDetailMessage::displayname() const {
  return *displayname_;
}
inline void TournamentRewardDetailMessage::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void TournamentRewardDetailMessage::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void TournamentRewardDetailMessage::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentRewardDetailMessage::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* TournamentRewardDetailMessage::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TournamentDetailMessage

// required int32 rank = 1;
inline bool TournamentDetailMessage::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TournamentDetailMessage::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TournamentDetailMessage::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TournamentDetailMessage::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 TournamentDetailMessage::rank() const {
  return rank_;
}
inline void TournamentDetailMessage::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// required string name = 2;
inline bool TournamentDetailMessage::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TournamentDetailMessage::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TournamentDetailMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TournamentDetailMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TournamentDetailMessage::name() const {
  return *name_;
}
inline void TournamentDetailMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentDetailMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TournamentDetailMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentDetailMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TournamentDetailMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float raceTime = 3;
inline bool TournamentDetailMessage::has_racetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TournamentDetailMessage::set_has_racetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TournamentDetailMessage::clear_has_racetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TournamentDetailMessage::clear_racetime() {
  racetime_ = 0;
  clear_has_racetime();
}
inline float TournamentDetailMessage::racetime() const {
  return racetime_;
}
inline void TournamentDetailMessage::set_racetime(float value) {
  set_has_racetime();
  racetime_ = value;
}

// required int32 headIndex = 4;
inline bool TournamentDetailMessage::has_headindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TournamentDetailMessage::set_has_headindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TournamentDetailMessage::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TournamentDetailMessage::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 TournamentDetailMessage::headindex() const {
  return headindex_;
}
inline void TournamentDetailMessage::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// optional string headUrl = 5;
inline bool TournamentDetailMessage::has_headurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TournamentDetailMessage::set_has_headurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TournamentDetailMessage::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TournamentDetailMessage::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& TournamentDetailMessage::headurl() const {
  return *headurl_;
}
inline void TournamentDetailMessage::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void TournamentDetailMessage::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void TournamentDetailMessage::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentDetailMessage::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* TournamentDetailMessage::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 userId = 6;
inline bool TournamentDetailMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TournamentDetailMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TournamentDetailMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TournamentDetailMessage::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 TournamentDetailMessage::userid() const {
  return userid_;
}
inline void TournamentDetailMessage::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// TournamentDetailRewardMessage

// required string title = 1;
inline bool TournamentDetailRewardMessage::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TournamentDetailRewardMessage::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TournamentDetailRewardMessage::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TournamentDetailRewardMessage::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& TournamentDetailRewardMessage::title() const {
  return *title_;
}
inline void TournamentDetailRewardMessage::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void TournamentDetailRewardMessage::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void TournamentDetailRewardMessage::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentDetailRewardMessage::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* TournamentDetailRewardMessage::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string money = 2;
inline bool TournamentDetailRewardMessage::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TournamentDetailRewardMessage::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TournamentDetailRewardMessage::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TournamentDetailRewardMessage::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& TournamentDetailRewardMessage::money() const {
  return *money_;
}
inline void TournamentDetailRewardMessage::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void TournamentDetailRewardMessage::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void TournamentDetailRewardMessage::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentDetailRewardMessage::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* TournamentDetailRewardMessage::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string rmb = 3;
inline bool TournamentDetailRewardMessage::has_rmb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TournamentDetailRewardMessage::set_has_rmb() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TournamentDetailRewardMessage::clear_has_rmb() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TournamentDetailRewardMessage::clear_rmb() {
  if (rmb_ != &::google::protobuf::internal::kEmptyString) {
    rmb_->clear();
  }
  clear_has_rmb();
}
inline const ::std::string& TournamentDetailRewardMessage::rmb() const {
  return *rmb_;
}
inline void TournamentDetailRewardMessage::set_rmb(const ::std::string& value) {
  set_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    rmb_ = new ::std::string;
  }
  rmb_->assign(value);
}
inline void TournamentDetailRewardMessage::set_rmb(const char* value) {
  set_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    rmb_ = new ::std::string;
  }
  rmb_->assign(value);
}
inline void TournamentDetailRewardMessage::set_rmb(const char* value, size_t size) {
  set_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    rmb_ = new ::std::string;
  }
  rmb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentDetailRewardMessage::mutable_rmb() {
  set_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    rmb_ = new ::std::string;
  }
  return rmb_;
}
inline ::std::string* TournamentDetailRewardMessage::release_rmb() {
  clear_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rmb_;
    rmb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string displayName = 4;
inline bool TournamentDetailRewardMessage::has_displayname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TournamentDetailRewardMessage::set_has_displayname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TournamentDetailRewardMessage::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TournamentDetailRewardMessage::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& TournamentDetailRewardMessage::displayname() const {
  return *displayname_;
}
inline void TournamentDetailRewardMessage::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void TournamentDetailRewardMessage::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void TournamentDetailRewardMessage::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TournamentDetailRewardMessage::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* TournamentDetailRewardMessage::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestTournamentCommand

// required int32 type = 1;
inline bool RequestTournamentCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestTournamentCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestTournamentCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestTournamentCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RequestTournamentCommand::type() const {
  return type_;
}
inline void RequestTournamentCommand::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ResponseTournamentCommand

// repeated .com.ea.eamobile.nfsmw.protoc.TournamentMessage tournament = 1;
inline int ResponseTournamentCommand::tournament_size() const {
  return tournament_.size();
}
inline void ResponseTournamentCommand::clear_tournament() {
  tournament_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TournamentMessage& ResponseTournamentCommand::tournament(int index) const {
  return tournament_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentMessage* ResponseTournamentCommand::mutable_tournament(int index) {
  return tournament_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentMessage* ResponseTournamentCommand::add_tournament() {
  return tournament_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentMessage >&
ResponseTournamentCommand::tournament() const {
  return tournament_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentMessage >*
ResponseTournamentCommand::mutable_tournament() {
  return &tournament_;
}

// optional int32 type = 2;
inline bool ResponseTournamentCommand::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseTournamentCommand::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseTournamentCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseTournamentCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ResponseTournamentCommand::type() const {
  return type_;
}
inline void ResponseTournamentCommand::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// RequestTournamentRewardDetailCommand

// required int32 tournamentOnlineId = 2;
inline bool RequestTournamentRewardDetailCommand::has_tournamentonlineid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestTournamentRewardDetailCommand::set_has_tournamentonlineid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestTournamentRewardDetailCommand::clear_has_tournamentonlineid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestTournamentRewardDetailCommand::clear_tournamentonlineid() {
  tournamentonlineid_ = 0;
  clear_has_tournamentonlineid();
}
inline ::google::protobuf::int32 RequestTournamentRewardDetailCommand::tournamentonlineid() const {
  return tournamentonlineid_;
}
inline void RequestTournamentRewardDetailCommand::set_tournamentonlineid(::google::protobuf::int32 value) {
  set_has_tournamentonlineid();
  tournamentonlineid_ = value;
}

// -------------------------------------------------------------------

// ResponseTournamentRewardDetailCommand

// repeated .com.ea.eamobile.nfsmw.protoc.TournamentRewardDetailMessage rewardDetail = 1;
inline int ResponseTournamentRewardDetailCommand::rewarddetail_size() const {
  return rewarddetail_.size();
}
inline void ResponseTournamentRewardDetailCommand::clear_rewarddetail() {
  rewarddetail_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage& ResponseTournamentRewardDetailCommand::rewarddetail(int index) const {
  return rewarddetail_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage* ResponseTournamentRewardDetailCommand::mutable_rewarddetail(int index) {
  return rewarddetail_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage* ResponseTournamentRewardDetailCommand::add_rewarddetail() {
  return rewarddetail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage >&
ResponseTournamentRewardDetailCommand::rewarddetail() const {
  return rewarddetail_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentRewardDetailMessage >*
ResponseTournamentRewardDetailCommand::mutable_rewarddetail() {
  return &rewarddetail_;
}

// optional int32 selfRank = 2;
inline bool ResponseTournamentRewardDetailCommand::has_selfrank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseTournamentRewardDetailCommand::set_has_selfrank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseTournamentRewardDetailCommand::clear_has_selfrank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseTournamentRewardDetailCommand::clear_selfrank() {
  selfrank_ = 0;
  clear_has_selfrank();
}
inline ::google::protobuf::int32 ResponseTournamentRewardDetailCommand::selfrank() const {
  return selfrank_;
}
inline void ResponseTournamentRewardDetailCommand::set_selfrank(::google::protobuf::int32 value) {
  set_has_selfrank();
  selfrank_ = value;
}

// optional string selfName = 3;
inline bool ResponseTournamentRewardDetailCommand::has_selfname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseTournamentRewardDetailCommand::set_has_selfname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseTournamentRewardDetailCommand::clear_has_selfname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseTournamentRewardDetailCommand::clear_selfname() {
  if (selfname_ != &::google::protobuf::internal::kEmptyString) {
    selfname_->clear();
  }
  clear_has_selfname();
}
inline const ::std::string& ResponseTournamentRewardDetailCommand::selfname() const {
  return *selfname_;
}
inline void ResponseTournamentRewardDetailCommand::set_selfname(const ::std::string& value) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_selfname(const char* value) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_selfname(const char* value, size_t size) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentRewardDetailCommand::mutable_selfname() {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  return selfname_;
}
inline ::std::string* ResponseTournamentRewardDetailCommand::release_selfname() {
  clear_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfname_;
    selfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float selfRaceTime = 4;
inline bool ResponseTournamentRewardDetailCommand::has_selfracetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseTournamentRewardDetailCommand::set_has_selfracetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseTournamentRewardDetailCommand::clear_has_selfracetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseTournamentRewardDetailCommand::clear_selfracetime() {
  selfracetime_ = 0;
  clear_has_selfracetime();
}
inline float ResponseTournamentRewardDetailCommand::selfracetime() const {
  return selfracetime_;
}
inline void ResponseTournamentRewardDetailCommand::set_selfracetime(float value) {
  set_has_selfracetime();
  selfracetime_ = value;
}

// optional string selfReward = 5;
inline bool ResponseTournamentRewardDetailCommand::has_selfreward() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseTournamentRewardDetailCommand::set_has_selfreward() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseTournamentRewardDetailCommand::clear_has_selfreward() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseTournamentRewardDetailCommand::clear_selfreward() {
  if (selfreward_ != &::google::protobuf::internal::kEmptyString) {
    selfreward_->clear();
  }
  clear_has_selfreward();
}
inline const ::std::string& ResponseTournamentRewardDetailCommand::selfreward() const {
  return *selfreward_;
}
inline void ResponseTournamentRewardDetailCommand::set_selfreward(const ::std::string& value) {
  set_has_selfreward();
  if (selfreward_ == &::google::protobuf::internal::kEmptyString) {
    selfreward_ = new ::std::string;
  }
  selfreward_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_selfreward(const char* value) {
  set_has_selfreward();
  if (selfreward_ == &::google::protobuf::internal::kEmptyString) {
    selfreward_ = new ::std::string;
  }
  selfreward_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_selfreward(const char* value, size_t size) {
  set_has_selfreward();
  if (selfreward_ == &::google::protobuf::internal::kEmptyString) {
    selfreward_ = new ::std::string;
  }
  selfreward_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentRewardDetailCommand::mutable_selfreward() {
  set_has_selfreward();
  if (selfreward_ == &::google::protobuf::internal::kEmptyString) {
    selfreward_ = new ::std::string;
  }
  return selfreward_;
}
inline ::std::string* ResponseTournamentRewardDetailCommand::release_selfreward() {
  clear_has_selfreward();
  if (selfreward_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfreward_;
    selfreward_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 selfHeadIndex = 6;
inline bool ResponseTournamentRewardDetailCommand::has_selfheadindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseTournamentRewardDetailCommand::set_has_selfheadindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseTournamentRewardDetailCommand::clear_has_selfheadindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseTournamentRewardDetailCommand::clear_selfheadindex() {
  selfheadindex_ = 0;
  clear_has_selfheadindex();
}
inline ::google::protobuf::int32 ResponseTournamentRewardDetailCommand::selfheadindex() const {
  return selfheadindex_;
}
inline void ResponseTournamentRewardDetailCommand::set_selfheadindex(::google::protobuf::int32 value) {
  set_has_selfheadindex();
  selfheadindex_ = value;
}

// optional string selfHeadUrl = 7;
inline bool ResponseTournamentRewardDetailCommand::has_selfheadurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseTournamentRewardDetailCommand::set_has_selfheadurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseTournamentRewardDetailCommand::clear_has_selfheadurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseTournamentRewardDetailCommand::clear_selfheadurl() {
  if (selfheadurl_ != &::google::protobuf::internal::kEmptyString) {
    selfheadurl_->clear();
  }
  clear_has_selfheadurl();
}
inline const ::std::string& ResponseTournamentRewardDetailCommand::selfheadurl() const {
  return *selfheadurl_;
}
inline void ResponseTournamentRewardDetailCommand::set_selfheadurl(const ::std::string& value) {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  selfheadurl_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_selfheadurl(const char* value) {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  selfheadurl_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_selfheadurl(const char* value, size_t size) {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  selfheadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentRewardDetailCommand::mutable_selfheadurl() {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  return selfheadurl_;
}
inline ::std::string* ResponseTournamentRewardDetailCommand::release_selfheadurl() {
  clear_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfheadurl_;
    selfheadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string tournamentName = 8;
inline bool ResponseTournamentRewardDetailCommand::has_tournamentname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseTournamentRewardDetailCommand::set_has_tournamentname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseTournamentRewardDetailCommand::clear_has_tournamentname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseTournamentRewardDetailCommand::clear_tournamentname() {
  if (tournamentname_ != &::google::protobuf::internal::kEmptyString) {
    tournamentname_->clear();
  }
  clear_has_tournamentname();
}
inline const ::std::string& ResponseTournamentRewardDetailCommand::tournamentname() const {
  return *tournamentname_;
}
inline void ResponseTournamentRewardDetailCommand::set_tournamentname(const ::std::string& value) {
  set_has_tournamentname();
  if (tournamentname_ == &::google::protobuf::internal::kEmptyString) {
    tournamentname_ = new ::std::string;
  }
  tournamentname_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_tournamentname(const char* value) {
  set_has_tournamentname();
  if (tournamentname_ == &::google::protobuf::internal::kEmptyString) {
    tournamentname_ = new ::std::string;
  }
  tournamentname_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_tournamentname(const char* value, size_t size) {
  set_has_tournamentname();
  if (tournamentname_ == &::google::protobuf::internal::kEmptyString) {
    tournamentname_ = new ::std::string;
  }
  tournamentname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentRewardDetailCommand::mutable_tournamentname() {
  set_has_tournamentname();
  if (tournamentname_ == &::google::protobuf::internal::kEmptyString) {
    tournamentname_ = new ::std::string;
  }
  return tournamentname_;
}
inline ::std::string* ResponseTournamentRewardDetailCommand::release_tournamentname() {
  clear_has_tournamentname();
  if (tournamentname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tournamentname_;
    tournamentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string info = 9;
inline bool ResponseTournamentRewardDetailCommand::has_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseTournamentRewardDetailCommand::set_has_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseTournamentRewardDetailCommand::clear_has_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseTournamentRewardDetailCommand::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& ResponseTournamentRewardDetailCommand::info() const {
  return *info_;
}
inline void ResponseTournamentRewardDetailCommand::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void ResponseTournamentRewardDetailCommand::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentRewardDetailCommand::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* ResponseTournamentRewardDetailCommand::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 10;
inline int ResponseTournamentRewardDetailCommand::friendleaderboard_size() const {
  return friendleaderboard_.size();
}
inline void ResponseTournamentRewardDetailCommand::clear_friendleaderboard() {
  friendleaderboard_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& ResponseTournamentRewardDetailCommand::friendleaderboard(int index) const {
  return friendleaderboard_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseTournamentRewardDetailCommand::mutable_friendleaderboard(int index) {
  return friendleaderboard_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseTournamentRewardDetailCommand::add_friendleaderboard() {
  return friendleaderboard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
ResponseTournamentRewardDetailCommand::friendleaderboard() const {
  return friendleaderboard_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
ResponseTournamentRewardDetailCommand::mutable_friendleaderboard() {
  return &friendleaderboard_;
}

// -------------------------------------------------------------------

// responseTournamentRewardCommand

// required int32 rank = 1;
inline bool responseTournamentRewardCommand::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void responseTournamentRewardCommand::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void responseTournamentRewardCommand::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void responseTournamentRewardCommand::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 responseTournamentRewardCommand::rank() const {
  return rank_;
}
inline void responseTournamentRewardCommand::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// optional string money = 2;
inline bool responseTournamentRewardCommand::has_money() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void responseTournamentRewardCommand::set_has_money() {
  _has_bits_[0] |= 0x00000002u;
}
inline void responseTournamentRewardCommand::clear_has_money() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void responseTournamentRewardCommand::clear_money() {
  if (money_ != &::google::protobuf::internal::kEmptyString) {
    money_->clear();
  }
  clear_has_money();
}
inline const ::std::string& responseTournamentRewardCommand::money() const {
  return *money_;
}
inline void responseTournamentRewardCommand::set_money(const ::std::string& value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void responseTournamentRewardCommand::set_money(const char* value) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(value);
}
inline void responseTournamentRewardCommand::set_money(const char* value, size_t size) {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  money_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* responseTournamentRewardCommand::mutable_money() {
  set_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    money_ = new ::std::string;
  }
  return money_;
}
inline ::std::string* responseTournamentRewardCommand::release_money() {
  clear_has_money();
  if (money_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = money_;
    money_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 moneyIconId = 3;
inline bool responseTournamentRewardCommand::has_moneyiconid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void responseTournamentRewardCommand::set_has_moneyiconid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void responseTournamentRewardCommand::clear_has_moneyiconid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void responseTournamentRewardCommand::clear_moneyiconid() {
  moneyiconid_ = 0;
  clear_has_moneyiconid();
}
inline ::google::protobuf::int32 responseTournamentRewardCommand::moneyiconid() const {
  return moneyiconid_;
}
inline void responseTournamentRewardCommand::set_moneyiconid(::google::protobuf::int32 value) {
  set_has_moneyiconid();
  moneyiconid_ = value;
}

// optional string rmb = 4;
inline bool responseTournamentRewardCommand::has_rmb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void responseTournamentRewardCommand::set_has_rmb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void responseTournamentRewardCommand::clear_has_rmb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void responseTournamentRewardCommand::clear_rmb() {
  if (rmb_ != &::google::protobuf::internal::kEmptyString) {
    rmb_->clear();
  }
  clear_has_rmb();
}
inline const ::std::string& responseTournamentRewardCommand::rmb() const {
  return *rmb_;
}
inline void responseTournamentRewardCommand::set_rmb(const ::std::string& value) {
  set_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    rmb_ = new ::std::string;
  }
  rmb_->assign(value);
}
inline void responseTournamentRewardCommand::set_rmb(const char* value) {
  set_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    rmb_ = new ::std::string;
  }
  rmb_->assign(value);
}
inline void responseTournamentRewardCommand::set_rmb(const char* value, size_t size) {
  set_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    rmb_ = new ::std::string;
  }
  rmb_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* responseTournamentRewardCommand::mutable_rmb() {
  set_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    rmb_ = new ::std::string;
  }
  return rmb_;
}
inline ::std::string* responseTournamentRewardCommand::release_rmb() {
  clear_has_rmb();
  if (rmb_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rmb_;
    rmb_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 goldIconId = 5;
inline bool responseTournamentRewardCommand::has_goldiconid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void responseTournamentRewardCommand::set_has_goldiconid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void responseTournamentRewardCommand::clear_has_goldiconid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void responseTournamentRewardCommand::clear_goldiconid() {
  goldiconid_ = 0;
  clear_has_goldiconid();
}
inline ::google::protobuf::int32 responseTournamentRewardCommand::goldiconid() const {
  return goldiconid_;
}
inline void responseTournamentRewardCommand::set_goldiconid(::google::protobuf::int32 value) {
  set_has_goldiconid();
  goldiconid_ = value;
}

// optional string displayName = 6;
inline bool responseTournamentRewardCommand::has_displayname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void responseTournamentRewardCommand::set_has_displayname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void responseTournamentRewardCommand::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void responseTournamentRewardCommand::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& responseTournamentRewardCommand::displayname() const {
  return *displayname_;
}
inline void responseTournamentRewardCommand::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void responseTournamentRewardCommand::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void responseTournamentRewardCommand::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* responseTournamentRewardCommand::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* responseTournamentRewardCommand::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isGet = 7;
inline bool responseTournamentRewardCommand::has_isget() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void responseTournamentRewardCommand::set_has_isget() {
  _has_bits_[0] |= 0x00000040u;
}
inline void responseTournamentRewardCommand::clear_has_isget() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void responseTournamentRewardCommand::clear_isget() {
  isget_ = false;
  clear_has_isget();
}
inline bool responseTournamentRewardCommand::isget() const {
  return isget_;
}
inline void responseTournamentRewardCommand::set_isget(bool value) {
  set_has_isget();
  isget_ = value;
}

// -------------------------------------------------------------------

// RequestTournamentSignUpCommand

// required int32 tournamentOnlineId = 1;
inline bool RequestTournamentSignUpCommand::has_tournamentonlineid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestTournamentSignUpCommand::set_has_tournamentonlineid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestTournamentSignUpCommand::clear_has_tournamentonlineid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestTournamentSignUpCommand::clear_tournamentonlineid() {
  tournamentonlineid_ = 0;
  clear_has_tournamentonlineid();
}
inline ::google::protobuf::int32 RequestTournamentSignUpCommand::tournamentonlineid() const {
  return tournamentonlineid_;
}
inline void RequestTournamentSignUpCommand::set_tournamentonlineid(::google::protobuf::int32 value) {
  set_has_tournamentonlineid();
  tournamentonlineid_ = value;
}

// -------------------------------------------------------------------

// ResponseTournamentSignUpCommand

// required int32 result = 1;
inline bool ResponseTournamentSignUpCommand::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseTournamentSignUpCommand::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseTournamentSignUpCommand::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseTournamentSignUpCommand::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseTournamentSignUpCommand::result() const {
  return result_;
}
inline void ResponseTournamentSignUpCommand::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// RequestTournamentDetailCommand

// required int32 tournamentOnlineId = 2;
inline bool RequestTournamentDetailCommand::has_tournamentonlineid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestTournamentDetailCommand::set_has_tournamentonlineid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestTournamentDetailCommand::clear_has_tournamentonlineid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestTournamentDetailCommand::clear_tournamentonlineid() {
  tournamentonlineid_ = 0;
  clear_has_tournamentonlineid();
}
inline ::google::protobuf::int32 RequestTournamentDetailCommand::tournamentonlineid() const {
  return tournamentonlineid_;
}
inline void RequestTournamentDetailCommand::set_tournamentonlineid(::google::protobuf::int32 value) {
  set_has_tournamentonlineid();
  tournamentonlineid_ = value;
}

// optional int32 raceType = 3;
inline bool RequestTournamentDetailCommand::has_racetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestTournamentDetailCommand::set_has_racetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestTournamentDetailCommand::clear_has_racetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestTournamentDetailCommand::clear_racetype() {
  racetype_ = 0;
  clear_has_racetype();
}
inline ::google::protobuf::int32 RequestTournamentDetailCommand::racetype() const {
  return racetype_;
}
inline void RequestTournamentDetailCommand::set_racetype(::google::protobuf::int32 value) {
  set_has_racetype();
  racetype_ = value;
}

// -------------------------------------------------------------------

// ResponseTournamentDetailCommand

// repeated .com.ea.eamobile.nfsmw.protoc.TournamentDetailMessage tournamentDetail = 1;
inline int ResponseTournamentDetailCommand::tournamentdetail_size() const {
  return tournamentdetail_.size();
}
inline void ResponseTournamentDetailCommand::clear_tournamentdetail() {
  tournamentdetail_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage& ResponseTournamentDetailCommand::tournamentdetail(int index) const {
  return tournamentdetail_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage* ResponseTournamentDetailCommand::mutable_tournamentdetail(int index) {
  return tournamentdetail_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage* ResponseTournamentDetailCommand::add_tournamentdetail() {
  return tournamentdetail_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage >&
ResponseTournamentDetailCommand::tournamentdetail() const {
  return tournamentdetail_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailMessage >*
ResponseTournamentDetailCommand::mutable_tournamentdetail() {
  return &tournamentdetail_;
}

// optional int32 selfRank = 2;
inline bool ResponseTournamentDetailCommand::has_selfrank() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_selfrank() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseTournamentDetailCommand::clear_has_selfrank() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseTournamentDetailCommand::clear_selfrank() {
  selfrank_ = 0;
  clear_has_selfrank();
}
inline ::google::protobuf::int32 ResponseTournamentDetailCommand::selfrank() const {
  return selfrank_;
}
inline void ResponseTournamentDetailCommand::set_selfrank(::google::protobuf::int32 value) {
  set_has_selfrank();
  selfrank_ = value;
}

// optional string selfName = 3;
inline bool ResponseTournamentDetailCommand::has_selfname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_selfname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseTournamentDetailCommand::clear_has_selfname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseTournamentDetailCommand::clear_selfname() {
  if (selfname_ != &::google::protobuf::internal::kEmptyString) {
    selfname_->clear();
  }
  clear_has_selfname();
}
inline const ::std::string& ResponseTournamentDetailCommand::selfname() const {
  return *selfname_;
}
inline void ResponseTournamentDetailCommand::set_selfname(const ::std::string& value) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_selfname(const char* value) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_selfname(const char* value, size_t size) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_selfname() {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  return selfname_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_selfname() {
  clear_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfname_;
    selfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float selfRaceTime = 4;
inline bool ResponseTournamentDetailCommand::has_selfracetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_selfracetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseTournamentDetailCommand::clear_has_selfracetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseTournamentDetailCommand::clear_selfracetime() {
  selfracetime_ = 0;
  clear_has_selfracetime();
}
inline float ResponseTournamentDetailCommand::selfracetime() const {
  return selfracetime_;
}
inline void ResponseTournamentDetailCommand::set_selfracetime(float value) {
  set_has_selfracetime();
  selfracetime_ = value;
}

// optional int32 selfHeadIndex = 6;
inline bool ResponseTournamentDetailCommand::has_selfheadindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_selfheadindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseTournamentDetailCommand::clear_has_selfheadindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseTournamentDetailCommand::clear_selfheadindex() {
  selfheadindex_ = 0;
  clear_has_selfheadindex();
}
inline ::google::protobuf::int32 ResponseTournamentDetailCommand::selfheadindex() const {
  return selfheadindex_;
}
inline void ResponseTournamentDetailCommand::set_selfheadindex(::google::protobuf::int32 value) {
  set_has_selfheadindex();
  selfheadindex_ = value;
}

// optional string selfHeadUrl = 7;
inline bool ResponseTournamentDetailCommand::has_selfheadurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_selfheadurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseTournamentDetailCommand::clear_has_selfheadurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseTournamentDetailCommand::clear_selfheadurl() {
  if (selfheadurl_ != &::google::protobuf::internal::kEmptyString) {
    selfheadurl_->clear();
  }
  clear_has_selfheadurl();
}
inline const ::std::string& ResponseTournamentDetailCommand::selfheadurl() const {
  return *selfheadurl_;
}
inline void ResponseTournamentDetailCommand::set_selfheadurl(const ::std::string& value) {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  selfheadurl_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_selfheadurl(const char* value) {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  selfheadurl_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_selfheadurl(const char* value, size_t size) {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  selfheadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_selfheadurl() {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  return selfheadurl_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_selfheadurl() {
  clear_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfheadurl_;
    selfheadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 tournamentSignUpPrice = 11;
inline bool ResponseTournamentDetailCommand::has_tournamentsignupprice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_tournamentsignupprice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseTournamentDetailCommand::clear_has_tournamentsignupprice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseTournamentDetailCommand::clear_tournamentsignupprice() {
  tournamentsignupprice_ = 0;
  clear_has_tournamentsignupprice();
}
inline ::google::protobuf::int32 ResponseTournamentDetailCommand::tournamentsignupprice() const {
  return tournamentsignupprice_;
}
inline void ResponseTournamentDetailCommand::set_tournamentsignupprice(::google::protobuf::int32 value) {
  set_has_tournamentsignupprice();
  tournamentsignupprice_ = value;
}

// required string tournamentGroup = 12;
inline bool ResponseTournamentDetailCommand::has_tournamentgroup() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_tournamentgroup() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseTournamentDetailCommand::clear_has_tournamentgroup() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseTournamentDetailCommand::clear_tournamentgroup() {
  if (tournamentgroup_ != &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_->clear();
  }
  clear_has_tournamentgroup();
}
inline const ::std::string& ResponseTournamentDetailCommand::tournamentgroup() const {
  return *tournamentgroup_;
}
inline void ResponseTournamentDetailCommand::set_tournamentgroup(const ::std::string& value) {
  set_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_ = new ::std::string;
  }
  tournamentgroup_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_tournamentgroup(const char* value) {
  set_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_ = new ::std::string;
  }
  tournamentgroup_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_tournamentgroup(const char* value, size_t size) {
  set_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_ = new ::std::string;
  }
  tournamentgroup_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_tournamentgroup() {
  set_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    tournamentgroup_ = new ::std::string;
  }
  return tournamentgroup_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_tournamentgroup() {
  clear_has_tournamentgroup();
  if (tournamentgroup_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tournamentgroup_;
    tournamentgroup_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string tournamentDescription = 13;
inline bool ResponseTournamentDetailCommand::has_tournamentdescription() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_tournamentdescription() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseTournamentDetailCommand::clear_has_tournamentdescription() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseTournamentDetailCommand::clear_tournamentdescription() {
  if (tournamentdescription_ != &::google::protobuf::internal::kEmptyString) {
    tournamentdescription_->clear();
  }
  clear_has_tournamentdescription();
}
inline const ::std::string& ResponseTournamentDetailCommand::tournamentdescription() const {
  return *tournamentdescription_;
}
inline void ResponseTournamentDetailCommand::set_tournamentdescription(const ::std::string& value) {
  set_has_tournamentdescription();
  if (tournamentdescription_ == &::google::protobuf::internal::kEmptyString) {
    tournamentdescription_ = new ::std::string;
  }
  tournamentdescription_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_tournamentdescription(const char* value) {
  set_has_tournamentdescription();
  if (tournamentdescription_ == &::google::protobuf::internal::kEmptyString) {
    tournamentdescription_ = new ::std::string;
  }
  tournamentdescription_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_tournamentdescription(const char* value, size_t size) {
  set_has_tournamentdescription();
  if (tournamentdescription_ == &::google::protobuf::internal::kEmptyString) {
    tournamentdescription_ = new ::std::string;
  }
  tournamentdescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_tournamentdescription() {
  set_has_tournamentdescription();
  if (tournamentdescription_ == &::google::protobuf::internal::kEmptyString) {
    tournamentdescription_ = new ::std::string;
  }
  return tournamentdescription_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_tournamentdescription() {
  clear_has_tournamentdescription();
  if (tournamentdescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tournamentdescription_;
    tournamentdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string tournamentCarName = 14;
inline int ResponseTournamentDetailCommand::tournamentcarname_size() const {
  return tournamentcarname_.size();
}
inline void ResponseTournamentDetailCommand::clear_tournamentcarname() {
  tournamentcarname_.Clear();
}
inline const ::std::string& ResponseTournamentDetailCommand::tournamentcarname(int index) const {
  return tournamentcarname_.Get(index);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_tournamentcarname(int index) {
  return tournamentcarname_.Mutable(index);
}
inline void ResponseTournamentDetailCommand::set_tournamentcarname(int index, const ::std::string& value) {
  tournamentcarname_.Mutable(index)->assign(value);
}
inline void ResponseTournamentDetailCommand::set_tournamentcarname(int index, const char* value) {
  tournamentcarname_.Mutable(index)->assign(value);
}
inline void ResponseTournamentDetailCommand::set_tournamentcarname(int index, const char* value, size_t size) {
  tournamentcarname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::add_tournamentcarname() {
  return tournamentcarname_.Add();
}
inline void ResponseTournamentDetailCommand::add_tournamentcarname(const ::std::string& value) {
  tournamentcarname_.Add()->assign(value);
}
inline void ResponseTournamentDetailCommand::add_tournamentcarname(const char* value) {
  tournamentcarname_.Add()->assign(value);
}
inline void ResponseTournamentDetailCommand::add_tournamentcarname(const char* value, size_t size) {
  tournamentcarname_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseTournamentDetailCommand::tournamentcarname() const {
  return tournamentcarname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseTournamentDetailCommand::mutable_tournamentcarname() {
  return &tournamentcarname_;
}

// repeated .com.ea.eamobile.nfsmw.protoc.TournamentDetailRewardMessage detailReward = 15;
inline int ResponseTournamentDetailCommand::detailreward_size() const {
  return detailreward_.size();
}
inline void ResponseTournamentDetailCommand::clear_detailreward() {
  detailreward_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage& ResponseTournamentDetailCommand::detailreward(int index) const {
  return detailreward_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage* ResponseTournamentDetailCommand::mutable_detailreward(int index) {
  return detailreward_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage* ResponseTournamentDetailCommand::add_detailreward() {
  return detailreward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage >&
ResponseTournamentDetailCommand::detailreward() const {
  return detailreward_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage >*
ResponseTournamentDetailCommand::mutable_detailreward() {
  return &detailreward_;
}

// required int32 ishasCar = 16;
inline bool ResponseTournamentDetailCommand::has_ishascar() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_ishascar() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResponseTournamentDetailCommand::clear_has_ishascar() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResponseTournamentDetailCommand::clear_ishascar() {
  ishascar_ = 0;
  clear_has_ishascar();
}
inline ::google::protobuf::int32 ResponseTournamentDetailCommand::ishascar() const {
  return ishascar_;
}
inline void ResponseTournamentDetailCommand::set_ishascar(::google::protobuf::int32 value) {
  set_has_ishascar();
  ishascar_ = value;
}

// repeated string carIDs = 17;
inline int ResponseTournamentDetailCommand::carids_size() const {
  return carids_.size();
}
inline void ResponseTournamentDetailCommand::clear_carids() {
  carids_.Clear();
}
inline const ::std::string& ResponseTournamentDetailCommand::carids(int index) const {
  return carids_.Get(index);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_carids(int index) {
  return carids_.Mutable(index);
}
inline void ResponseTournamentDetailCommand::set_carids(int index, const ::std::string& value) {
  carids_.Mutable(index)->assign(value);
}
inline void ResponseTournamentDetailCommand::set_carids(int index, const char* value) {
  carids_.Mutable(index)->assign(value);
}
inline void ResponseTournamentDetailCommand::set_carids(int index, const char* value, size_t size) {
  carids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::add_carids() {
  return carids_.Add();
}
inline void ResponseTournamentDetailCommand::add_carids(const ::std::string& value) {
  carids_.Add()->assign(value);
}
inline void ResponseTournamentDetailCommand::add_carids(const char* value) {
  carids_.Add()->assign(value);
}
inline void ResponseTournamentDetailCommand::add_carids(const char* value, size_t size) {
  carids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseTournamentDetailCommand::carids() const {
  return carids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseTournamentDetailCommand::mutable_carids() {
  return &carids_;
}

// optional string hotRideCarId = 18;
inline bool ResponseTournamentDetailCommand::has_hotridecarid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_hotridecarid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResponseTournamentDetailCommand::clear_has_hotridecarid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResponseTournamentDetailCommand::clear_hotridecarid() {
  if (hotridecarid_ != &::google::protobuf::internal::kEmptyString) {
    hotridecarid_->clear();
  }
  clear_has_hotridecarid();
}
inline const ::std::string& ResponseTournamentDetailCommand::hotridecarid() const {
  return *hotridecarid_;
}
inline void ResponseTournamentDetailCommand::set_hotridecarid(const ::std::string& value) {
  set_has_hotridecarid();
  if (hotridecarid_ == &::google::protobuf::internal::kEmptyString) {
    hotridecarid_ = new ::std::string;
  }
  hotridecarid_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_hotridecarid(const char* value) {
  set_has_hotridecarid();
  if (hotridecarid_ == &::google::protobuf::internal::kEmptyString) {
    hotridecarid_ = new ::std::string;
  }
  hotridecarid_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_hotridecarid(const char* value, size_t size) {
  set_has_hotridecarid();
  if (hotridecarid_ == &::google::protobuf::internal::kEmptyString) {
    hotridecarid_ = new ::std::string;
  }
  hotridecarid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_hotridecarid() {
  set_has_hotridecarid();
  if (hotridecarid_ == &::google::protobuf::internal::kEmptyString) {
    hotridecarid_ = new ::std::string;
  }
  return hotridecarid_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_hotridecarid() {
  clear_has_hotridecarid();
  if (hotridecarid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hotridecarid_;
    hotridecarid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isNotConsumable = 19;
inline bool ResponseTournamentDetailCommand::has_isnotconsumable() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_isnotconsumable() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ResponseTournamentDetailCommand::clear_has_isnotconsumable() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ResponseTournamentDetailCommand::clear_isnotconsumable() {
  isnotconsumable_ = false;
  clear_has_isnotconsumable();
}
inline bool ResponseTournamentDetailCommand::isnotconsumable() const {
  return isnotconsumable_;
}
inline void ResponseTournamentDetailCommand::set_isnotconsumable(bool value) {
  set_has_isnotconsumable();
  isnotconsumable_ = value;
}

// optional string weiboContent = 20;
inline bool ResponseTournamentDetailCommand::has_weibocontent() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_weibocontent() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ResponseTournamentDetailCommand::clear_has_weibocontent() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ResponseTournamentDetailCommand::clear_weibocontent() {
  if (weibocontent_ != &::google::protobuf::internal::kEmptyString) {
    weibocontent_->clear();
  }
  clear_has_weibocontent();
}
inline const ::std::string& ResponseTournamentDetailCommand::weibocontent() const {
  return *weibocontent_;
}
inline void ResponseTournamentDetailCommand::set_weibocontent(const ::std::string& value) {
  set_has_weibocontent();
  if (weibocontent_ == &::google::protobuf::internal::kEmptyString) {
    weibocontent_ = new ::std::string;
  }
  weibocontent_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_weibocontent(const char* value) {
  set_has_weibocontent();
  if (weibocontent_ == &::google::protobuf::internal::kEmptyString) {
    weibocontent_ = new ::std::string;
  }
  weibocontent_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_weibocontent(const char* value, size_t size) {
  set_has_weibocontent();
  if (weibocontent_ == &::google::protobuf::internal::kEmptyString) {
    weibocontent_ = new ::std::string;
  }
  weibocontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_weibocontent() {
  set_has_weibocontent();
  if (weibocontent_ == &::google::protobuf::internal::kEmptyString) {
    weibocontent_ = new ::std::string;
  }
  return weibocontent_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_weibocontent() {
  clear_has_weibocontent();
  if (weibocontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weibocontent_;
    weibocontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string hint = 21;
inline bool ResponseTournamentDetailCommand::has_hint() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_hint() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ResponseTournamentDetailCommand::clear_has_hint() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ResponseTournamentDetailCommand::clear_hint() {
  if (hint_ != &::google::protobuf::internal::kEmptyString) {
    hint_->clear();
  }
  clear_has_hint();
}
inline const ::std::string& ResponseTournamentDetailCommand::hint() const {
  return *hint_;
}
inline void ResponseTournamentDetailCommand::set_hint(const ::std::string& value) {
  set_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    hint_ = new ::std::string;
  }
  hint_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_hint(const char* value) {
  set_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    hint_ = new ::std::string;
  }
  hint_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_hint(const char* value, size_t size) {
  set_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    hint_ = new ::std::string;
  }
  hint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_hint() {
  set_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    hint_ = new ::std::string;
  }
  return hint_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_hint() {
  clear_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hint_;
    hint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .com.ea.eamobile.nfsmw.protoc.Leaderboard friendLeaderboard = 22;
inline int ResponseTournamentDetailCommand::friendleaderboard_size() const {
  return friendleaderboard_.size();
}
inline void ResponseTournamentDetailCommand::clear_friendleaderboard() {
  friendleaderboard_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Leaderboard& ResponseTournamentDetailCommand::friendleaderboard(int index) const {
  return friendleaderboard_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseTournamentDetailCommand::mutable_friendleaderboard(int index) {
  return friendleaderboard_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Leaderboard* ResponseTournamentDetailCommand::add_friendleaderboard() {
  return friendleaderboard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >&
ResponseTournamentDetailCommand::friendleaderboard() const {
  return friendleaderboard_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Leaderboard >*
ResponseTournamentDetailCommand::mutable_friendleaderboard() {
  return &friendleaderboard_;
}

// optional string startContent = 23;
inline bool ResponseTournamentDetailCommand::has_startcontent() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_startcontent() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ResponseTournamentDetailCommand::clear_has_startcontent() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ResponseTournamentDetailCommand::clear_startcontent() {
  if (startcontent_ != &::google::protobuf::internal::kEmptyString) {
    startcontent_->clear();
  }
  clear_has_startcontent();
}
inline const ::std::string& ResponseTournamentDetailCommand::startcontent() const {
  return *startcontent_;
}
inline void ResponseTournamentDetailCommand::set_startcontent(const ::std::string& value) {
  set_has_startcontent();
  if (startcontent_ == &::google::protobuf::internal::kEmptyString) {
    startcontent_ = new ::std::string;
  }
  startcontent_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_startcontent(const char* value) {
  set_has_startcontent();
  if (startcontent_ == &::google::protobuf::internal::kEmptyString) {
    startcontent_ = new ::std::string;
  }
  startcontent_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_startcontent(const char* value, size_t size) {
  set_has_startcontent();
  if (startcontent_ == &::google::protobuf::internal::kEmptyString) {
    startcontent_ = new ::std::string;
  }
  startcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_startcontent() {
  set_has_startcontent();
  if (startcontent_ == &::google::protobuf::internal::kEmptyString) {
    startcontent_ = new ::std::string;
  }
  return startcontent_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_startcontent() {
  clear_has_startcontent();
  if (startcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startcontent_;
    startcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string endContent = 24;
inline bool ResponseTournamentDetailCommand::has_endcontent() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_endcontent() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ResponseTournamentDetailCommand::clear_has_endcontent() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ResponseTournamentDetailCommand::clear_endcontent() {
  if (endcontent_ != &::google::protobuf::internal::kEmptyString) {
    endcontent_->clear();
  }
  clear_has_endcontent();
}
inline const ::std::string& ResponseTournamentDetailCommand::endcontent() const {
  return *endcontent_;
}
inline void ResponseTournamentDetailCommand::set_endcontent(const ::std::string& value) {
  set_has_endcontent();
  if (endcontent_ == &::google::protobuf::internal::kEmptyString) {
    endcontent_ = new ::std::string;
  }
  endcontent_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_endcontent(const char* value) {
  set_has_endcontent();
  if (endcontent_ == &::google::protobuf::internal::kEmptyString) {
    endcontent_ = new ::std::string;
  }
  endcontent_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_endcontent(const char* value, size_t size) {
  set_has_endcontent();
  if (endcontent_ == &::google::protobuf::internal::kEmptyString) {
    endcontent_ = new ::std::string;
  }
  endcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_endcontent() {
  set_has_endcontent();
  if (endcontent_ == &::google::protobuf::internal::kEmptyString) {
    endcontent_ = new ::std::string;
  }
  return endcontent_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_endcontent() {
  clear_has_endcontent();
  if (endcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endcontent_;
    endcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string weiboShareContent = 25;
inline bool ResponseTournamentDetailCommand::has_weibosharecontent() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_weibosharecontent() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ResponseTournamentDetailCommand::clear_has_weibosharecontent() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ResponseTournamentDetailCommand::clear_weibosharecontent() {
  if (weibosharecontent_ != &::google::protobuf::internal::kEmptyString) {
    weibosharecontent_->clear();
  }
  clear_has_weibosharecontent();
}
inline const ::std::string& ResponseTournamentDetailCommand::weibosharecontent() const {
  return *weibosharecontent_;
}
inline void ResponseTournamentDetailCommand::set_weibosharecontent(const ::std::string& value) {
  set_has_weibosharecontent();
  if (weibosharecontent_ == &::google::protobuf::internal::kEmptyString) {
    weibosharecontent_ = new ::std::string;
  }
  weibosharecontent_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_weibosharecontent(const char* value) {
  set_has_weibosharecontent();
  if (weibosharecontent_ == &::google::protobuf::internal::kEmptyString) {
    weibosharecontent_ = new ::std::string;
  }
  weibosharecontent_->assign(value);
}
inline void ResponseTournamentDetailCommand::set_weibosharecontent(const char* value, size_t size) {
  set_has_weibosharecontent();
  if (weibosharecontent_ == &::google::protobuf::internal::kEmptyString) {
    weibosharecontent_ = new ::std::string;
  }
  weibosharecontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentDetailCommand::mutable_weibosharecontent() {
  set_has_weibosharecontent();
  if (weibosharecontent_ == &::google::protobuf::internal::kEmptyString) {
    weibosharecontent_ = new ::std::string;
  }
  return weibosharecontent_;
}
inline ::std::string* ResponseTournamentDetailCommand::release_weibosharecontent() {
  clear_has_weibosharecontent();
  if (weibosharecontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weibosharecontent_;
    weibosharecontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 tournamentOnlineId = 26;
inline bool ResponseTournamentDetailCommand::has_tournamentonlineid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_tournamentonlineid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ResponseTournamentDetailCommand::clear_has_tournamentonlineid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ResponseTournamentDetailCommand::clear_tournamentonlineid() {
  tournamentonlineid_ = 0;
  clear_has_tournamentonlineid();
}
inline ::google::protobuf::int32 ResponseTournamentDetailCommand::tournamentonlineid() const {
  return tournamentonlineid_;
}
inline void ResponseTournamentDetailCommand::set_tournamentonlineid(::google::protobuf::int32 value) {
  set_has_tournamentonlineid();
  tournamentonlineid_ = value;
}

// optional int32 tournamentGroupId = 27;
inline bool ResponseTournamentDetailCommand::has_tournamentgroupid() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ResponseTournamentDetailCommand::set_has_tournamentgroupid() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ResponseTournamentDetailCommand::clear_has_tournamentgroupid() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ResponseTournamentDetailCommand::clear_tournamentgroupid() {
  tournamentgroupid_ = 0;
  clear_has_tournamentgroupid();
}
inline ::google::protobuf::int32 ResponseTournamentDetailCommand::tournamentgroupid() const {
  return tournamentgroupid_;
}
inline void ResponseTournamentDetailCommand::set_tournamentgroupid(::google::protobuf::int32 value) {
  set_has_tournamentgroupid();
  tournamentgroupid_ = value;
}

// -------------------------------------------------------------------

// RequestGetRewardCommand

// required int32 tournamentOnlineId = 2;
inline bool RequestGetRewardCommand::has_tournamentonlineid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGetRewardCommand::set_has_tournamentonlineid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGetRewardCommand::clear_has_tournamentonlineid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGetRewardCommand::clear_tournamentonlineid() {
  tournamentonlineid_ = 0;
  clear_has_tournamentonlineid();
}
inline ::google::protobuf::int32 RequestGetRewardCommand::tournamentonlineid() const {
  return tournamentonlineid_;
}
inline void RequestGetRewardCommand::set_tournamentonlineid(::google::protobuf::int32 value) {
  set_has_tournamentonlineid();
  tournamentonlineid_ = value;
}

// -------------------------------------------------------------------

// ResponseGetRewardCommand

// required int32 success = 2;
inline bool ResponseGetRewardCommand::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGetRewardCommand::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGetRewardCommand::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGetRewardCommand::clear_success() {
  success_ = 0;
  clear_has_success();
}
inline ::google::protobuf::int32 ResponseGetRewardCommand::success() const {
  return success_;
}
inline void ResponseGetRewardCommand::set_success(::google::protobuf::int32 value) {
  set_has_success();
  success_ = value;
}

// optional string errorMessage = 3;
inline bool ResponseGetRewardCommand::has_errormessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseGetRewardCommand::set_has_errormessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseGetRewardCommand::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseGetRewardCommand::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& ResponseGetRewardCommand::errormessage() const {
  return *errormessage_;
}
inline void ResponseGetRewardCommand::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void ResponseGetRewardCommand::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void ResponseGetRewardCommand::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseGetRewardCommand::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* ResponseGetRewardCommand::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// HeadInfo

// required int32 version = 1;
inline bool HeadInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeadInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeadInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeadInfo::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 HeadInfo::version() const {
  return version_;
}
inline void HeadInfo::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// required int64 datetime = 2;
inline bool HeadInfo::has_datetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeadInfo::set_has_datetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeadInfo::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeadInfo::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 HeadInfo::datetime() const {
  return datetime_;
}
inline void HeadInfo::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
}

// required string session = 4;
inline bool HeadInfo::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeadInfo::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeadInfo::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeadInfo::clear_session() {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    session_->clear();
  }
  clear_has_session();
}
inline const ::std::string& HeadInfo::session() const {
  return *session_;
}
inline void HeadInfo::set_session(const ::std::string& value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void HeadInfo::set_session(const char* value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void HeadInfo::set_session(const char* value, size_t size) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* HeadInfo::mutable_session() {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  return session_;
}
inline ::std::string* HeadInfo::release_session() {
  clear_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_;
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 gameVersion = 5;
inline bool HeadInfo::has_gameversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeadInfo::set_has_gameversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeadInfo::clear_has_gameversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeadInfo::clear_gameversion() {
  gameversion_ = 0;
  clear_has_gameversion();
}
inline ::google::protobuf::int32 HeadInfo::gameversion() const {
  return gameversion_;
}
inline void HeadInfo::set_gameversion(::google::protobuf::int32 value) {
  set_has_gameversion();
  gameversion_ = value;
}

// -------------------------------------------------------------------

// RequestRaceStartCommand

// required int32 modeId = 1;
inline bool RequestRaceStartCommand::has_modeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRaceStartCommand::set_has_modeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRaceStartCommand::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRaceStartCommand::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 RequestRaceStartCommand::modeid() const {
  return modeid_;
}
inline void RequestRaceStartCommand::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// required int32 gameMode = 2;
inline bool RequestRaceStartCommand::has_gamemode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRaceStartCommand::set_has_gamemode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRaceStartCommand::clear_has_gamemode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRaceStartCommand::clear_gamemode() {
  gamemode_ = 0;
  clear_has_gamemode();
}
inline ::google::protobuf::int32 RequestRaceStartCommand::gamemode() const {
  return gamemode_;
}
inline void RequestRaceStartCommand::set_gamemode(::google::protobuf::int32 value) {
  set_has_gamemode();
  gamemode_ = value;
}

// optional int32 raceType = 3;
inline bool RequestRaceStartCommand::has_racetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRaceStartCommand::set_has_racetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRaceStartCommand::clear_has_racetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRaceStartCommand::clear_racetype() {
  racetype_ = 0;
  clear_has_racetype();
}
inline ::google::protobuf::int32 RequestRaceStartCommand::racetype() const {
  return racetype_;
}
inline void RequestRaceStartCommand::set_racetype(::google::protobuf::int32 value) {
  set_has_racetype();
  racetype_ = value;
}

// optional int32 tournamentOnlineId = 4;
inline bool RequestRaceStartCommand::has_tournamentonlineid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRaceStartCommand::set_has_tournamentonlineid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRaceStartCommand::clear_has_tournamentonlineid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRaceStartCommand::clear_tournamentonlineid() {
  tournamentonlineid_ = 0;
  clear_has_tournamentonlineid();
}
inline ::google::protobuf::int32 RequestRaceStartCommand::tournamentonlineid() const {
  return tournamentonlineid_;
}
inline void RequestRaceStartCommand::set_tournamentonlineid(::google::protobuf::int32 value) {
  set_has_tournamentonlineid();
  tournamentonlineid_ = value;
}

// repeated int32 carModType = 5;
inline int RequestRaceStartCommand::carmodtype_size() const {
  return carmodtype_.size();
}
inline void RequestRaceStartCommand::clear_carmodtype() {
  carmodtype_.Clear();
}
inline ::google::protobuf::int32 RequestRaceStartCommand::carmodtype(int index) const {
  return carmodtype_.Get(index);
}
inline void RequestRaceStartCommand::set_carmodtype(int index, ::google::protobuf::int32 value) {
  carmodtype_.Set(index, value);
}
inline void RequestRaceStartCommand::add_carmodtype(::google::protobuf::int32 value) {
  carmodtype_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RequestRaceStartCommand::carmodtype() const {
  return carmodtype_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RequestRaceStartCommand::mutable_carmodtype() {
  return &carmodtype_;
}

// repeated int32 carModSlotID = 6;
inline int RequestRaceStartCommand::carmodslotid_size() const {
  return carmodslotid_.size();
}
inline void RequestRaceStartCommand::clear_carmodslotid() {
  carmodslotid_.Clear();
}
inline ::google::protobuf::int32 RequestRaceStartCommand::carmodslotid(int index) const {
  return carmodslotid_.Get(index);
}
inline void RequestRaceStartCommand::set_carmodslotid(int index, ::google::protobuf::int32 value) {
  carmodslotid_.Set(index, value);
}
inline void RequestRaceStartCommand::add_carmodslotid(::google::protobuf::int32 value) {
  carmodslotid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RequestRaceStartCommand::carmodslotid() const {
  return carmodslotid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RequestRaceStartCommand::mutable_carmodslotid() {
  return &carmodslotid_;
}

// optional string carId = 7;
inline bool RequestRaceStartCommand::has_carid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestRaceStartCommand::set_has_carid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestRaceStartCommand::clear_has_carid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestRaceStartCommand::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& RequestRaceStartCommand::carid() const {
  return *carid_;
}
inline void RequestRaceStartCommand::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestRaceStartCommand::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestRaceStartCommand::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestRaceStartCommand::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* RequestRaceStartCommand::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseRaceStartCommand

// required bool approved = 1;
inline bool ResponseRaceStartCommand::has_approved() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRaceStartCommand::set_has_approved() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRaceStartCommand::clear_has_approved() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRaceStartCommand::clear_approved() {
  approved_ = false;
  clear_has_approved();
}
inline bool ResponseRaceStartCommand::approved() const {
  return approved_;
}
inline void ResponseRaceStartCommand::set_approved(bool value) {
  set_has_approved();
  approved_ = value;
}

// optional int64 stamina = 2;
inline bool ResponseRaceStartCommand::has_stamina() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseRaceStartCommand::set_has_stamina() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseRaceStartCommand::clear_has_stamina() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseRaceStartCommand::clear_stamina() {
  stamina_ = GOOGLE_LONGLONG(0);
  clear_has_stamina();
}
inline ::google::protobuf::int64 ResponseRaceStartCommand::stamina() const {
  return stamina_;
}
inline void ResponseRaceStartCommand::set_stamina(::google::protobuf::int64 value) {
  set_has_stamina();
  stamina_ = value;
}

// optional int32 status = 3;
inline bool ResponseRaceStartCommand::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseRaceStartCommand::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseRaceStartCommand::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseRaceStartCommand::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ResponseRaceStartCommand::status() const {
  return status_;
}
inline void ResponseRaceStartCommand::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string hint = 4;
inline bool ResponseRaceStartCommand::has_hint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseRaceStartCommand::set_has_hint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseRaceStartCommand::clear_has_hint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseRaceStartCommand::clear_hint() {
  if (hint_ != &::google::protobuf::internal::kEmptyString) {
    hint_->clear();
  }
  clear_has_hint();
}
inline const ::std::string& ResponseRaceStartCommand::hint() const {
  return *hint_;
}
inline void ResponseRaceStartCommand::set_hint(const ::std::string& value) {
  set_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    hint_ = new ::std::string;
  }
  hint_->assign(value);
}
inline void ResponseRaceStartCommand::set_hint(const char* value) {
  set_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    hint_ = new ::std::string;
  }
  hint_->assign(value);
}
inline void ResponseRaceStartCommand::set_hint(const char* value, size_t size) {
  set_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    hint_ = new ::std::string;
  }
  hint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseRaceStartCommand::mutable_hint() {
  set_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    hint_ = new ::std::string;
  }
  return hint_;
}
inline ::std::string* ResponseRaceStartCommand::release_hint() {
  clear_has_hint();
  if (hint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hint_;
    hint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 samplePeriod = 5;
inline bool ResponseRaceStartCommand::has_sampleperiod() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseRaceStartCommand::set_has_sampleperiod() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseRaceStartCommand::clear_has_sampleperiod() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseRaceStartCommand::clear_sampleperiod() {
  sampleperiod_ = 0;
  clear_has_sampleperiod();
}
inline ::google::protobuf::int32 ResponseRaceStartCommand::sampleperiod() const {
  return sampleperiod_;
}
inline void ResponseRaceStartCommand::set_sampleperiod(::google::protobuf::int32 value) {
  set_has_sampleperiod();
  sampleperiod_ = value;
}

// -------------------------------------------------------------------

// ResponseTournamentRaceStartCommand

// required string trackName = 1;
inline bool ResponseTournamentRaceStartCommand::has_trackname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseTournamentRaceStartCommand::set_has_trackname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseTournamentRaceStartCommand::clear_has_trackname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseTournamentRaceStartCommand::clear_trackname() {
  if (trackname_ != &::google::protobuf::internal::kEmptyString) {
    trackname_->clear();
  }
  clear_has_trackname();
}
inline const ::std::string& ResponseTournamentRaceStartCommand::trackname() const {
  return *trackname_;
}
inline void ResponseTournamentRaceStartCommand::set_trackname(const ::std::string& value) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(value);
}
inline void ResponseTournamentRaceStartCommand::set_trackname(const char* value) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(value);
}
inline void ResponseTournamentRaceStartCommand::set_trackname(const char* value, size_t size) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentRaceStartCommand::mutable_trackname() {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  return trackname_;
}
inline ::std::string* ResponseTournamentRaceStartCommand::release_trackname() {
  clear_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trackname_;
    trackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .com.ea.eamobile.nfsmw.protoc.Reward reward = 2;
inline int ResponseTournamentRaceStartCommand::reward_size() const {
  return reward_.size();
}
inline void ResponseTournamentRaceStartCommand::clear_reward() {
  reward_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Reward& ResponseTournamentRaceStartCommand::reward(int index) const {
  return reward_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseTournamentRaceStartCommand::mutable_reward(int index) {
  return reward_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseTournamentRaceStartCommand::add_reward() {
  return reward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward >&
ResponseTournamentRaceStartCommand::reward() const {
  return reward_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::Reward >*
ResponseTournamentRaceStartCommand::mutable_reward() {
  return &reward_;
}

// repeated .com.ea.eamobile.nfsmw.protoc.TournamentDetailRewardMessage detailReward = 3;
inline int ResponseTournamentRaceStartCommand::detailreward_size() const {
  return detailreward_.size();
}
inline void ResponseTournamentRaceStartCommand::clear_detailreward() {
  detailreward_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage& ResponseTournamentRaceStartCommand::detailreward(int index) const {
  return detailreward_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage* ResponseTournamentRaceStartCommand::mutable_detailreward(int index) {
  return detailreward_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage* ResponseTournamentRaceStartCommand::add_detailreward() {
  return detailreward_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage >&
ResponseTournamentRaceStartCommand::detailreward() const {
  return detailreward_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::TournamentDetailRewardMessage >*
ResponseTournamentRaceStartCommand::mutable_detailreward() {
  return &detailreward_;
}

// -------------------------------------------------------------------

// AccountInfo

// required int32 type = 1;
inline bool AccountInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AccountInfo::type() const {
  return type_;
}
inline void AccountInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string name = 2;
inline bool AccountInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AccountInfo::name() const {
  return *name_;
}
inline void AccountInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AccountInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AccountInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AccountInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string headUrl = 3;
inline bool AccountInfo::has_headurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountInfo::set_has_headurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountInfo::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountInfo::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& AccountInfo::headurl() const {
  return *headurl_;
}
inline void AccountInfo::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void AccountInfo::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void AccountInfo::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* AccountInfo::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool isExpired = 4;
inline bool AccountInfo::has_isexpired() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountInfo::set_has_isexpired() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountInfo::clear_has_isexpired() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountInfo::clear_isexpired() {
  isexpired_ = false;
  clear_has_isexpired();
}
inline bool AccountInfo::isexpired() const {
  return isexpired_;
}
inline void AccountInfo::set_isexpired(bool value) {
  set_has_isexpired();
  isexpired_ = value;
}

// -------------------------------------------------------------------

// RequestBindingStartCommand

// required string token = 1;
inline bool RequestBindingStartCommand::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBindingStartCommand::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBindingStartCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBindingStartCommand::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& RequestBindingStartCommand::token() const {
  return *token_;
}
inline void RequestBindingStartCommand::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestBindingStartCommand::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestBindingStartCommand::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindingStartCommand::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* RequestBindingStartCommand::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseBindingStartCommand

// required string authUrl = 1;
inline bool ResponseBindingStartCommand::has_authurl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBindingStartCommand::set_has_authurl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBindingStartCommand::clear_has_authurl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBindingStartCommand::clear_authurl() {
  if (authurl_ != &::google::protobuf::internal::kEmptyString) {
    authurl_->clear();
  }
  clear_has_authurl();
}
inline const ::std::string& ResponseBindingStartCommand::authurl() const {
  return *authurl_;
}
inline void ResponseBindingStartCommand::set_authurl(const ::std::string& value) {
  set_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    authurl_ = new ::std::string;
  }
  authurl_->assign(value);
}
inline void ResponseBindingStartCommand::set_authurl(const char* value) {
  set_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    authurl_ = new ::std::string;
  }
  authurl_->assign(value);
}
inline void ResponseBindingStartCommand::set_authurl(const char* value, size_t size) {
  set_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    authurl_ = new ::std::string;
  }
  authurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseBindingStartCommand::mutable_authurl() {
  set_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    authurl_ = new ::std::string;
  }
  return authurl_;
}
inline ::std::string* ResponseBindingStartCommand::release_authurl() {
  clear_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authurl_;
    authurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string closeUrl = 2;
inline bool ResponseBindingStartCommand::has_closeurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseBindingStartCommand::set_has_closeurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseBindingStartCommand::clear_has_closeurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseBindingStartCommand::clear_closeurl() {
  if (closeurl_ != &::google::protobuf::internal::kEmptyString) {
    closeurl_->clear();
  }
  clear_has_closeurl();
}
inline const ::std::string& ResponseBindingStartCommand::closeurl() const {
  return *closeurl_;
}
inline void ResponseBindingStartCommand::set_closeurl(const ::std::string& value) {
  set_has_closeurl();
  if (closeurl_ == &::google::protobuf::internal::kEmptyString) {
    closeurl_ = new ::std::string;
  }
  closeurl_->assign(value);
}
inline void ResponseBindingStartCommand::set_closeurl(const char* value) {
  set_has_closeurl();
  if (closeurl_ == &::google::protobuf::internal::kEmptyString) {
    closeurl_ = new ::std::string;
  }
  closeurl_->assign(value);
}
inline void ResponseBindingStartCommand::set_closeurl(const char* value, size_t size) {
  set_has_closeurl();
  if (closeurl_ == &::google::protobuf::internal::kEmptyString) {
    closeurl_ = new ::std::string;
  }
  closeurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseBindingStartCommand::mutable_closeurl() {
  set_has_closeurl();
  if (closeurl_ == &::google::protobuf::internal::kEmptyString) {
    closeurl_ = new ::std::string;
  }
  return closeurl_;
}
inline ::std::string* ResponseBindingStartCommand::release_closeurl() {
  clear_has_closeurl();
  if (closeurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = closeurl_;
    closeurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestBindingTokenCommand

// required bool isOverride = 1;
inline bool RequestBindingTokenCommand::has_isoverride() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBindingTokenCommand::set_has_isoverride() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBindingTokenCommand::clear_has_isoverride() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBindingTokenCommand::clear_isoverride() {
  isoverride_ = false;
  clear_has_isoverride();
}
inline bool RequestBindingTokenCommand::isoverride() const {
  return isoverride_;
}
inline void RequestBindingTokenCommand::set_isoverride(bool value) {
  set_has_isoverride();
  isoverride_ = value;
}

// required string token = 2;
inline bool RequestBindingTokenCommand::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBindingTokenCommand::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBindingTokenCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBindingTokenCommand::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& RequestBindingTokenCommand::token() const {
  return *token_;
}
inline void RequestBindingTokenCommand::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestBindingTokenCommand::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestBindingTokenCommand::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindingTokenCommand::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* RequestBindingTokenCommand::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string access_token = 3;
inline bool RequestBindingTokenCommand::has_access_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestBindingTokenCommand::set_has_access_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestBindingTokenCommand::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestBindingTokenCommand::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& RequestBindingTokenCommand::access_token() const {
  return *access_token_;
}
inline void RequestBindingTokenCommand::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void RequestBindingTokenCommand::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void RequestBindingTokenCommand::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindingTokenCommand::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  return access_token_;
}
inline ::std::string* RequestBindingTokenCommand::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string uid = 4;
inline bool RequestBindingTokenCommand::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestBindingTokenCommand::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestBindingTokenCommand::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestBindingTokenCommand::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RequestBindingTokenCommand::uid() const {
  return *uid_;
}
inline void RequestBindingTokenCommand::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RequestBindingTokenCommand::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RequestBindingTokenCommand::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindingTokenCommand::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RequestBindingTokenCommand::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string nickname = 5;
inline bool RequestBindingTokenCommand::has_nickname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestBindingTokenCommand::set_has_nickname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestBindingTokenCommand::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestBindingTokenCommand::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RequestBindingTokenCommand::nickname() const {
  return *nickname_;
}
inline void RequestBindingTokenCommand::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RequestBindingTokenCommand::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RequestBindingTokenCommand::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindingTokenCommand::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* RequestBindingTokenCommand::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseBindingTokenCommand

// required string token = 1;
inline bool ResponseBindingTokenCommand::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBindingTokenCommand::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBindingTokenCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBindingTokenCommand::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ResponseBindingTokenCommand::token() const {
  return *token_;
}
inline void ResponseBindingTokenCommand::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ResponseBindingTokenCommand::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ResponseBindingTokenCommand::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseBindingTokenCommand::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ResponseBindingTokenCommand::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestBindingInfoCommand

// required string access_token = 1;
inline bool RequestBindingInfoCommand::has_access_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBindingInfoCommand::set_has_access_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBindingInfoCommand::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBindingInfoCommand::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& RequestBindingInfoCommand::access_token() const {
  return *access_token_;
}
inline void RequestBindingInfoCommand::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void RequestBindingInfoCommand::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void RequestBindingInfoCommand::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindingInfoCommand::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  return access_token_;
}
inline ::std::string* RequestBindingInfoCommand::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string uid = 2;
inline bool RequestBindingInfoCommand::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBindingInfoCommand::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBindingInfoCommand::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBindingInfoCommand::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& RequestBindingInfoCommand::uid() const {
  return *uid_;
}
inline void RequestBindingInfoCommand::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RequestBindingInfoCommand::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void RequestBindingInfoCommand::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindingInfoCommand::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* RequestBindingInfoCommand::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseBindingInfoCommand

// required bool isBinding = 1;
inline bool ResponseBindingInfoCommand::has_isbinding() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBindingInfoCommand::set_has_isbinding() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBindingInfoCommand::clear_has_isbinding() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBindingInfoCommand::clear_isbinding() {
  isbinding_ = false;
  clear_has_isbinding();
}
inline bool ResponseBindingInfoCommand::isbinding() const {
  return isbinding_;
}
inline void ResponseBindingInfoCommand::set_isbinding(bool value) {
  set_has_isbinding();
  isbinding_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingConfirmCommand bindingConfirmCommand = 3;
inline bool ResponseBindingInfoCommand::has_bindingconfirmcommand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseBindingInfoCommand::set_has_bindingconfirmcommand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseBindingInfoCommand::clear_has_bindingconfirmcommand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseBindingInfoCommand::clear_bindingconfirmcommand() {
  if (bindingconfirmcommand_ != NULL) bindingconfirmcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand::Clear();
  clear_has_bindingconfirmcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand& ResponseBindingInfoCommand::bindingconfirmcommand() const {
  return bindingconfirmcommand_ != NULL ? *bindingconfirmcommand_ : *default_instance_->bindingconfirmcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* ResponseBindingInfoCommand::mutable_bindingconfirmcommand() {
  set_has_bindingconfirmcommand();
  if (bindingconfirmcommand_ == NULL) bindingconfirmcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand;
  return bindingconfirmcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* ResponseBindingInfoCommand::release_bindingconfirmcommand() {
  clear_has_bindingconfirmcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* temp = bindingconfirmcommand_;
  bindingconfirmcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.UserInfo userInfo = 4;
inline bool ResponseBindingInfoCommand::has_userinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseBindingInfoCommand::set_has_userinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseBindingInfoCommand::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseBindingInfoCommand::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::com::ea::eamobile::nfsmw::protoc::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::UserInfo& ResponseBindingInfoCommand::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* ResponseBindingInfoCommand::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::com::ea::eamobile::nfsmw::protoc::UserInfo;
  return userinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* ResponseBindingInfoCommand::release_userinfo() {
  clear_has_userinfo();
  ::com::ea::eamobile::nfsmw::protoc::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RequestBindingResultCommand

// required string token = 1;
inline bool RequestBindingResultCommand::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBindingResultCommand::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBindingResultCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBindingResultCommand::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& RequestBindingResultCommand::token() const {
  return *token_;
}
inline void RequestBindingResultCommand::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestBindingResultCommand::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestBindingResultCommand::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindingResultCommand::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* RequestBindingResultCommand::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseBindingResultCommand

// required bool isBinding = 1;
inline bool ResponseBindingResultCommand::has_isbinding() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBindingResultCommand::set_has_isbinding() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBindingResultCommand::clear_has_isbinding() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBindingResultCommand::clear_isbinding() {
  isbinding_ = false;
  clear_has_isbinding();
}
inline bool ResponseBindingResultCommand::isbinding() const {
  return isbinding_;
}
inline void ResponseBindingResultCommand::set_isbinding(bool value) {
  set_has_isbinding();
  isbinding_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingConfirmCommand bindingConfirmCommand = 3;
inline bool ResponseBindingResultCommand::has_bindingconfirmcommand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseBindingResultCommand::set_has_bindingconfirmcommand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseBindingResultCommand::clear_has_bindingconfirmcommand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseBindingResultCommand::clear_bindingconfirmcommand() {
  if (bindingconfirmcommand_ != NULL) bindingconfirmcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand::Clear();
  clear_has_bindingconfirmcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand& ResponseBindingResultCommand::bindingconfirmcommand() const {
  return bindingconfirmcommand_ != NULL ? *bindingconfirmcommand_ : *default_instance_->bindingconfirmcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* ResponseBindingResultCommand::mutable_bindingconfirmcommand() {
  set_has_bindingconfirmcommand();
  if (bindingconfirmcommand_ == NULL) bindingconfirmcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand;
  return bindingconfirmcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* ResponseBindingResultCommand::release_bindingconfirmcommand() {
  clear_has_bindingconfirmcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* temp = bindingconfirmcommand_;
  bindingconfirmcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.UserInfo userInfo = 4;
inline bool ResponseBindingResultCommand::has_userinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseBindingResultCommand::set_has_userinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseBindingResultCommand::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseBindingResultCommand::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::com::ea::eamobile::nfsmw::protoc::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::UserInfo& ResponseBindingResultCommand::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* ResponseBindingResultCommand::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::com::ea::eamobile::nfsmw::protoc::UserInfo;
  return userinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::UserInfo* ResponseBindingResultCommand::release_userinfo() {
  clear_has_userinfo();
  ::com::ea::eamobile::nfsmw::protoc::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RequestBindingConfirmCommand

// required bool isOverride = 1;
inline bool RequestBindingConfirmCommand::has_isoverride() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBindingConfirmCommand::set_has_isoverride() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBindingConfirmCommand::clear_has_isoverride() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBindingConfirmCommand::clear_isoverride() {
  isoverride_ = false;
  clear_has_isoverride();
}
inline bool RequestBindingConfirmCommand::isoverride() const {
  return isoverride_;
}
inline void RequestBindingConfirmCommand::set_isoverride(bool value) {
  set_has_isoverride();
  isoverride_ = value;
}

// required string token = 2;
inline bool RequestBindingConfirmCommand::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestBindingConfirmCommand::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestBindingConfirmCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestBindingConfirmCommand::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& RequestBindingConfirmCommand::token() const {
  return *token_;
}
inline void RequestBindingConfirmCommand::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestBindingConfirmCommand::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void RequestBindingConfirmCommand::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBindingConfirmCommand::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* RequestBindingConfirmCommand::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseBindingConfirmCommand

// required string token = 1;
inline bool ResponseBindingConfirmCommand::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBindingConfirmCommand::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBindingConfirmCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBindingConfirmCommand::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& ResponseBindingConfirmCommand::token() const {
  return *token_;
}
inline void ResponseBindingConfirmCommand::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ResponseBindingConfirmCommand::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void ResponseBindingConfirmCommand::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseBindingConfirmCommand::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* ResponseBindingConfirmCommand::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseBindingPopupCommand

// required bool isPopup = 1;
inline bool ResponseBindingPopupCommand::has_ispopup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBindingPopupCommand::set_has_ispopup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBindingPopupCommand::clear_has_ispopup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBindingPopupCommand::clear_ispopup() {
  ispopup_ = false;
  clear_has_ispopup();
}
inline bool ResponseBindingPopupCommand::ispopup() const {
  return ispopup_;
}
inline void ResponseBindingPopupCommand::set_ispopup(bool value) {
  set_has_ispopup();
  ispopup_ = value;
}

// -------------------------------------------------------------------

// ErrorCommand

// required string code = 1;
inline bool ErrorCommand::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorCommand::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorCommand::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorCommand::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& ErrorCommand::code() const {
  return *code_;
}
inline void ErrorCommand::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void ErrorCommand::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void ErrorCommand::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrorCommand::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* ErrorCommand::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string message = 2;
inline bool ErrorCommand::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorCommand::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrorCommand::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ErrorCommand::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ErrorCommand::message() const {
  return *message_;
}
inline void ErrorCommand::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ErrorCommand::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ErrorCommand::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ErrorCommand::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ErrorCommand::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CarData

// required string carId = 1;
inline bool CarData::has_carid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CarData::set_has_carid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CarData::clear_has_carid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CarData::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& CarData::carid() const {
  return *carid_;
}
inline void CarData::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void CarData::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void CarData::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarData::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* CarData::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 type = 2;
inline bool CarData::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CarData::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CarData::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CarData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 CarData::type() const {
  return type_;
}
inline void CarData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 tier = 3;
inline bool CarData::has_tier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CarData::set_has_tier() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CarData::clear_has_tier() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CarData::clear_tier() {
  tier_ = 0;
  clear_has_tier();
}
inline ::google::protobuf::int32 CarData::tier() const {
  return tier_;
}
inline void CarData::set_tier(::google::protobuf::int32 value) {
  set_has_tier();
  tier_ = value;
}

// required int32 score = 4;
inline bool CarData::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CarData::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CarData::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CarData::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 CarData::score() const {
  return score_;
}
inline void CarData::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// required int32 status = 5;
inline bool CarData::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CarData::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CarData::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CarData::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 CarData::status() const {
  return status_;
}
inline void CarData::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.CarSlotInfo slots = 6;
inline int CarData::slots_size() const {
  return slots_.size();
}
inline void CarData::clear_slots() {
  slots_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo& CarData::slots(int index) const {
  return slots_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo* CarData::mutable_slots(int index) {
  return slots_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo* CarData::add_slots() {
  return slots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo >&
CarData::slots() const {
  return slots_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarSlotInfo >*
CarData::mutable_slots() {
  return &slots_;
}

// required int32 priceType = 7;
inline bool CarData::has_pricetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CarData::set_has_pricetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CarData::clear_has_pricetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CarData::clear_pricetype() {
  pricetype_ = 0;
  clear_has_pricetype();
}
inline ::google::protobuf::int32 CarData::pricetype() const {
  return pricetype_;
}
inline void CarData::set_pricetype(::google::protobuf::int32 value) {
  set_has_pricetype();
  pricetype_ = value;
}

// required int32 price = 8;
inline bool CarData::has_price() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CarData::set_has_price() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CarData::clear_has_price() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CarData::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 CarData::price() const {
  return price_;
}
inline void CarData::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// required int32 unlockMWLevel = 9;
inline bool CarData::has_unlockmwlevel() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CarData::set_has_unlockmwlevel() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CarData::clear_has_unlockmwlevel() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CarData::clear_unlockmwlevel() {
  unlockmwlevel_ = 0;
  clear_has_unlockmwlevel();
}
inline ::google::protobuf::int32 CarData::unlockmwlevel() const {
  return unlockmwlevel_;
}
inline void CarData::set_unlockmwlevel(::google::protobuf::int32 value) {
  set_has_unlockmwlevel();
  unlockmwlevel_ = value;
}

// required int32 chartletId = 10;
inline bool CarData::has_chartletid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CarData::set_has_chartletid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CarData::clear_has_chartletid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CarData::clear_chartletid() {
  chartletid_ = 0;
  clear_has_chartletid();
}
inline ::google::protobuf::int32 CarData::chartletid() const {
  return chartletid_;
}
inline void CarData::set_chartletid(::google::protobuf::int32 value) {
  set_has_chartletid();
  chartletid_ = value;
}

// optional bool isLock = 11;
inline bool CarData::has_islock() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CarData::set_has_islock() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CarData::clear_has_islock() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CarData::clear_islock() {
  islock_ = false;
  clear_has_islock();
}
inline bool CarData::islock() const {
  return islock_;
}
inline void CarData::set_islock(bool value) {
  set_has_islock();
  islock_ = value;
}

// optional int64 remainTime = 13;
inline bool CarData::has_remaintime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CarData::set_has_remaintime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CarData::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CarData::clear_remaintime() {
  remaintime_ = GOOGLE_LONGLONG(0);
  clear_has_remaintime();
}
inline ::google::protobuf::int64 CarData::remaintime() const {
  return remaintime_;
}
inline void CarData::set_remaintime(::google::protobuf::int64 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.ChartletInfo chartletInfos = 14;
inline int CarData::chartletinfos_size() const {
  return chartletinfos_.size();
}
inline void CarData::clear_chartletinfos() {
  chartletinfos_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ChartletInfo& CarData::chartletinfos(int index) const {
  return chartletinfos_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ChartletInfo* CarData::mutable_chartletinfos(int index) {
  return chartletinfos_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ChartletInfo* CarData::add_chartletinfos() {
  return chartletinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ChartletInfo >&
CarData::chartletinfos() const {
  return chartletinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ChartletInfo >*
CarData::mutable_chartletinfos() {
  return &chartletinfos_;
}

// optional int32 sellFlag = 15;
inline bool CarData::has_sellflag() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CarData::set_has_sellflag() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CarData::clear_has_sellflag() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CarData::clear_sellflag() {
  sellflag_ = 0;
  clear_has_sellflag();
}
inline ::google::protobuf::int32 CarData::sellflag() const {
  return sellflag_;
}
inline void CarData::set_sellflag(::google::protobuf::int32 value) {
  set_has_sellflag();
  sellflag_ = value;
}

// optional bool isSpecialCar = 16;
inline bool CarData::has_isspecialcar() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CarData::set_has_isspecialcar() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CarData::clear_has_isspecialcar() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CarData::clear_isspecialcar() {
  isspecialcar_ = false;
  clear_has_isspecialcar();
}
inline bool CarData::isspecialcar() const {
  return isspecialcar_;
}
inline void CarData::set_isspecialcar(bool value) {
  set_has_isspecialcar();
  isspecialcar_ = value;
}

// optional int32 fragmentNumber = 17;
inline bool CarData::has_fragmentnumber() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CarData::set_has_fragmentnumber() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CarData::clear_has_fragmentnumber() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CarData::clear_fragmentnumber() {
  fragmentnumber_ = 0;
  clear_has_fragmentnumber();
}
inline ::google::protobuf::int32 CarData::fragmentnumber() const {
  return fragmentnumber_;
}
inline void CarData::set_fragmentnumber(::google::protobuf::int32 value) {
  set_has_fragmentnumber();
  fragmentnumber_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.GotchaExpense gotchaExpense = 18;
inline int CarData::gotchaexpense_size() const {
  return gotchaexpense_.size();
}
inline void CarData::clear_gotchaexpense() {
  gotchaexpense_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::GotchaExpense& CarData::gotchaexpense(int index) const {
  return gotchaexpense_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::GotchaExpense* CarData::mutable_gotchaexpense(int index) {
  return gotchaexpense_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::GotchaExpense* CarData::add_gotchaexpense() {
  return gotchaexpense_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaExpense >&
CarData::gotchaexpense() const {
  return gotchaexpense_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaExpense >*
CarData::mutable_gotchaexpense() {
  return &gotchaexpense_;
}

// optional int32 totalFragmentNumber = 19;
inline bool CarData::has_totalfragmentnumber() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CarData::set_has_totalfragmentnumber() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CarData::clear_has_totalfragmentnumber() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CarData::clear_totalfragmentnumber() {
  totalfragmentnumber_ = 0;
  clear_has_totalfragmentnumber();
}
inline ::google::protobuf::int32 CarData::totalfragmentnumber() const {
  return totalfragmentnumber_;
}
inline void CarData::set_totalfragmentnumber(::google::protobuf::int32 value) {
  set_has_totalfragmentnumber();
  totalfragmentnumber_ = value;
}

// optional int32 remainPriceType = 20;
inline bool CarData::has_remainpricetype() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CarData::set_has_remainpricetype() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CarData::clear_has_remainpricetype() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CarData::clear_remainpricetype() {
  remainpricetype_ = 0;
  clear_has_remainpricetype();
}
inline ::google::protobuf::int32 CarData::remainpricetype() const {
  return remainpricetype_;
}
inline void CarData::set_remainpricetype(::google::protobuf::int32 value) {
  set_has_remainpricetype();
  remainpricetype_ = value;
}

// optional int32 remainPrice = 21;
inline bool CarData::has_remainprice() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void CarData::set_has_remainprice() {
  _has_bits_[0] |= 0x00080000u;
}
inline void CarData::clear_has_remainprice() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void CarData::clear_remainprice() {
  remainprice_ = 0;
  clear_has_remainprice();
}
inline ::google::protobuf::int32 CarData::remainprice() const {
  return remainprice_;
}
inline void CarData::set_remainprice(::google::protobuf::int32 value) {
  set_has_remainprice();
  remainprice_ = value;
}

// optional int32 maxlimit = 22;
inline bool CarData::has_maxlimit() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void CarData::set_has_maxlimit() {
  _has_bits_[0] |= 0x00100000u;
}
inline void CarData::clear_has_maxlimit() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void CarData::clear_maxlimit() {
  maxlimit_ = 0;
  clear_has_maxlimit();
}
inline ::google::protobuf::int32 CarData::maxlimit() const {
  return maxlimit_;
}
inline void CarData::set_maxlimit(::google::protobuf::int32 value) {
  set_has_maxlimit();
  maxlimit_ = value;
}

// optional int32 limit = 23;
inline bool CarData::has_limit() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void CarData::set_has_limit() {
  _has_bits_[0] |= 0x00200000u;
}
inline void CarData::clear_has_limit() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void CarData::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::google::protobuf::int32 CarData::limit() const {
  return limit_;
}
inline void CarData::set_limit(::google::protobuf::int32 value) {
  set_has_limit();
  limit_ = value;
}

// optional int32 state = 24;
inline bool CarData::has_state() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void CarData::set_has_state() {
  _has_bits_[0] |= 0x00400000u;
}
inline void CarData::clear_has_state() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void CarData::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::google::protobuf::int32 CarData::state() const {
  return state_;
}
inline void CarData::set_state(::google::protobuf::int32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// GotchaExpense

// required int32 level = 1;
inline bool GotchaExpense::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GotchaExpense::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GotchaExpense::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GotchaExpense::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 GotchaExpense::level() const {
  return level_;
}
inline void GotchaExpense::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required int32 price = 2;
inline bool GotchaExpense::has_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GotchaExpense::set_has_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GotchaExpense::clear_has_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GotchaExpense::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 GotchaExpense::price() const {
  return price_;
}
inline void GotchaExpense::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// required int32 priceType = 3;
inline bool GotchaExpense::has_pricetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GotchaExpense::set_has_pricetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GotchaExpense::clear_has_pricetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GotchaExpense::clear_pricetype() {
  pricetype_ = 0;
  clear_has_pricetype();
}
inline ::google::protobuf::int32 GotchaExpense::pricetype() const {
  return pricetype_;
}
inline void GotchaExpense::set_pricetype(::google::protobuf::int32 value) {
  set_has_pricetype();
  pricetype_ = value;
}

// required int32 leftFreeTimes = 4;
inline bool GotchaExpense::has_leftfreetimes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GotchaExpense::set_has_leftfreetimes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GotchaExpense::clear_has_leftfreetimes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GotchaExpense::clear_leftfreetimes() {
  leftfreetimes_ = 0;
  clear_has_leftfreetimes();
}
inline ::google::protobuf::int32 GotchaExpense::leftfreetimes() const {
  return leftfreetimes_;
}
inline void GotchaExpense::set_leftfreetimes(::google::protobuf::int32 value) {
  set_has_leftfreetimes();
  leftfreetimes_ = value;
}

// -------------------------------------------------------------------

// ChartletInfo

// required string name = 1;
inline bool ChartletInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChartletInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChartletInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChartletInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ChartletInfo::name() const {
  return *name_;
}
inline void ChartletInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChartletInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ChartletInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChartletInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ChartletInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string diffuseTexturePath = 2;
inline bool ChartletInfo::has_diffusetexturepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChartletInfo::set_has_diffusetexturepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChartletInfo::clear_has_diffusetexturepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChartletInfo::clear_diffusetexturepath() {
  if (diffusetexturepath_ != &::google::protobuf::internal::kEmptyString) {
    diffusetexturepath_->clear();
  }
  clear_has_diffusetexturepath();
}
inline const ::std::string& ChartletInfo::diffusetexturepath() const {
  return *diffusetexturepath_;
}
inline void ChartletInfo::set_diffusetexturepath(const ::std::string& value) {
  set_has_diffusetexturepath();
  if (diffusetexturepath_ == &::google::protobuf::internal::kEmptyString) {
    diffusetexturepath_ = new ::std::string;
  }
  diffusetexturepath_->assign(value);
}
inline void ChartletInfo::set_diffusetexturepath(const char* value) {
  set_has_diffusetexturepath();
  if (diffusetexturepath_ == &::google::protobuf::internal::kEmptyString) {
    diffusetexturepath_ = new ::std::string;
  }
  diffusetexturepath_->assign(value);
}
inline void ChartletInfo::set_diffusetexturepath(const char* value, size_t size) {
  set_has_diffusetexturepath();
  if (diffusetexturepath_ == &::google::protobuf::internal::kEmptyString) {
    diffusetexturepath_ = new ::std::string;
  }
  diffusetexturepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChartletInfo::mutable_diffusetexturepath() {
  set_has_diffusetexturepath();
  if (diffusetexturepath_ == &::google::protobuf::internal::kEmptyString) {
    diffusetexturepath_ = new ::std::string;
  }
  return diffusetexturepath_;
}
inline ::std::string* ChartletInfo::release_diffusetexturepath() {
  clear_has_diffusetexturepath();
  if (diffusetexturepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = diffusetexturepath_;
    diffusetexturepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string diffuseMaskPath = 3;
inline bool ChartletInfo::has_diffusemaskpath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChartletInfo::set_has_diffusemaskpath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChartletInfo::clear_has_diffusemaskpath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChartletInfo::clear_diffusemaskpath() {
  if (diffusemaskpath_ != &::google::protobuf::internal::kEmptyString) {
    diffusemaskpath_->clear();
  }
  clear_has_diffusemaskpath();
}
inline const ::std::string& ChartletInfo::diffusemaskpath() const {
  return *diffusemaskpath_;
}
inline void ChartletInfo::set_diffusemaskpath(const ::std::string& value) {
  set_has_diffusemaskpath();
  if (diffusemaskpath_ == &::google::protobuf::internal::kEmptyString) {
    diffusemaskpath_ = new ::std::string;
  }
  diffusemaskpath_->assign(value);
}
inline void ChartletInfo::set_diffusemaskpath(const char* value) {
  set_has_diffusemaskpath();
  if (diffusemaskpath_ == &::google::protobuf::internal::kEmptyString) {
    diffusemaskpath_ = new ::std::string;
  }
  diffusemaskpath_->assign(value);
}
inline void ChartletInfo::set_diffusemaskpath(const char* value, size_t size) {
  set_has_diffusemaskpath();
  if (diffusemaskpath_ == &::google::protobuf::internal::kEmptyString) {
    diffusemaskpath_ = new ::std::string;
  }
  diffusemaskpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChartletInfo::mutable_diffusemaskpath() {
  set_has_diffusemaskpath();
  if (diffusemaskpath_ == &::google::protobuf::internal::kEmptyString) {
    diffusemaskpath_ = new ::std::string;
  }
  return diffusemaskpath_;
}
inline ::std::string* ChartletInfo::release_diffusemaskpath() {
  clear_has_diffusemaskpath();
  if (diffusemaskpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = diffusemaskpath_;
    diffusemaskpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string BRDFPath = 4;
inline bool ChartletInfo::has_brdfpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChartletInfo::set_has_brdfpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChartletInfo::clear_has_brdfpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChartletInfo::clear_brdfpath() {
  if (brdfpath_ != &::google::protobuf::internal::kEmptyString) {
    brdfpath_->clear();
  }
  clear_has_brdfpath();
}
inline const ::std::string& ChartletInfo::brdfpath() const {
  return *brdfpath_;
}
inline void ChartletInfo::set_brdfpath(const ::std::string& value) {
  set_has_brdfpath();
  if (brdfpath_ == &::google::protobuf::internal::kEmptyString) {
    brdfpath_ = new ::std::string;
  }
  brdfpath_->assign(value);
}
inline void ChartletInfo::set_brdfpath(const char* value) {
  set_has_brdfpath();
  if (brdfpath_ == &::google::protobuf::internal::kEmptyString) {
    brdfpath_ = new ::std::string;
  }
  brdfpath_->assign(value);
}
inline void ChartletInfo::set_brdfpath(const char* value, size_t size) {
  set_has_brdfpath();
  if (brdfpath_ == &::google::protobuf::internal::kEmptyString) {
    brdfpath_ = new ::std::string;
  }
  brdfpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChartletInfo::mutable_brdfpath() {
  set_has_brdfpath();
  if (brdfpath_ == &::google::protobuf::internal::kEmptyString) {
    brdfpath_ = new ::std::string;
  }
  return brdfpath_;
}
inline ::std::string* ChartletInfo::release_brdfpath() {
  clear_has_brdfpath();
  if (brdfpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brdfpath_;
    brdfpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string BRDFSpecularPath = 5;
inline bool ChartletInfo::has_brdfspecularpath() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChartletInfo::set_has_brdfspecularpath() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChartletInfo::clear_has_brdfspecularpath() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChartletInfo::clear_brdfspecularpath() {
  if (brdfspecularpath_ != &::google::protobuf::internal::kEmptyString) {
    brdfspecularpath_->clear();
  }
  clear_has_brdfspecularpath();
}
inline const ::std::string& ChartletInfo::brdfspecularpath() const {
  return *brdfspecularpath_;
}
inline void ChartletInfo::set_brdfspecularpath(const ::std::string& value) {
  set_has_brdfspecularpath();
  if (brdfspecularpath_ == &::google::protobuf::internal::kEmptyString) {
    brdfspecularpath_ = new ::std::string;
  }
  brdfspecularpath_->assign(value);
}
inline void ChartletInfo::set_brdfspecularpath(const char* value) {
  set_has_brdfspecularpath();
  if (brdfspecularpath_ == &::google::protobuf::internal::kEmptyString) {
    brdfspecularpath_ = new ::std::string;
  }
  brdfspecularpath_->assign(value);
}
inline void ChartletInfo::set_brdfspecularpath(const char* value, size_t size) {
  set_has_brdfspecularpath();
  if (brdfspecularpath_ == &::google::protobuf::internal::kEmptyString) {
    brdfspecularpath_ = new ::std::string;
  }
  brdfspecularpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChartletInfo::mutable_brdfspecularpath() {
  set_has_brdfspecularpath();
  if (brdfspecularpath_ == &::google::protobuf::internal::kEmptyString) {
    brdfspecularpath_ = new ::std::string;
  }
  return brdfspecularpath_;
}
inline ::std::string* ChartletInfo::release_brdfspecularpath() {
  clear_has_brdfspecularpath();
  if (brdfspecularpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brdfspecularpath_;
    brdfspecularpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string numberPlatePath = 6;
inline bool ChartletInfo::has_numberplatepath() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChartletInfo::set_has_numberplatepath() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChartletInfo::clear_has_numberplatepath() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChartletInfo::clear_numberplatepath() {
  if (numberplatepath_ != &::google::protobuf::internal::kEmptyString) {
    numberplatepath_->clear();
  }
  clear_has_numberplatepath();
}
inline const ::std::string& ChartletInfo::numberplatepath() const {
  return *numberplatepath_;
}
inline void ChartletInfo::set_numberplatepath(const ::std::string& value) {
  set_has_numberplatepath();
  if (numberplatepath_ == &::google::protobuf::internal::kEmptyString) {
    numberplatepath_ = new ::std::string;
  }
  numberplatepath_->assign(value);
}
inline void ChartletInfo::set_numberplatepath(const char* value) {
  set_has_numberplatepath();
  if (numberplatepath_ == &::google::protobuf::internal::kEmptyString) {
    numberplatepath_ = new ::std::string;
  }
  numberplatepath_->assign(value);
}
inline void ChartletInfo::set_numberplatepath(const char* value, size_t size) {
  set_has_numberplatepath();
  if (numberplatepath_ == &::google::protobuf::internal::kEmptyString) {
    numberplatepath_ = new ::std::string;
  }
  numberplatepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChartletInfo::mutable_numberplatepath() {
  set_has_numberplatepath();
  if (numberplatepath_ == &::google::protobuf::internal::kEmptyString) {
    numberplatepath_ = new ::std::string;
  }
  return numberplatepath_;
}
inline ::std::string* ChartletInfo::release_numberplatepath() {
  clear_has_numberplatepath();
  if (numberplatepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = numberplatepath_;
    numberplatepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 swatchColor = 7;
inline bool ChartletInfo::has_swatchcolor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChartletInfo::set_has_swatchcolor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChartletInfo::clear_has_swatchcolor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChartletInfo::clear_swatchcolor() {
  swatchcolor_ = GOOGLE_LONGLONG(0);
  clear_has_swatchcolor();
}
inline ::google::protobuf::int64 ChartletInfo::swatchcolor() const {
  return swatchcolor_;
}
inline void ChartletInfo::set_swatchcolor(::google::protobuf::int64 value) {
  set_has_swatchcolor();
  swatchcolor_ = value;
}

// required int64 swatchColor2 = 8;
inline bool ChartletInfo::has_swatchcolor2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChartletInfo::set_has_swatchcolor2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChartletInfo::clear_has_swatchcolor2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChartletInfo::clear_swatchcolor2() {
  swatchcolor2_ = GOOGLE_LONGLONG(0);
  clear_has_swatchcolor2();
}
inline ::google::protobuf::int64 ChartletInfo::swatchcolor2() const {
  return swatchcolor2_;
}
inline void ChartletInfo::set_swatchcolor2(::google::protobuf::int64 value) {
  set_has_swatchcolor2();
  swatchcolor2_ = value;
}

// required int32 paintType = 9;
inline bool ChartletInfo::has_painttype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ChartletInfo::set_has_painttype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ChartletInfo::clear_has_painttype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ChartletInfo::clear_painttype() {
  painttype_ = 0;
  clear_has_painttype();
}
inline ::google::protobuf::int32 ChartletInfo::painttype() const {
  return painttype_;
}
inline void ChartletInfo::set_painttype(::google::protobuf::int32 value) {
  set_has_painttype();
  painttype_ = value;
}

// required bool useVinylMap = 10;
inline bool ChartletInfo::has_usevinylmap() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ChartletInfo::set_has_usevinylmap() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ChartletInfo::clear_has_usevinylmap() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ChartletInfo::clear_usevinylmap() {
  usevinylmap_ = false;
  clear_has_usevinylmap();
}
inline bool ChartletInfo::usevinylmap() const {
  return usevinylmap_;
}
inline void ChartletInfo::set_usevinylmap(bool value) {
  set_has_usevinylmap();
  usevinylmap_ = value;
}

// required int32 priceType = 11;
inline bool ChartletInfo::has_pricetype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ChartletInfo::set_has_pricetype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ChartletInfo::clear_has_pricetype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ChartletInfo::clear_pricetype() {
  pricetype_ = 0;
  clear_has_pricetype();
}
inline ::google::protobuf::int32 ChartletInfo::pricetype() const {
  return pricetype_;
}
inline void ChartletInfo::set_pricetype(::google::protobuf::int32 value) {
  set_has_pricetype();
  pricetype_ = value;
}

// required int32 price = 12;
inline bool ChartletInfo::has_price() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ChartletInfo::set_has_price() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ChartletInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ChartletInfo::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 ChartletInfo::price() const {
  return price_;
}
inline void ChartletInfo::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// required int64 tenancy = 13;
inline bool ChartletInfo::has_tenancy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ChartletInfo::set_has_tenancy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ChartletInfo::clear_has_tenancy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ChartletInfo::clear_tenancy() {
  tenancy_ = GOOGLE_LONGLONG(0);
  clear_has_tenancy();
}
inline ::google::protobuf::int64 ChartletInfo::tenancy() const {
  return tenancy_;
}
inline void ChartletInfo::set_tenancy(::google::protobuf::int64 value) {
  set_has_tenancy();
  tenancy_ = value;
}

// required bool owned = 14;
inline bool ChartletInfo::has_owned() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ChartletInfo::set_has_owned() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ChartletInfo::clear_has_owned() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ChartletInfo::clear_owned() {
  owned_ = false;
  clear_has_owned();
}
inline bool ChartletInfo::owned() const {
  return owned_;
}
inline void ChartletInfo::set_owned(bool value) {
  set_has_owned();
  owned_ = value;
}

// required int64 remainTime = 15;
inline bool ChartletInfo::has_remaintime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ChartletInfo::set_has_remaintime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ChartletInfo::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ChartletInfo::clear_remaintime() {
  remaintime_ = GOOGLE_LONGLONG(0);
  clear_has_remaintime();
}
inline ::google::protobuf::int64 ChartletInfo::remaintime() const {
  return remaintime_;
}
inline void ChartletInfo::set_remaintime(::google::protobuf::int64 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// required int32 id = 16;
inline bool ChartletInfo::has_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ChartletInfo::set_has_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ChartletInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ChartletInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ChartletInfo::id() const {
  return id_;
}
inline void ChartletInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 sellFlag = 17;
inline bool ChartletInfo::has_sellflag() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ChartletInfo::set_has_sellflag() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ChartletInfo::clear_has_sellflag() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ChartletInfo::clear_sellflag() {
  sellflag_ = 0;
  clear_has_sellflag();
}
inline ::google::protobuf::int32 ChartletInfo::sellflag() const {
  return sellflag_;
}
inline void ChartletInfo::set_sellflag(::google::protobuf::int32 value) {
  set_has_sellflag();
  sellflag_ = value;
}

// optional int32 orderId = 18;
inline bool ChartletInfo::has_orderid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ChartletInfo::set_has_orderid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ChartletInfo::clear_has_orderid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ChartletInfo::clear_orderid() {
  orderid_ = 0;
  clear_has_orderid();
}
inline ::google::protobuf::int32 ChartletInfo::orderid() const {
  return orderid_;
}
inline void ChartletInfo::set_orderid(::google::protobuf::int32 value) {
  set_has_orderid();
  orderid_ = value;
}

// optional int32 score = 19;
inline bool ChartletInfo::has_score() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ChartletInfo::set_has_score() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ChartletInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ChartletInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ChartletInfo::score() const {
  return score_;
}
inline void ChartletInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// CarSlotInfo

// required int32 slotId = 1;
inline bool CarSlotInfo::has_slotid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CarSlotInfo::set_has_slotid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CarSlotInfo::clear_has_slotid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CarSlotInfo::clear_slotid() {
  slotid_ = 0;
  clear_has_slotid();
}
inline ::google::protobuf::int32 CarSlotInfo::slotid() const {
  return slotid_;
}
inline void CarSlotInfo::set_slotid(::google::protobuf::int32 value) {
  set_has_slotid();
  slotid_ = value;
}

// required int32 level = 2;
inline bool CarSlotInfo::has_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CarSlotInfo::set_has_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CarSlotInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CarSlotInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CarSlotInfo::level() const {
  return level_;
}
inline void CarSlotInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required bool reachMaxLevel = 3;
inline bool CarSlotInfo::has_reachmaxlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CarSlotInfo::set_has_reachmaxlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CarSlotInfo::clear_has_reachmaxlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CarSlotInfo::clear_reachmaxlevel() {
  reachmaxlevel_ = false;
  clear_has_reachmaxlevel();
}
inline bool CarSlotInfo::reachmaxlevel() const {
  return reachmaxlevel_;
}
inline void CarSlotInfo::set_reachmaxlevel(bool value) {
  set_has_reachmaxlevel();
  reachmaxlevel_ = value;
}

// required int32 status = 4;
inline bool CarSlotInfo::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CarSlotInfo::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CarSlotInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CarSlotInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 CarSlotInfo::status() const {
  return status_;
}
inline void CarSlotInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional int32 remainTime = 5;
inline bool CarSlotInfo::has_remaintime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CarSlotInfo::set_has_remaintime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CarSlotInfo::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CarSlotInfo::clear_remaintime() {
  remaintime_ = 0;
  clear_has_remaintime();
}
inline ::google::protobuf::int32 CarSlotInfo::remaintime() const {
  return remaintime_;
}
inline void CarSlotInfo::set_remaintime(::google::protobuf::int32 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// required int32 score = 6;
inline bool CarSlotInfo::has_score() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CarSlotInfo::set_has_score() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CarSlotInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CarSlotInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 CarSlotInfo::score() const {
  return score_;
}
inline void CarSlotInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// required int32 priceType = 7;
inline bool CarSlotInfo::has_pricetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CarSlotInfo::set_has_pricetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CarSlotInfo::clear_has_pricetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CarSlotInfo::clear_pricetype() {
  pricetype_ = 0;
  clear_has_pricetype();
}
inline ::google::protobuf::int32 CarSlotInfo::pricetype() const {
  return pricetype_;
}
inline void CarSlotInfo::set_pricetype(::google::protobuf::int32 value) {
  set_has_pricetype();
  pricetype_ = value;
}

// required int32 price = 8;
inline bool CarSlotInfo::has_price() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CarSlotInfo::set_has_price() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CarSlotInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CarSlotInfo::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 CarSlotInfo::price() const {
  return price_;
}
inline void CarSlotInfo::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// required string description = 9;
inline bool CarSlotInfo::has_description() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CarSlotInfo::set_has_description() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CarSlotInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CarSlotInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CarSlotInfo::description() const {
  return *description_;
}
inline void CarSlotInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CarSlotInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CarSlotInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CarSlotInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CarSlotInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .com.ea.eamobile.nfsmw.protoc.ConsumableData consumble = 10;
inline int CarSlotInfo::consumble_size() const {
  return consumble_.size();
}
inline void CarSlotInfo::clear_consumble() {
  consumble_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ConsumableData& CarSlotInfo::consumble(int index) const {
  return consumble_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ConsumableData* CarSlotInfo::mutable_consumble(int index) {
  return consumble_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ConsumableData* CarSlotInfo::add_consumble() {
  return consumble_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ConsumableData >&
CarSlotInfo::consumble() const {
  return consumble_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ConsumableData >*
CarSlotInfo::mutable_consumble() {
  return &consumble_;
}

// optional int32 nextAddScore = 11;
inline bool CarSlotInfo::has_nextaddscore() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CarSlotInfo::set_has_nextaddscore() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CarSlotInfo::clear_has_nextaddscore() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CarSlotInfo::clear_nextaddscore() {
  nextaddscore_ = 0;
  clear_has_nextaddscore();
}
inline ::google::protobuf::int32 CarSlotInfo::nextaddscore() const {
  return nextaddscore_;
}
inline void CarSlotInfo::set_nextaddscore(::google::protobuf::int32 value) {
  set_has_nextaddscore();
  nextaddscore_ = value;
}

// -------------------------------------------------------------------

// ConsumableData

// required int32 type = 1;
inline bool ConsumableData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConsumableData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConsumableData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConsumableData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ConsumableData::type() const {
  return type_;
}
inline void ConsumableData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required float ratio = 2;
inline bool ConsumableData::has_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConsumableData::set_has_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConsumableData::clear_has_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConsumableData::clear_ratio() {
  ratio_ = 0;
  clear_has_ratio();
}
inline float ConsumableData::ratio() const {
  return ratio_;
}
inline void ConsumableData::set_ratio(float value) {
  set_has_ratio();
  ratio_ = value;
}

// required int32 priceType = 3;
inline bool ConsumableData::has_pricetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConsumableData::set_has_pricetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConsumableData::clear_has_pricetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConsumableData::clear_pricetype() {
  pricetype_ = 0;
  clear_has_pricetype();
}
inline ::google::protobuf::int32 ConsumableData::pricetype() const {
  return pricetype_;
}
inline void ConsumableData::set_pricetype(::google::protobuf::int32 value) {
  set_has_pricetype();
  pricetype_ = value;
}

// required int32 price = 4;
inline bool ConsumableData::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConsumableData::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConsumableData::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConsumableData::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 ConsumableData::price() const {
  return price_;
}
inline void ConsumableData::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
}

// -------------------------------------------------------------------

// RequestGarageCommand

// -------------------------------------------------------------------

// ResponseGarageCommand

// repeated .com.ea.eamobile.nfsmw.protoc.CarData carDatas = 1;
inline int ResponseGarageCommand::cardatas_size() const {
  return cardatas_.size();
}
inline void ResponseGarageCommand::clear_cardatas() {
  cardatas_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::CarData& ResponseGarageCommand::cardatas(int index) const {
  return cardatas_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::CarData* ResponseGarageCommand::mutable_cardatas(int index) {
  return cardatas_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::CarData* ResponseGarageCommand::add_cardatas() {
  return cardatas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarData >&
ResponseGarageCommand::cardatas() const {
  return cardatas_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::CarData >*
ResponseGarageCommand::mutable_cardatas() {
  return &cardatas_;
}

// -------------------------------------------------------------------

// RequestBuyCarCommand

// required string carId = 1;
inline bool RequestBuyCarCommand::has_carid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBuyCarCommand::set_has_carid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBuyCarCommand::clear_has_carid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBuyCarCommand::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& RequestBuyCarCommand::carid() const {
  return *carid_;
}
inline void RequestBuyCarCommand::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestBuyCarCommand::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestBuyCarCommand::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestBuyCarCommand::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* RequestBuyCarCommand::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseBuyCarCommand

// required bool success = 1;
inline bool ResponseBuyCarCommand::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBuyCarCommand::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBuyCarCommand::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBuyCarCommand::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ResponseBuyCarCommand::success() const {
  return success_;
}
inline void ResponseBuyCarCommand::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required string message = 2;
inline bool ResponseBuyCarCommand::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseBuyCarCommand::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseBuyCarCommand::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseBuyCarCommand::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ResponseBuyCarCommand::message() const {
  return *message_;
}
inline void ResponseBuyCarCommand::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseBuyCarCommand::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseBuyCarCommand::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseBuyCarCommand::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ResponseBuyCarCommand::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestCarDataCommand

// required string carId = 1;
inline bool RequestCarDataCommand::has_carid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCarDataCommand::set_has_carid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCarDataCommand::clear_has_carid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCarDataCommand::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& RequestCarDataCommand::carid() const {
  return *carid_;
}
inline void RequestCarDataCommand::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestCarDataCommand::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestCarDataCommand::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestCarDataCommand::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* RequestCarDataCommand::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseCarDataCommand

// required .com.ea.eamobile.nfsmw.protoc.CarData carData = 1;
inline bool ResponseCarDataCommand::has_cardata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCarDataCommand::set_has_cardata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCarDataCommand::clear_has_cardata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCarDataCommand::clear_cardata() {
  if (cardata_ != NULL) cardata_->::com::ea::eamobile::nfsmw::protoc::CarData::Clear();
  clear_has_cardata();
}
inline const ::com::ea::eamobile::nfsmw::protoc::CarData& ResponseCarDataCommand::cardata() const {
  return cardata_ != NULL ? *cardata_ : *default_instance_->cardata_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CarData* ResponseCarDataCommand::mutable_cardata() {
  set_has_cardata();
  if (cardata_ == NULL) cardata_ = new ::com::ea::eamobile::nfsmw::protoc::CarData;
  return cardata_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CarData* ResponseCarDataCommand::release_cardata() {
  clear_has_cardata();
  ::com::ea::eamobile::nfsmw::protoc::CarData* temp = cardata_;
  cardata_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RequestUpgradeSlotCommand

// required int32 slotId = 1;
inline bool RequestUpgradeSlotCommand::has_slotid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUpgradeSlotCommand::set_has_slotid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUpgradeSlotCommand::clear_has_slotid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUpgradeSlotCommand::clear_slotid() {
  slotid_ = 0;
  clear_has_slotid();
}
inline ::google::protobuf::int32 RequestUpgradeSlotCommand::slotid() const {
  return slotid_;
}
inline void RequestUpgradeSlotCommand::set_slotid(::google::protobuf::int32 value) {
  set_has_slotid();
  slotid_ = value;
}

// required string userCarId = 2;
inline bool RequestUpgradeSlotCommand::has_usercarid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUpgradeSlotCommand::set_has_usercarid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUpgradeSlotCommand::clear_has_usercarid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUpgradeSlotCommand::clear_usercarid() {
  if (usercarid_ != &::google::protobuf::internal::kEmptyString) {
    usercarid_->clear();
  }
  clear_has_usercarid();
}
inline const ::std::string& RequestUpgradeSlotCommand::usercarid() const {
  return *usercarid_;
}
inline void RequestUpgradeSlotCommand::set_usercarid(const ::std::string& value) {
  set_has_usercarid();
  if (usercarid_ == &::google::protobuf::internal::kEmptyString) {
    usercarid_ = new ::std::string;
  }
  usercarid_->assign(value);
}
inline void RequestUpgradeSlotCommand::set_usercarid(const char* value) {
  set_has_usercarid();
  if (usercarid_ == &::google::protobuf::internal::kEmptyString) {
    usercarid_ = new ::std::string;
  }
  usercarid_->assign(value);
}
inline void RequestUpgradeSlotCommand::set_usercarid(const char* value, size_t size) {
  set_has_usercarid();
  if (usercarid_ == &::google::protobuf::internal::kEmptyString) {
    usercarid_ = new ::std::string;
  }
  usercarid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUpgradeSlotCommand::mutable_usercarid() {
  set_has_usercarid();
  if (usercarid_ == &::google::protobuf::internal::kEmptyString) {
    usercarid_ = new ::std::string;
  }
  return usercarid_;
}
inline ::std::string* RequestUpgradeSlotCommand::release_usercarid() {
  clear_has_usercarid();
  if (usercarid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usercarid_;
    usercarid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseUpgradeSlotCommand

// required bool success = 1;
inline bool ResponseUpgradeSlotCommand::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUpgradeSlotCommand::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUpgradeSlotCommand::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUpgradeSlotCommand::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ResponseUpgradeSlotCommand::success() const {
  return success_;
}
inline void ResponseUpgradeSlotCommand::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required string message = 2;
inline bool ResponseUpgradeSlotCommand::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseUpgradeSlotCommand::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseUpgradeSlotCommand::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseUpgradeSlotCommand::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ResponseUpgradeSlotCommand::message() const {
  return *message_;
}
inline void ResponseUpgradeSlotCommand::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseUpgradeSlotCommand::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseUpgradeSlotCommand::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseUpgradeSlotCommand::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ResponseUpgradeSlotCommand::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 remainTime = 3;
inline bool ResponseUpgradeSlotCommand::has_remaintime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseUpgradeSlotCommand::set_has_remaintime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseUpgradeSlotCommand::clear_has_remaintime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseUpgradeSlotCommand::clear_remaintime() {
  remaintime_ = 0;
  clear_has_remaintime();
}
inline ::google::protobuf::int32 ResponseUpgradeSlotCommand::remaintime() const {
  return remaintime_;
}
inline void ResponseUpgradeSlotCommand::set_remaintime(::google::protobuf::int32 value) {
  set_has_remaintime();
  remaintime_ = value;
}

// -------------------------------------------------------------------

// RequestUseChartletCommand

// required int32 chartletId = 1;
inline bool RequestUseChartletCommand::has_chartletid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestUseChartletCommand::set_has_chartletid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestUseChartletCommand::clear_has_chartletid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestUseChartletCommand::clear_chartletid() {
  chartletid_ = 0;
  clear_has_chartletid();
}
inline ::google::protobuf::int32 RequestUseChartletCommand::chartletid() const {
  return chartletid_;
}
inline void RequestUseChartletCommand::set_chartletid(::google::protobuf::int32 value) {
  set_has_chartletid();
  chartletid_ = value;
}

// required string carId = 2;
inline bool RequestUseChartletCommand::has_carid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestUseChartletCommand::set_has_carid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestUseChartletCommand::clear_has_carid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestUseChartletCommand::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& RequestUseChartletCommand::carid() const {
  return *carid_;
}
inline void RequestUseChartletCommand::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestUseChartletCommand::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestUseChartletCommand::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestUseChartletCommand::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* RequestUseChartletCommand::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseUseChartletCommand

// required bool success = 1;
inline bool ResponseUseChartletCommand::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseUseChartletCommand::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseUseChartletCommand::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseUseChartletCommand::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ResponseUseChartletCommand::success() const {
  return success_;
}
inline void ResponseUseChartletCommand::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// required string message = 2;
inline bool ResponseUseChartletCommand::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseUseChartletCommand::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseUseChartletCommand::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseUseChartletCommand::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ResponseUseChartletCommand::message() const {
  return *message_;
}
inline void ResponseUseChartletCommand::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseUseChartletCommand::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseUseChartletCommand::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseUseChartletCommand::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ResponseUseChartletCommand::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestChallengeMathInfoCommand

// required bool request = 1;
inline bool RequestChallengeMathInfoCommand::has_request() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestChallengeMathInfoCommand::set_has_request() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestChallengeMathInfoCommand::clear_has_request() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestChallengeMathInfoCommand::clear_request() {
  request_ = false;
  clear_has_request();
}
inline bool RequestChallengeMathInfoCommand::request() const {
  return request_;
}
inline void RequestChallengeMathInfoCommand::set_request(bool value) {
  set_has_request();
  request_ = value;
}

// -------------------------------------------------------------------

// ResponseChallengeMatchInfoCommand

// required int32 modeId = 1;
inline bool ResponseChallengeMatchInfoCommand::has_modeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseChallengeMatchInfoCommand::set_has_modeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseChallengeMatchInfoCommand::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseChallengeMatchInfoCommand::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 ResponseChallengeMatchInfoCommand::modeid() const {
  return modeid_;
}
inline void ResponseChallengeMatchInfoCommand::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// required int32 challengeDays = 2;
inline bool ResponseChallengeMatchInfoCommand::has_challengedays() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseChallengeMatchInfoCommand::set_has_challengedays() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseChallengeMatchInfoCommand::clear_has_challengedays() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseChallengeMatchInfoCommand::clear_challengedays() {
  challengedays_ = 0;
  clear_has_challengedays();
}
inline ::google::protobuf::int32 ResponseChallengeMatchInfoCommand::challengedays() const {
  return challengedays_;
}
inline void ResponseChallengeMatchInfoCommand::set_challengedays(::google::protobuf::int32 value) {
  set_has_challengedays();
  challengedays_ = value;
}

// required .com.ea.eamobile.nfsmw.protoc.Reward reward = 3;
inline bool ResponseChallengeMatchInfoCommand::has_reward() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseChallengeMatchInfoCommand::set_has_reward() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseChallengeMatchInfoCommand::clear_has_reward() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseChallengeMatchInfoCommand::clear_reward() {
  if (reward_ != NULL) reward_->::com::ea::eamobile::nfsmw::protoc::Reward::Clear();
  clear_has_reward();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Reward& ResponseChallengeMatchInfoCommand::reward() const {
  return reward_ != NULL ? *reward_ : *default_instance_->reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseChallengeMatchInfoCommand::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) reward_ = new ::com::ea::eamobile::nfsmw::protoc::Reward;
  return reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseChallengeMatchInfoCommand::release_reward() {
  clear_has_reward();
  ::com::ea::eamobile::nfsmw::protoc::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}

// required string carId = 4;
inline bool ResponseChallengeMatchInfoCommand::has_carid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseChallengeMatchInfoCommand::set_has_carid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseChallengeMatchInfoCommand::clear_has_carid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseChallengeMatchInfoCommand::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& ResponseChallengeMatchInfoCommand::carid() const {
  return *carid_;
}
inline void ResponseChallengeMatchInfoCommand::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void ResponseChallengeMatchInfoCommand::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void ResponseChallengeMatchInfoCommand::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseChallengeMatchInfoCommand::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* ResponseChallengeMatchInfoCommand::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 remainTimes = 5;
inline bool ResponseChallengeMatchInfoCommand::has_remaintimes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseChallengeMatchInfoCommand::set_has_remaintimes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseChallengeMatchInfoCommand::clear_has_remaintimes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseChallengeMatchInfoCommand::clear_remaintimes() {
  remaintimes_ = 0;
  clear_has_remaintimes();
}
inline ::google::protobuf::int32 ResponseChallengeMatchInfoCommand::remaintimes() const {
  return remaintimes_;
}
inline void ResponseChallengeMatchInfoCommand::set_remaintimes(::google::protobuf::int32 value) {
  set_has_remaintimes();
  remaintimes_ = value;
}

// required float passTime = 6;
inline bool ResponseChallengeMatchInfoCommand::has_passtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseChallengeMatchInfoCommand::set_has_passtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseChallengeMatchInfoCommand::clear_has_passtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseChallengeMatchInfoCommand::clear_passtime() {
  passtime_ = 0;
  clear_has_passtime();
}
inline float ResponseChallengeMatchInfoCommand::passtime() const {
  return passtime_;
}
inline void ResponseChallengeMatchInfoCommand::set_passtime(float value) {
  set_has_passtime();
  passtime_ = value;
}

// required string eventName = 7;
inline bool ResponseChallengeMatchInfoCommand::has_eventname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseChallengeMatchInfoCommand::set_has_eventname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseChallengeMatchInfoCommand::clear_has_eventname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseChallengeMatchInfoCommand::clear_eventname() {
  if (eventname_ != &::google::protobuf::internal::kEmptyString) {
    eventname_->clear();
  }
  clear_has_eventname();
}
inline const ::std::string& ResponseChallengeMatchInfoCommand::eventname() const {
  return *eventname_;
}
inline void ResponseChallengeMatchInfoCommand::set_eventname(const ::std::string& value) {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  eventname_->assign(value);
}
inline void ResponseChallengeMatchInfoCommand::set_eventname(const char* value) {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  eventname_->assign(value);
}
inline void ResponseChallengeMatchInfoCommand::set_eventname(const char* value, size_t size) {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  eventname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseChallengeMatchInfoCommand::mutable_eventname() {
  set_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    eventname_ = new ::std::string;
  }
  return eventname_;
}
inline ::std::string* ResponseChallengeMatchInfoCommand::release_eventname() {
  clear_has_eventname();
  if (eventname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventname_;
    eventname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string carLimitDisplayString = 8;
inline bool ResponseChallengeMatchInfoCommand::has_carlimitdisplaystring() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseChallengeMatchInfoCommand::set_has_carlimitdisplaystring() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseChallengeMatchInfoCommand::clear_has_carlimitdisplaystring() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseChallengeMatchInfoCommand::clear_carlimitdisplaystring() {
  if (carlimitdisplaystring_ != &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_->clear();
  }
  clear_has_carlimitdisplaystring();
}
inline const ::std::string& ResponseChallengeMatchInfoCommand::carlimitdisplaystring() const {
  return *carlimitdisplaystring_;
}
inline void ResponseChallengeMatchInfoCommand::set_carlimitdisplaystring(const ::std::string& value) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(value);
}
inline void ResponseChallengeMatchInfoCommand::set_carlimitdisplaystring(const char* value) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(value);
}
inline void ResponseChallengeMatchInfoCommand::set_carlimitdisplaystring(const char* value, size_t size) {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  carlimitdisplaystring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseChallengeMatchInfoCommand::mutable_carlimitdisplaystring() {
  set_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    carlimitdisplaystring_ = new ::std::string;
  }
  return carlimitdisplaystring_;
}
inline ::std::string* ResponseChallengeMatchInfoCommand::release_carlimitdisplaystring() {
  clear_has_carlimitdisplaystring();
  if (carlimitdisplaystring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carlimitdisplaystring_;
    carlimitdisplaystring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 expireSeconds = 9;
inline bool ResponseChallengeMatchInfoCommand::has_expireseconds() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseChallengeMatchInfoCommand::set_has_expireseconds() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseChallengeMatchInfoCommand::clear_has_expireseconds() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseChallengeMatchInfoCommand::clear_expireseconds() {
  expireseconds_ = 0;
  clear_has_expireseconds();
}
inline ::google::protobuf::int32 ResponseChallengeMatchInfoCommand::expireseconds() const {
  return expireseconds_;
}
inline void ResponseChallengeMatchInfoCommand::set_expireseconds(::google::protobuf::int32 value) {
  set_has_expireseconds();
  expireseconds_ = value;
}

// -------------------------------------------------------------------

// ResponseFeedCommand

// repeated string feedContent = 1;
inline int ResponseFeedCommand::feedcontent_size() const {
  return feedcontent_.size();
}
inline void ResponseFeedCommand::clear_feedcontent() {
  feedcontent_.Clear();
}
inline const ::std::string& ResponseFeedCommand::feedcontent(int index) const {
  return feedcontent_.Get(index);
}
inline ::std::string* ResponseFeedCommand::mutable_feedcontent(int index) {
  return feedcontent_.Mutable(index);
}
inline void ResponseFeedCommand::set_feedcontent(int index, const ::std::string& value) {
  feedcontent_.Mutable(index)->assign(value);
}
inline void ResponseFeedCommand::set_feedcontent(int index, const char* value) {
  feedcontent_.Mutable(index)->assign(value);
}
inline void ResponseFeedCommand::set_feedcontent(int index, const char* value, size_t size) {
  feedcontent_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseFeedCommand::add_feedcontent() {
  return feedcontent_.Add();
}
inline void ResponseFeedCommand::add_feedcontent(const ::std::string& value) {
  feedcontent_.Add()->assign(value);
}
inline void ResponseFeedCommand::add_feedcontent(const char* value) {
  feedcontent_.Add()->assign(value);
}
inline void ResponseFeedCommand::add_feedcontent(const char* value, size_t size) {
  feedcontent_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseFeedCommand::feedcontent() const {
  return feedcontent_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseFeedCommand::mutable_feedcontent() {
  return &feedcontent_;
}

// -------------------------------------------------------------------

// ItemMessage

// required string name = 1;
inline bool ItemMessage::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemMessage::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ItemMessage::name() const {
  return *name_;
}
inline void ItemMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ItemMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ItemMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ItemMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 priceType = 2;
inline bool ItemMessage::has_pricetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemMessage::set_has_pricetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemMessage::clear_has_pricetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemMessage::clear_pricetype() {
  pricetype_ = 0;
  clear_has_pricetype();
}
inline ::google::protobuf::int32 ItemMessage::pricetype() const {
  return pricetype_;
}
inline void ItemMessage::set_pricetype(::google::protobuf::int32 value) {
  set_has_pricetype();
  pricetype_ = value;
}

// required float price = 3;
inline bool ItemMessage::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemMessage::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemMessage::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemMessage::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float ItemMessage::price() const {
  return price_;
}
inline void ItemMessage::set_price(float value) {
  set_has_price();
  price_ = value;
}

// required bool discount = 4;
inline bool ItemMessage::has_discount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ItemMessage::set_has_discount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ItemMessage::clear_has_discount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ItemMessage::clear_discount() {
  discount_ = false;
  clear_has_discount();
}
inline bool ItemMessage::discount() const {
  return discount_;
}
inline void ItemMessage::set_discount(bool value) {
  set_has_discount();
  discount_ = value;
}

// required string discountNum = 5;
inline bool ItemMessage::has_discountnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ItemMessage::set_has_discountnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ItemMessage::clear_has_discountnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ItemMessage::clear_discountnum() {
  if (discountnum_ != &::google::protobuf::internal::kEmptyString) {
    discountnum_->clear();
  }
  clear_has_discountnum();
}
inline const ::std::string& ItemMessage::discountnum() const {
  return *discountnum_;
}
inline void ItemMessage::set_discountnum(const ::std::string& value) {
  set_has_discountnum();
  if (discountnum_ == &::google::protobuf::internal::kEmptyString) {
    discountnum_ = new ::std::string;
  }
  discountnum_->assign(value);
}
inline void ItemMessage::set_discountnum(const char* value) {
  set_has_discountnum();
  if (discountnum_ == &::google::protobuf::internal::kEmptyString) {
    discountnum_ = new ::std::string;
  }
  discountnum_->assign(value);
}
inline void ItemMessage::set_discountnum(const char* value, size_t size) {
  set_has_discountnum();
  if (discountnum_ == &::google::protobuf::internal::kEmptyString) {
    discountnum_ = new ::std::string;
  }
  discountnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ItemMessage::mutable_discountnum() {
  set_has_discountnum();
  if (discountnum_ == &::google::protobuf::internal::kEmptyString) {
    discountnum_ = new ::std::string;
  }
  return discountnum_;
}
inline ::std::string* ItemMessage::release_discountnum() {
  clear_has_discountnum();
  if (discountnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = discountnum_;
    discountnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required float discountPrice = 6;
inline bool ItemMessage::has_discountprice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ItemMessage::set_has_discountprice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ItemMessage::clear_has_discountprice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ItemMessage::clear_discountprice() {
  discountprice_ = 0;
  clear_has_discountprice();
}
inline float ItemMessage::discountprice() const {
  return discountprice_;
}
inline void ItemMessage::set_discountprice(float value) {
  set_has_discountprice();
  discountprice_ = value;
}

// required int32 buyCount = 7;
inline bool ItemMessage::has_buycount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ItemMessage::set_has_buycount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ItemMessage::clear_has_buycount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ItemMessage::clear_buycount() {
  buycount_ = 0;
  clear_has_buycount();
}
inline ::google::protobuf::int32 ItemMessage::buycount() const {
  return buycount_;
}
inline void ItemMessage::set_buycount(::google::protobuf::int32 value) {
  set_has_buycount();
  buycount_ = value;
}

// required int64 buyTimeLimit = 8;
inline bool ItemMessage::has_buytimelimit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ItemMessage::set_has_buytimelimit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ItemMessage::clear_has_buytimelimit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ItemMessage::clear_buytimelimit() {
  buytimelimit_ = GOOGLE_LONGLONG(0);
  clear_has_buytimelimit();
}
inline ::google::protobuf::int64 ItemMessage::buytimelimit() const {
  return buytimelimit_;
}
inline void ItemMessage::set_buytimelimit(::google::protobuf::int64 value) {
  set_has_buytimelimit();
  buytimelimit_ = value;
}

// required int32 itemType = 9;
inline bool ItemMessage::has_itemtype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ItemMessage::set_has_itemtype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ItemMessage::clear_has_itemtype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ItemMessage::clear_itemtype() {
  itemtype_ = 0;
  clear_has_itemtype();
}
inline ::google::protobuf::int32 ItemMessage::itemtype() const {
  return itemtype_;
}
inline void ItemMessage::set_itemtype(::google::protobuf::int32 value) {
  set_has_itemtype();
  itemtype_ = value;
}

// required int32 itemId = 10;
inline bool ItemMessage::has_itemid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ItemMessage::set_has_itemid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ItemMessage::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ItemMessage::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 ItemMessage::itemid() const {
  return itemid_;
}
inline void ItemMessage::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional int32 sellFlag = 11;
inline bool ItemMessage::has_sellflag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ItemMessage::set_has_sellflag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ItemMessage::clear_has_sellflag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ItemMessage::clear_sellflag() {
  sellflag_ = 0;
  clear_has_sellflag();
}
inline ::google::protobuf::int32 ItemMessage::sellflag() const {
  return sellflag_;
}
inline void ItemMessage::set_sellflag(::google::protobuf::int32 value) {
  set_has_sellflag();
  sellflag_ = value;
}

// -------------------------------------------------------------------

// RequestStoreDetailCommand

// -------------------------------------------------------------------

// ResponseStoreDetailCommand

// repeated .com.ea.eamobile.nfsmw.protoc.ItemMessage items = 1;
inline int ResponseStoreDetailCommand::items_size() const {
  return items_.size();
}
inline void ResponseStoreDetailCommand::clear_items() {
  items_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ItemMessage& ResponseStoreDetailCommand::items(int index) const {
  return items_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ItemMessage* ResponseStoreDetailCommand::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ItemMessage* ResponseStoreDetailCommand::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ItemMessage >&
ResponseStoreDetailCommand::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ItemMessage >*
ResponseStoreDetailCommand::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// RequestBuyItemCommand

// required int32 itemId = 1;
inline bool RequestBuyItemCommand::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestBuyItemCommand::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestBuyItemCommand::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestBuyItemCommand::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 RequestBuyItemCommand::itemid() const {
  return itemid_;
}
inline void RequestBuyItemCommand::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// -------------------------------------------------------------------

// ResponseBuyItemCommand

// required bool success = 1;
inline bool ResponseBuyItemCommand::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseBuyItemCommand::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseBuyItemCommand::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseBuyItemCommand::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ResponseBuyItemCommand::success() const {
  return success_;
}
inline void ResponseBuyItemCommand::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string message = 2;
inline bool ResponseBuyItemCommand::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseBuyItemCommand::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseBuyItemCommand::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseBuyItemCommand::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ResponseBuyItemCommand::message() const {
  return *message_;
}
inline void ResponseBuyItemCommand::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseBuyItemCommand::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseBuyItemCommand::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseBuyItemCommand::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ResponseBuyItemCommand::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestSystemCommand

// required .com.ea.eamobile.nfsmw.protoc.RequestSystemCommand.SystemConfigType type = 1;
inline bool RequestSystemCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestSystemCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestSystemCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestSystemCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand_SystemConfigType RequestSystemCommand::type() const {
  return static_cast< ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand_SystemConfigType >(type_);
}
inline void RequestSystemCommand::set_type(::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand_SystemConfigType value) {
  GOOGLE_DCHECK(::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand_SystemConfigType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string content = 2;
inline bool RequestSystemCommand::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestSystemCommand::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestSystemCommand::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestSystemCommand::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& RequestSystemCommand::content() const {
  return *content_;
}
inline void RequestSystemCommand::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void RequestSystemCommand::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void RequestSystemCommand::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestSystemCommand::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* RequestSystemCommand::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseSystemCommand

// repeated .com.ea.eamobile.nfsmw.protoc.EventOptionMessage EventOption = 1;
inline int ResponseSystemCommand::eventoption_size() const {
  return eventoption_.size();
}
inline void ResponseSystemCommand::clear_eventoption() {
  eventoption_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage& ResponseSystemCommand::eventoption(int index) const {
  return eventoption_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage* ResponseSystemCommand::mutable_eventoption(int index) {
  return eventoption_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage* ResponseSystemCommand::add_eventoption() {
  return eventoption_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage >&
ResponseSystemCommand::eventoption() const {
  return eventoption_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::EventOptionMessage >*
ResponseSystemCommand::mutable_eventoption() {
  return &eventoption_;
}

// repeated int32 CtaParam = 2;
inline int ResponseSystemCommand::ctaparam_size() const {
  return ctaparam_.size();
}
inline void ResponseSystemCommand::clear_ctaparam() {
  ctaparam_.Clear();
}
inline ::google::protobuf::int32 ResponseSystemCommand::ctaparam(int index) const {
  return ctaparam_.Get(index);
}
inline void ResponseSystemCommand::set_ctaparam(int index, ::google::protobuf::int32 value) {
  ctaparam_.Set(index, value);
}
inline void ResponseSystemCommand::add_ctaparam(::google::protobuf::int32 value) {
  ctaparam_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ResponseSystemCommand::ctaparam() const {
  return ctaparam_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ResponseSystemCommand::mutable_ctaparam() {
  return &ctaparam_;
}

// optional string messageUrl = 3;
inline bool ResponseSystemCommand::has_messageurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseSystemCommand::set_has_messageurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseSystemCommand::clear_has_messageurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseSystemCommand::clear_messageurl() {
  if (messageurl_ != &::google::protobuf::internal::kEmptyString) {
    messageurl_->clear();
  }
  clear_has_messageurl();
}
inline const ::std::string& ResponseSystemCommand::messageurl() const {
  return *messageurl_;
}
inline void ResponseSystemCommand::set_messageurl(const ::std::string& value) {
  set_has_messageurl();
  if (messageurl_ == &::google::protobuf::internal::kEmptyString) {
    messageurl_ = new ::std::string;
  }
  messageurl_->assign(value);
}
inline void ResponseSystemCommand::set_messageurl(const char* value) {
  set_has_messageurl();
  if (messageurl_ == &::google::protobuf::internal::kEmptyString) {
    messageurl_ = new ::std::string;
  }
  messageurl_->assign(value);
}
inline void ResponseSystemCommand::set_messageurl(const char* value, size_t size) {
  set_has_messageurl();
  if (messageurl_ == &::google::protobuf::internal::kEmptyString) {
    messageurl_ = new ::std::string;
  }
  messageurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseSystemCommand::mutable_messageurl() {
  set_has_messageurl();
  if (messageurl_ == &::google::protobuf::internal::kEmptyString) {
    messageurl_ = new ::std::string;
  }
  return messageurl_;
}
inline ::std::string* ResponseSystemCommand::release_messageurl() {
  clear_has_messageurl();
  if (messageurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messageurl_;
    messageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated float speedFactor = 4;
inline int ResponseSystemCommand::speedfactor_size() const {
  return speedfactor_.size();
}
inline void ResponseSystemCommand::clear_speedfactor() {
  speedfactor_.Clear();
}
inline float ResponseSystemCommand::speedfactor(int index) const {
  return speedfactor_.Get(index);
}
inline void ResponseSystemCommand::set_speedfactor(int index, float value) {
  speedfactor_.Set(index, value);
}
inline void ResponseSystemCommand::add_speedfactor(float value) {
  speedfactor_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ResponseSystemCommand::speedfactor() const {
  return speedfactor_;
}
inline ::google::protobuf::RepeatedField< float >*
ResponseSystemCommand::mutable_speedfactor() {
  return &speedfactor_;
}

// optional string IPSPFailedMessageUrl = 5;
inline bool ResponseSystemCommand::has_ipspfailedmessageurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseSystemCommand::set_has_ipspfailedmessageurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseSystemCommand::clear_has_ipspfailedmessageurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseSystemCommand::clear_ipspfailedmessageurl() {
  if (ipspfailedmessageurl_ != &::google::protobuf::internal::kEmptyString) {
    ipspfailedmessageurl_->clear();
  }
  clear_has_ipspfailedmessageurl();
}
inline const ::std::string& ResponseSystemCommand::ipspfailedmessageurl() const {
  return *ipspfailedmessageurl_;
}
inline void ResponseSystemCommand::set_ipspfailedmessageurl(const ::std::string& value) {
  set_has_ipspfailedmessageurl();
  if (ipspfailedmessageurl_ == &::google::protobuf::internal::kEmptyString) {
    ipspfailedmessageurl_ = new ::std::string;
  }
  ipspfailedmessageurl_->assign(value);
}
inline void ResponseSystemCommand::set_ipspfailedmessageurl(const char* value) {
  set_has_ipspfailedmessageurl();
  if (ipspfailedmessageurl_ == &::google::protobuf::internal::kEmptyString) {
    ipspfailedmessageurl_ = new ::std::string;
  }
  ipspfailedmessageurl_->assign(value);
}
inline void ResponseSystemCommand::set_ipspfailedmessageurl(const char* value, size_t size) {
  set_has_ipspfailedmessageurl();
  if (ipspfailedmessageurl_ == &::google::protobuf::internal::kEmptyString) {
    ipspfailedmessageurl_ = new ::std::string;
  }
  ipspfailedmessageurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseSystemCommand::mutable_ipspfailedmessageurl() {
  set_has_ipspfailedmessageurl();
  if (ipspfailedmessageurl_ == &::google::protobuf::internal::kEmptyString) {
    ipspfailedmessageurl_ = new ::std::string;
  }
  return ipspfailedmessageurl_;
}
inline ::std::string* ResponseSystemCommand::release_ipspfailedmessageurl() {
  clear_has_ipspfailedmessageurl();
  if (ipspfailedmessageurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipspfailedmessageurl_;
    ipspfailedmessageurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string rentJaguarUrl = 6;
inline bool ResponseSystemCommand::has_rentjaguarurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseSystemCommand::set_has_rentjaguarurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseSystemCommand::clear_has_rentjaguarurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseSystemCommand::clear_rentjaguarurl() {
  if (rentjaguarurl_ != &::google::protobuf::internal::kEmptyString) {
    rentjaguarurl_->clear();
  }
  clear_has_rentjaguarurl();
}
inline const ::std::string& ResponseSystemCommand::rentjaguarurl() const {
  return *rentjaguarurl_;
}
inline void ResponseSystemCommand::set_rentjaguarurl(const ::std::string& value) {
  set_has_rentjaguarurl();
  if (rentjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    rentjaguarurl_ = new ::std::string;
  }
  rentjaguarurl_->assign(value);
}
inline void ResponseSystemCommand::set_rentjaguarurl(const char* value) {
  set_has_rentjaguarurl();
  if (rentjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    rentjaguarurl_ = new ::std::string;
  }
  rentjaguarurl_->assign(value);
}
inline void ResponseSystemCommand::set_rentjaguarurl(const char* value, size_t size) {
  set_has_rentjaguarurl();
  if (rentjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    rentjaguarurl_ = new ::std::string;
  }
  rentjaguarurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseSystemCommand::mutable_rentjaguarurl() {
  set_has_rentjaguarurl();
  if (rentjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    rentjaguarurl_ = new ::std::string;
  }
  return rentjaguarurl_;
}
inline ::std::string* ResponseSystemCommand::release_rentjaguarurl() {
  clear_has_rentjaguarurl();
  if (rentjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rentjaguarurl_;
    rentjaguarurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string getJaguarUrl = 7;
inline bool ResponseSystemCommand::has_getjaguarurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseSystemCommand::set_has_getjaguarurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseSystemCommand::clear_has_getjaguarurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseSystemCommand::clear_getjaguarurl() {
  if (getjaguarurl_ != &::google::protobuf::internal::kEmptyString) {
    getjaguarurl_->clear();
  }
  clear_has_getjaguarurl();
}
inline const ::std::string& ResponseSystemCommand::getjaguarurl() const {
  return *getjaguarurl_;
}
inline void ResponseSystemCommand::set_getjaguarurl(const ::std::string& value) {
  set_has_getjaguarurl();
  if (getjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    getjaguarurl_ = new ::std::string;
  }
  getjaguarurl_->assign(value);
}
inline void ResponseSystemCommand::set_getjaguarurl(const char* value) {
  set_has_getjaguarurl();
  if (getjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    getjaguarurl_ = new ::std::string;
  }
  getjaguarurl_->assign(value);
}
inline void ResponseSystemCommand::set_getjaguarurl(const char* value, size_t size) {
  set_has_getjaguarurl();
  if (getjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    getjaguarurl_ = new ::std::string;
  }
  getjaguarurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseSystemCommand::mutable_getjaguarurl() {
  set_has_getjaguarurl();
  if (getjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    getjaguarurl_ = new ::std::string;
  }
  return getjaguarurl_;
}
inline ::std::string* ResponseSystemCommand::release_getjaguarurl() {
  clear_has_getjaguarurl();
  if (getjaguarurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = getjaguarurl_;
    getjaguarurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string jaguarInfoUrl = 8;
inline bool ResponseSystemCommand::has_jaguarinfourl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseSystemCommand::set_has_jaguarinfourl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseSystemCommand::clear_has_jaguarinfourl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseSystemCommand::clear_jaguarinfourl() {
  if (jaguarinfourl_ != &::google::protobuf::internal::kEmptyString) {
    jaguarinfourl_->clear();
  }
  clear_has_jaguarinfourl();
}
inline const ::std::string& ResponseSystemCommand::jaguarinfourl() const {
  return *jaguarinfourl_;
}
inline void ResponseSystemCommand::set_jaguarinfourl(const ::std::string& value) {
  set_has_jaguarinfourl();
  if (jaguarinfourl_ == &::google::protobuf::internal::kEmptyString) {
    jaguarinfourl_ = new ::std::string;
  }
  jaguarinfourl_->assign(value);
}
inline void ResponseSystemCommand::set_jaguarinfourl(const char* value) {
  set_has_jaguarinfourl();
  if (jaguarinfourl_ == &::google::protobuf::internal::kEmptyString) {
    jaguarinfourl_ = new ::std::string;
  }
  jaguarinfourl_->assign(value);
}
inline void ResponseSystemCommand::set_jaguarinfourl(const char* value, size_t size) {
  set_has_jaguarinfourl();
  if (jaguarinfourl_ == &::google::protobuf::internal::kEmptyString) {
    jaguarinfourl_ = new ::std::string;
  }
  jaguarinfourl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseSystemCommand::mutable_jaguarinfourl() {
  set_has_jaguarinfourl();
  if (jaguarinfourl_ == &::google::protobuf::internal::kEmptyString) {
    jaguarinfourl_ = new ::std::string;
  }
  return jaguarinfourl_;
}
inline ::std::string* ResponseSystemCommand::release_jaguarinfourl() {
  clear_has_jaguarinfourl();
  if (jaguarinfourl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jaguarinfourl_;
    jaguarinfourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string servers = 9;
inline int ResponseSystemCommand::servers_size() const {
  return servers_.size();
}
inline void ResponseSystemCommand::clear_servers() {
  servers_.Clear();
}
inline const ::std::string& ResponseSystemCommand::servers(int index) const {
  return servers_.Get(index);
}
inline ::std::string* ResponseSystemCommand::mutable_servers(int index) {
  return servers_.Mutable(index);
}
inline void ResponseSystemCommand::set_servers(int index, const ::std::string& value) {
  servers_.Mutable(index)->assign(value);
}
inline void ResponseSystemCommand::set_servers(int index, const char* value) {
  servers_.Mutable(index)->assign(value);
}
inline void ResponseSystemCommand::set_servers(int index, const char* value, size_t size) {
  servers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseSystemCommand::add_servers() {
  return servers_.Add();
}
inline void ResponseSystemCommand::add_servers(const ::std::string& value) {
  servers_.Add()->assign(value);
}
inline void ResponseSystemCommand::add_servers(const char* value) {
  servers_.Add()->assign(value);
}
inline void ResponseSystemCommand::add_servers(const char* value, size_t size) {
  servers_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseSystemCommand::servers() const {
  return servers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseSystemCommand::mutable_servers() {
  return &servers_;
}

// optional bool popMOD = 10;
inline bool ResponseSystemCommand::has_popmod() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseSystemCommand::set_has_popmod() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseSystemCommand::clear_has_popmod() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseSystemCommand::clear_popmod() {
  popmod_ = false;
  clear_has_popmod();
}
inline bool ResponseSystemCommand::popmod() const {
  return popmod_;
}
inline void ResponseSystemCommand::set_popmod(bool value) {
  set_has_popmod();
  popmod_ = value;
}

// optional int32 energyRecoveringStartTime = 11;
inline bool ResponseSystemCommand::has_energyrecoveringstarttime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResponseSystemCommand::set_has_energyrecoveringstarttime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResponseSystemCommand::clear_has_energyrecoveringstarttime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResponseSystemCommand::clear_energyrecoveringstarttime() {
  energyrecoveringstarttime_ = 0;
  clear_has_energyrecoveringstarttime();
}
inline ::google::protobuf::int32 ResponseSystemCommand::energyrecoveringstarttime() const {
  return energyrecoveringstarttime_;
}
inline void ResponseSystemCommand::set_energyrecoveringstarttime(::google::protobuf::int32 value) {
  set_has_energyrecoveringstarttime();
  energyrecoveringstarttime_ = value;
}

// optional int32 energyRecoveringPeriod = 12;
inline bool ResponseSystemCommand::has_energyrecoveringperiod() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResponseSystemCommand::set_has_energyrecoveringperiod() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResponseSystemCommand::clear_has_energyrecoveringperiod() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResponseSystemCommand::clear_energyrecoveringperiod() {
  energyrecoveringperiod_ = 0;
  clear_has_energyrecoveringperiod();
}
inline ::google::protobuf::int32 ResponseSystemCommand::energyrecoveringperiod() const {
  return energyrecoveringperiod_;
}
inline void ResponseSystemCommand::set_energyrecoveringperiod(::google::protobuf::int32 value) {
  set_has_energyrecoveringperiod();
  energyrecoveringperiod_ = value;
}

// optional int32 energyRecoveringNum = 13;
inline bool ResponseSystemCommand::has_energyrecoveringnum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResponseSystemCommand::set_has_energyrecoveringnum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResponseSystemCommand::clear_has_energyrecoveringnum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResponseSystemCommand::clear_energyrecoveringnum() {
  energyrecoveringnum_ = 0;
  clear_has_energyrecoveringnum();
}
inline ::google::protobuf::int32 ResponseSystemCommand::energyrecoveringnum() const {
  return energyrecoveringnum_;
}
inline void ResponseSystemCommand::set_energyrecoveringnum(::google::protobuf::int32 value) {
  set_has_energyrecoveringnum();
  energyrecoveringnum_ = value;
}

// optional int32 ipspPurchaseItemCallBackType = 14;
inline bool ResponseSystemCommand::has_ipsppurchaseitemcallbacktype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResponseSystemCommand::set_has_ipsppurchaseitemcallbacktype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResponseSystemCommand::clear_has_ipsppurchaseitemcallbacktype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResponseSystemCommand::clear_ipsppurchaseitemcallbacktype() {
  ipsppurchaseitemcallbacktype_ = 0;
  clear_has_ipsppurchaseitemcallbacktype();
}
inline ::google::protobuf::int32 ResponseSystemCommand::ipsppurchaseitemcallbacktype() const {
  return ipsppurchaseitemcallbacktype_;
}
inline void ResponseSystemCommand::set_ipsppurchaseitemcallbacktype(::google::protobuf::int32 value) {
  set_has_ipsppurchaseitemcallbacktype();
  ipsppurchaseitemcallbacktype_ = value;
}

// optional int32 energyMaxNum = 15;
inline bool ResponseSystemCommand::has_energymaxnum() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ResponseSystemCommand::set_has_energymaxnum() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ResponseSystemCommand::clear_has_energymaxnum() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ResponseSystemCommand::clear_energymaxnum() {
  energymaxnum_ = 0;
  clear_has_energymaxnum();
}
inline ::google::protobuf::int32 ResponseSystemCommand::energymaxnum() const {
  return energymaxnum_;
}
inline void ResponseSystemCommand::set_energymaxnum(::google::protobuf::int32 value) {
  set_has_energymaxnum();
  energymaxnum_ = value;
}

// optional int32 newMOD = 16;
inline bool ResponseSystemCommand::has_newmod() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ResponseSystemCommand::set_has_newmod() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ResponseSystemCommand::clear_has_newmod() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ResponseSystemCommand::clear_newmod() {
  newmod_ = 0;
  clear_has_newmod();
}
inline ::google::protobuf::int32 ResponseSystemCommand::newmod() const {
  return newmod_;
}
inline void ResponseSystemCommand::set_newmod(::google::protobuf::int32 value) {
  set_has_newmod();
  newmod_ = value;
}

// -------------------------------------------------------------------

// EventOptionMessage

// optional .com.ea.eamobile.nfsmw.protoc.CashRewardMessage cashReward = 1;
inline bool EventOptionMessage::has_cashreward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventOptionMessage::set_has_cashreward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventOptionMessage::clear_has_cashreward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventOptionMessage::clear_cashreward() {
  if (cashreward_ != NULL) cashreward_->::com::ea::eamobile::nfsmw::protoc::CashRewardMessage::Clear();
  clear_has_cashreward();
}
inline const ::com::ea::eamobile::nfsmw::protoc::CashRewardMessage& EventOptionMessage::cashreward() const {
  return cashreward_ != NULL ? *cashreward_ : *default_instance_->cashreward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CashRewardMessage* EventOptionMessage::mutable_cashreward() {
  set_has_cashreward();
  if (cashreward_ == NULL) cashreward_ = new ::com::ea::eamobile::nfsmw::protoc::CashRewardMessage;
  return cashreward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CashRewardMessage* EventOptionMessage::release_cashreward() {
  clear_has_cashreward();
  ::com::ea::eamobile::nfsmw::protoc::CashRewardMessage* temp = cashreward_;
  cashreward_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.OpponentCollectionMessage opponentCollection = 2;
inline bool EventOptionMessage::has_opponentcollection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventOptionMessage::set_has_opponentcollection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventOptionMessage::clear_has_opponentcollection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventOptionMessage::clear_opponentcollection() {
  if (opponentcollection_ != NULL) opponentcollection_->::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage::Clear();
  clear_has_opponentcollection();
}
inline const ::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage& EventOptionMessage::opponentcollection() const {
  return opponentcollection_ != NULL ? *opponentcollection_ : *default_instance_->opponentcollection_;
}
inline ::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage* EventOptionMessage::mutable_opponentcollection() {
  set_has_opponentcollection();
  if (opponentcollection_ == NULL) opponentcollection_ = new ::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage;
  return opponentcollection_;
}
inline ::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage* EventOptionMessage::release_opponentcollection() {
  clear_has_opponentcollection();
  ::com::ea::eamobile::nfsmw::protoc::OpponentCollectionMessage* temp = opponentcollection_;
  opponentcollection_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RaceEventMessage raceEvent = 3;
inline bool EventOptionMessage::has_raceevent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EventOptionMessage::set_has_raceevent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EventOptionMessage::clear_has_raceevent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EventOptionMessage::clear_raceevent() {
  if (raceevent_ != NULL) raceevent_->::com::ea::eamobile::nfsmw::protoc::RaceEventMessage::Clear();
  clear_has_raceevent();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RaceEventMessage& EventOptionMessage::raceevent() const {
  return raceevent_ != NULL ? *raceevent_ : *default_instance_->raceevent_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RaceEventMessage* EventOptionMessage::mutable_raceevent() {
  set_has_raceevent();
  if (raceevent_ == NULL) raceevent_ = new ::com::ea::eamobile::nfsmw::protoc::RaceEventMessage;
  return raceevent_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RaceEventMessage* EventOptionMessage::release_raceevent() {
  clear_has_raceevent();
  ::com::ea::eamobile::nfsmw::protoc::RaceEventMessage* temp = raceevent_;
  raceevent_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.TrafficFlowMessage trafficFlow = 4;
inline bool EventOptionMessage::has_trafficflow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EventOptionMessage::set_has_trafficflow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EventOptionMessage::clear_has_trafficflow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EventOptionMessage::clear_trafficflow() {
  if (trafficflow_ != NULL) trafficflow_->::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage::Clear();
  clear_has_trafficflow();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage& EventOptionMessage::trafficflow() const {
  return trafficflow_ != NULL ? *trafficflow_ : *default_instance_->trafficflow_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage* EventOptionMessage::mutable_trafficflow() {
  set_has_trafficflow();
  if (trafficflow_ == NULL) trafficflow_ = new ::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage;
  return trafficflow_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage* EventOptionMessage::release_trafficflow() {
  clear_has_trafficflow();
  ::com::ea::eamobile::nfsmw::protoc::TrafficFlowMessage* temp = trafficflow_;
  trafficflow_ = NULL;
  return temp;
}

// required int32 modeId = 5;
inline bool EventOptionMessage::has_modeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EventOptionMessage::set_has_modeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EventOptionMessage::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EventOptionMessage::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 EventOptionMessage::modeid() const {
  return modeid_;
}
inline void EventOptionMessage::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.MedalPositionMessage MedalPosition = 6;
inline bool EventOptionMessage::has_medalposition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EventOptionMessage::set_has_medalposition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EventOptionMessage::clear_has_medalposition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EventOptionMessage::clear_medalposition() {
  if (medalposition_ != NULL) medalposition_->::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage::Clear();
  clear_has_medalposition();
}
inline const ::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage& EventOptionMessage::medalposition() const {
  return medalposition_ != NULL ? *medalposition_ : *default_instance_->medalposition_;
}
inline ::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage* EventOptionMessage::mutable_medalposition() {
  set_has_medalposition();
  if (medalposition_ == NULL) medalposition_ = new ::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage;
  return medalposition_;
}
inline ::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage* EventOptionMessage::release_medalposition() {
  clear_has_medalposition();
  ::com::ea::eamobile::nfsmw::protoc::MedalPositionMessage* temp = medalposition_;
  medalposition_ = NULL;
  return temp;
}

// required string FileName = 7;
inline bool EventOptionMessage::has_filename() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EventOptionMessage::set_has_filename() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EventOptionMessage::clear_has_filename() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EventOptionMessage::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& EventOptionMessage::filename() const {
  return *filename_;
}
inline void EventOptionMessage::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void EventOptionMessage::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void EventOptionMessage::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EventOptionMessage::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* EventOptionMessage::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .com.ea.eamobile.nfsmw.protoc.MedalScoreMessage MedalScore = 8;
inline bool EventOptionMessage::has_medalscore() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EventOptionMessage::set_has_medalscore() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EventOptionMessage::clear_has_medalscore() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EventOptionMessage::clear_medalscore() {
  if (medalscore_ != NULL) medalscore_->::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage::Clear();
  clear_has_medalscore();
}
inline const ::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage& EventOptionMessage::medalscore() const {
  return medalscore_ != NULL ? *medalscore_ : *default_instance_->medalscore_;
}
inline ::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage* EventOptionMessage::mutable_medalscore() {
  set_has_medalscore();
  if (medalscore_ == NULL) medalscore_ = new ::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage;
  return medalscore_;
}
inline ::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage* EventOptionMessage::release_medalscore() {
  clear_has_medalscore();
  ::com::ea::eamobile::nfsmw::protoc::MedalScoreMessage* temp = medalscore_;
  medalscore_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.MedalTimeMessage MedalTime = 9;
inline bool EventOptionMessage::has_medaltime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EventOptionMessage::set_has_medaltime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EventOptionMessage::clear_has_medaltime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EventOptionMessage::clear_medaltime() {
  if (medaltime_ != NULL) medaltime_->::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage::Clear();
  clear_has_medaltime();
}
inline const ::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage& EventOptionMessage::medaltime() const {
  return medaltime_ != NULL ? *medaltime_ : *default_instance_->medaltime_;
}
inline ::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage* EventOptionMessage::mutable_medaltime() {
  set_has_medaltime();
  if (medaltime_ == NULL) medaltime_ = new ::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage;
  return medaltime_;
}
inline ::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage* EventOptionMessage::release_medaltime() {
  clear_has_medaltime();
  ::com::ea::eamobile::nfsmw::protoc::MedalTimeMessage* temp = medaltime_;
  medaltime_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.CountdownInitialTimeMessage InitialTime = 10;
inline bool EventOptionMessage::has_initialtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EventOptionMessage::set_has_initialtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EventOptionMessage::clear_has_initialtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EventOptionMessage::clear_initialtime() {
  if (initialtime_ != NULL) initialtime_->::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage::Clear();
  clear_has_initialtime();
}
inline const ::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage& EventOptionMessage::initialtime() const {
  return initialtime_ != NULL ? *initialtime_ : *default_instance_->initialtime_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage* EventOptionMessage::mutable_initialtime() {
  set_has_initialtime();
  if (initialtime_ == NULL) initialtime_ = new ::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage;
  return initialtime_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage* EventOptionMessage::release_initialtime() {
  clear_has_initialtime();
  ::com::ea::eamobile::nfsmw::protoc::CountdownInitialTimeMessage* temp = initialtime_;
  initialtime_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.PenaltyTimeMessage PenaltyTime = 11;
inline bool EventOptionMessage::has_penaltytime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EventOptionMessage::set_has_penaltytime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EventOptionMessage::clear_has_penaltytime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EventOptionMessage::clear_penaltytime() {
  if (penaltytime_ != NULL) penaltytime_->::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage::Clear();
  clear_has_penaltytime();
}
inline const ::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage& EventOptionMessage::penaltytime() const {
  return penaltytime_ != NULL ? *penaltytime_ : *default_instance_->penaltytime_;
}
inline ::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage* EventOptionMessage::mutable_penaltytime() {
  set_has_penaltytime();
  if (penaltytime_ == NULL) penaltytime_ = new ::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage;
  return penaltytime_;
}
inline ::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage* EventOptionMessage::release_penaltytime() {
  clear_has_penaltytime();
  ::com::ea::eamobile::nfsmw::protoc::PenaltyTimeMessage* temp = penaltytime_;
  penaltytime_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CashRewardMessage

// optional int32 bronze = 1;
inline bool CashRewardMessage::has_bronze() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CashRewardMessage::set_has_bronze() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CashRewardMessage::clear_has_bronze() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CashRewardMessage::clear_bronze() {
  bronze_ = 0;
  clear_has_bronze();
}
inline ::google::protobuf::int32 CashRewardMessage::bronze() const {
  return bronze_;
}
inline void CashRewardMessage::set_bronze(::google::protobuf::int32 value) {
  set_has_bronze();
  bronze_ = value;
}

// optional int32 silver = 2;
inline bool CashRewardMessage::has_silver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CashRewardMessage::set_has_silver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CashRewardMessage::clear_has_silver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CashRewardMessage::clear_silver() {
  silver_ = 0;
  clear_has_silver();
}
inline ::google::protobuf::int32 CashRewardMessage::silver() const {
  return silver_;
}
inline void CashRewardMessage::set_silver(::google::protobuf::int32 value) {
  set_has_silver();
  silver_ = value;
}

// optional int32 gold = 3;
inline bool CashRewardMessage::has_gold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CashRewardMessage::set_has_gold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CashRewardMessage::clear_has_gold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CashRewardMessage::clear_gold() {
  gold_ = 0;
  clear_has_gold();
}
inline ::google::protobuf::int32 CashRewardMessage::gold() const {
  return gold_;
}
inline void CashRewardMessage::set_gold(::google::protobuf::int32 value) {
  set_has_gold();
  gold_ = value;
}

// -------------------------------------------------------------------

// MedalPositionMessage

// optional int32 PositionBronze = 1;
inline bool MedalPositionMessage::has_positionbronze() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MedalPositionMessage::set_has_positionbronze() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MedalPositionMessage::clear_has_positionbronze() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MedalPositionMessage::clear_positionbronze() {
  positionbronze_ = 0;
  clear_has_positionbronze();
}
inline ::google::protobuf::int32 MedalPositionMessage::positionbronze() const {
  return positionbronze_;
}
inline void MedalPositionMessage::set_positionbronze(::google::protobuf::int32 value) {
  set_has_positionbronze();
  positionbronze_ = value;
}

// optional int32 PositionSilver = 2;
inline bool MedalPositionMessage::has_positionsilver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MedalPositionMessage::set_has_positionsilver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MedalPositionMessage::clear_has_positionsilver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MedalPositionMessage::clear_positionsilver() {
  positionsilver_ = 0;
  clear_has_positionsilver();
}
inline ::google::protobuf::int32 MedalPositionMessage::positionsilver() const {
  return positionsilver_;
}
inline void MedalPositionMessage::set_positionsilver(::google::protobuf::int32 value) {
  set_has_positionsilver();
  positionsilver_ = value;
}

// optional int32 PositionGold = 3;
inline bool MedalPositionMessage::has_positiongold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MedalPositionMessage::set_has_positiongold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MedalPositionMessage::clear_has_positiongold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MedalPositionMessage::clear_positiongold() {
  positiongold_ = 0;
  clear_has_positiongold();
}
inline ::google::protobuf::int32 MedalPositionMessage::positiongold() const {
  return positiongold_;
}
inline void MedalPositionMessage::set_positiongold(::google::protobuf::int32 value) {
  set_has_positiongold();
  positiongold_ = value;
}

// -------------------------------------------------------------------

// MedalScoreMessage

// optional int32 ScoreBronze = 1;
inline bool MedalScoreMessage::has_scorebronze() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MedalScoreMessage::set_has_scorebronze() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MedalScoreMessage::clear_has_scorebronze() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MedalScoreMessage::clear_scorebronze() {
  scorebronze_ = 0;
  clear_has_scorebronze();
}
inline ::google::protobuf::int32 MedalScoreMessage::scorebronze() const {
  return scorebronze_;
}
inline void MedalScoreMessage::set_scorebronze(::google::protobuf::int32 value) {
  set_has_scorebronze();
  scorebronze_ = value;
}

// optional int32 ScoreSilver = 2;
inline bool MedalScoreMessage::has_scoresilver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MedalScoreMessage::set_has_scoresilver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MedalScoreMessage::clear_has_scoresilver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MedalScoreMessage::clear_scoresilver() {
  scoresilver_ = 0;
  clear_has_scoresilver();
}
inline ::google::protobuf::int32 MedalScoreMessage::scoresilver() const {
  return scoresilver_;
}
inline void MedalScoreMessage::set_scoresilver(::google::protobuf::int32 value) {
  set_has_scoresilver();
  scoresilver_ = value;
}

// optional int32 ScoreGold = 3;
inline bool MedalScoreMessage::has_scoregold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MedalScoreMessage::set_has_scoregold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MedalScoreMessage::clear_has_scoregold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MedalScoreMessage::clear_scoregold() {
  scoregold_ = 0;
  clear_has_scoregold();
}
inline ::google::protobuf::int32 MedalScoreMessage::scoregold() const {
  return scoregold_;
}
inline void MedalScoreMessage::set_scoregold(::google::protobuf::int32 value) {
  set_has_scoregold();
  scoregold_ = value;
}

// -------------------------------------------------------------------

// MedalTimeMessage

// optional float TimeBronze = 1;
inline bool MedalTimeMessage::has_timebronze() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MedalTimeMessage::set_has_timebronze() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MedalTimeMessage::clear_has_timebronze() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MedalTimeMessage::clear_timebronze() {
  timebronze_ = 0;
  clear_has_timebronze();
}
inline float MedalTimeMessage::timebronze() const {
  return timebronze_;
}
inline void MedalTimeMessage::set_timebronze(float value) {
  set_has_timebronze();
  timebronze_ = value;
}

// optional float TimeSilver = 2;
inline bool MedalTimeMessage::has_timesilver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MedalTimeMessage::set_has_timesilver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MedalTimeMessage::clear_has_timesilver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MedalTimeMessage::clear_timesilver() {
  timesilver_ = 0;
  clear_has_timesilver();
}
inline float MedalTimeMessage::timesilver() const {
  return timesilver_;
}
inline void MedalTimeMessage::set_timesilver(float value) {
  set_has_timesilver();
  timesilver_ = value;
}

// optional float TimeGold = 3;
inline bool MedalTimeMessage::has_timegold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MedalTimeMessage::set_has_timegold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MedalTimeMessage::clear_has_timegold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MedalTimeMessage::clear_timegold() {
  timegold_ = 0;
  clear_has_timegold();
}
inline float MedalTimeMessage::timegold() const {
  return timegold_;
}
inline void MedalTimeMessage::set_timegold(float value) {
  set_has_timegold();
  timegold_ = value;
}

// -------------------------------------------------------------------

// CountdownInitialTimeMessage

// optional float InitialTime = 1;
inline bool CountdownInitialTimeMessage::has_initialtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CountdownInitialTimeMessage::set_has_initialtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CountdownInitialTimeMessage::clear_has_initialtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CountdownInitialTimeMessage::clear_initialtime() {
  initialtime_ = 0;
  clear_has_initialtime();
}
inline float CountdownInitialTimeMessage::initialtime() const {
  return initialtime_;
}
inline void CountdownInitialTimeMessage::set_initialtime(float value) {
  set_has_initialtime();
  initialtime_ = value;
}

// -------------------------------------------------------------------

// PenaltyTimeMessage

// optional float MaximumTime = 1;
inline bool PenaltyTimeMessage::has_maximumtime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PenaltyTimeMessage::set_has_maximumtime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PenaltyTimeMessage::clear_has_maximumtime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PenaltyTimeMessage::clear_maximumtime() {
  maximumtime_ = 0;
  clear_has_maximumtime();
}
inline float PenaltyTimeMessage::maximumtime() const {
  return maximumtime_;
}
inline void PenaltyTimeMessage::set_maximumtime(float value) {
  set_has_maximumtime();
  maximumtime_ = value;
}

// -------------------------------------------------------------------

// OpponentCollectionMessage

// repeated .com.ea.eamobile.nfsmw.protoc.OpponentMessage opponent = 1;
inline int OpponentCollectionMessage::opponent_size() const {
  return opponent_.size();
}
inline void OpponentCollectionMessage::clear_opponent() {
  opponent_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::OpponentMessage& OpponentCollectionMessage::opponent(int index) const {
  return opponent_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::OpponentMessage* OpponentCollectionMessage::mutable_opponent(int index) {
  return opponent_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::OpponentMessage* OpponentCollectionMessage::add_opponent() {
  return opponent_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::OpponentMessage >&
OpponentCollectionMessage::opponent() const {
  return opponent_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::OpponentMessage >*
OpponentCollectionMessage::mutable_opponent() {
  return &opponent_;
}

// -------------------------------------------------------------------

// OpponentMessage

// optional string driverName = 1;
inline bool OpponentMessage::has_drivername() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpponentMessage::set_has_drivername() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpponentMessage::clear_has_drivername() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpponentMessage::clear_drivername() {
  if (drivername_ != &::google::protobuf::internal::kEmptyString) {
    drivername_->clear();
  }
  clear_has_drivername();
}
inline const ::std::string& OpponentMessage::drivername() const {
  return *drivername_;
}
inline void OpponentMessage::set_drivername(const ::std::string& value) {
  set_has_drivername();
  if (drivername_ == &::google::protobuf::internal::kEmptyString) {
    drivername_ = new ::std::string;
  }
  drivername_->assign(value);
}
inline void OpponentMessage::set_drivername(const char* value) {
  set_has_drivername();
  if (drivername_ == &::google::protobuf::internal::kEmptyString) {
    drivername_ = new ::std::string;
  }
  drivername_->assign(value);
}
inline void OpponentMessage::set_drivername(const char* value, size_t size) {
  set_has_drivername();
  if (drivername_ == &::google::protobuf::internal::kEmptyString) {
    drivername_ = new ::std::string;
  }
  drivername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpponentMessage::mutable_drivername() {
  set_has_drivername();
  if (drivername_ == &::google::protobuf::internal::kEmptyString) {
    drivername_ = new ::std::string;
  }
  return drivername_;
}
inline ::std::string* OpponentMessage::release_drivername() {
  clear_has_drivername();
  if (drivername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = drivername_;
    drivername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string carDescriptionName = 2;
inline bool OpponentMessage::has_cardescriptionname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpponentMessage::set_has_cardescriptionname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpponentMessage::clear_has_cardescriptionname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpponentMessage::clear_cardescriptionname() {
  if (cardescriptionname_ != &::google::protobuf::internal::kEmptyString) {
    cardescriptionname_->clear();
  }
  clear_has_cardescriptionname();
}
inline const ::std::string& OpponentMessage::cardescriptionname() const {
  return *cardescriptionname_;
}
inline void OpponentMessage::set_cardescriptionname(const ::std::string& value) {
  set_has_cardescriptionname();
  if (cardescriptionname_ == &::google::protobuf::internal::kEmptyString) {
    cardescriptionname_ = new ::std::string;
  }
  cardescriptionname_->assign(value);
}
inline void OpponentMessage::set_cardescriptionname(const char* value) {
  set_has_cardescriptionname();
  if (cardescriptionname_ == &::google::protobuf::internal::kEmptyString) {
    cardescriptionname_ = new ::std::string;
  }
  cardescriptionname_->assign(value);
}
inline void OpponentMessage::set_cardescriptionname(const char* value, size_t size) {
  set_has_cardescriptionname();
  if (cardescriptionname_ == &::google::protobuf::internal::kEmptyString) {
    cardescriptionname_ = new ::std::string;
  }
  cardescriptionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpponentMessage::mutable_cardescriptionname() {
  set_has_cardescriptionname();
  if (cardescriptionname_ == &::google::protobuf::internal::kEmptyString) {
    cardescriptionname_ = new ::std::string;
  }
  return cardescriptionname_;
}
inline ::std::string* OpponentMessage::release_cardescriptionname() {
  clear_has_cardescriptionname();
  if (cardescriptionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cardescriptionname_;
    cardescriptionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 colourIndex = 3;
inline bool OpponentMessage::has_colourindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpponentMessage::set_has_colourindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpponentMessage::clear_has_colourindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpponentMessage::clear_colourindex() {
  colourindex_ = 0;
  clear_has_colourindex();
}
inline ::google::protobuf::int32 OpponentMessage::colourindex() const {
  return colourindex_;
}
inline void OpponentMessage::set_colourindex(::google::protobuf::int32 value) {
  set_has_colourindex();
  colourindex_ = value;
}

// optional bool stationary = 4;
inline bool OpponentMessage::has_stationary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpponentMessage::set_has_stationary() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpponentMessage::clear_has_stationary() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpponentMessage::clear_stationary() {
  stationary_ = false;
  clear_has_stationary();
}
inline bool OpponentMessage::stationary() const {
  return stationary_;
}
inline void OpponentMessage::set_stationary(bool value) {
  set_has_stationary();
  stationary_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.AiSettingsMessage aiSettings = 5;
inline bool OpponentMessage::has_aisettings() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpponentMessage::set_has_aisettings() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpponentMessage::clear_has_aisettings() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpponentMessage::clear_aisettings() {
  if (aisettings_ != NULL) aisettings_->::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage::Clear();
  clear_has_aisettings();
}
inline const ::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage& OpponentMessage::aisettings() const {
  return aisettings_ != NULL ? *aisettings_ : *default_instance_->aisettings_;
}
inline ::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage* OpponentMessage::mutable_aisettings() {
  set_has_aisettings();
  if (aisettings_ == NULL) aisettings_ = new ::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage;
  return aisettings_;
}
inline ::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage* OpponentMessage::release_aisettings() {
  clear_has_aisettings();
  ::com::ea::eamobile::nfsmw::protoc::AiSettingsMessage* temp = aisettings_;
  aisettings_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AiSettingsMessage

// optional float speedFactor = 1;
inline bool AiSettingsMessage::has_speedfactor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AiSettingsMessage::set_has_speedfactor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AiSettingsMessage::clear_has_speedfactor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AiSettingsMessage::clear_speedfactor() {
  speedfactor_ = 0;
  clear_has_speedfactor();
}
inline float AiSettingsMessage::speedfactor() const {
  return speedfactor_;
}
inline void AiSettingsMessage::set_speedfactor(float value) {
  set_has_speedfactor();
  speedfactor_ = value;
}

// optional float corneringFactor = 2;
inline bool AiSettingsMessage::has_corneringfactor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AiSettingsMessage::set_has_corneringfactor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AiSettingsMessage::clear_has_corneringfactor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AiSettingsMessage::clear_corneringfactor() {
  corneringfactor_ = 0;
  clear_has_corneringfactor();
}
inline float AiSettingsMessage::corneringfactor() const {
  return corneringfactor_;
}
inline void AiSettingsMessage::set_corneringfactor(float value) {
  set_has_corneringfactor();
  corneringfactor_ = value;
}

// optional float racingLineScale = 3;
inline bool AiSettingsMessage::has_racinglinescale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AiSettingsMessage::set_has_racinglinescale() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AiSettingsMessage::clear_has_racinglinescale() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AiSettingsMessage::clear_racinglinescale() {
  racinglinescale_ = 0;
  clear_has_racinglinescale();
}
inline float AiSettingsMessage::racinglinescale() const {
  return racinglinescale_;
}
inline void AiSettingsMessage::set_racinglinescale(float value) {
  set_has_racinglinescale();
  racinglinescale_ = value;
}

// optional int32 rubberBandingTweaksToUse = 4;
inline bool AiSettingsMessage::has_rubberbandingtweakstouse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AiSettingsMessage::set_has_rubberbandingtweakstouse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AiSettingsMessage::clear_has_rubberbandingtweakstouse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AiSettingsMessage::clear_rubberbandingtweakstouse() {
  rubberbandingtweakstouse_ = 0;
  clear_has_rubberbandingtweakstouse();
}
inline ::google::protobuf::int32 AiSettingsMessage::rubberbandingtweakstouse() const {
  return rubberbandingtweakstouse_;
}
inline void AiSettingsMessage::set_rubberbandingtweakstouse(::google::protobuf::int32 value) {
  set_has_rubberbandingtweakstouse();
  rubberbandingtweakstouse_ = value;
}

// optional float rubberBandingDifficulty = 5;
inline bool AiSettingsMessage::has_rubberbandingdifficulty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AiSettingsMessage::set_has_rubberbandingdifficulty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AiSettingsMessage::clear_has_rubberbandingdifficulty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AiSettingsMessage::clear_rubberbandingdifficulty() {
  rubberbandingdifficulty_ = 0;
  clear_has_rubberbandingdifficulty();
}
inline float AiSettingsMessage::rubberbandingdifficulty() const {
  return rubberbandingdifficulty_;
}
inline void AiSettingsMessage::set_rubberbandingdifficulty(float value) {
  set_has_rubberbandingdifficulty();
  rubberbandingdifficulty_ = value;
}

// optional float rubberBandingTargetDifficulty = 6;
inline bool AiSettingsMessage::has_rubberbandingtargetdifficulty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AiSettingsMessage::set_has_rubberbandingtargetdifficulty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AiSettingsMessage::clear_has_rubberbandingtargetdifficulty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AiSettingsMessage::clear_rubberbandingtargetdifficulty() {
  rubberbandingtargetdifficulty_ = 0;
  clear_has_rubberbandingtargetdifficulty();
}
inline float AiSettingsMessage::rubberbandingtargetdifficulty() const {
  return rubberbandingtargetdifficulty_;
}
inline void AiSettingsMessage::set_rubberbandingtargetdifficulty(float value) {
  set_has_rubberbandingtargetdifficulty();
  rubberbandingtargetdifficulty_ = value;
}

// optional float pathfindingSkill = 7;
inline bool AiSettingsMessage::has_pathfindingskill() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AiSettingsMessage::set_has_pathfindingskill() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AiSettingsMessage::clear_has_pathfindingskill() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AiSettingsMessage::clear_pathfindingskill() {
  pathfindingskill_ = 0;
  clear_has_pathfindingskill();
}
inline float AiSettingsMessage::pathfindingskill() const {
  return pathfindingskill_;
}
inline void AiSettingsMessage::set_pathfindingskill(float value) {
  set_has_pathfindingskill();
  pathfindingskill_ = value;
}

// optional float nitroSkill = 8;
inline bool AiSettingsMessage::has_nitroskill() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AiSettingsMessage::set_has_nitroskill() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AiSettingsMessage::clear_has_nitroskill() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AiSettingsMessage::clear_nitroskill() {
  nitroskill_ = 0;
  clear_has_nitroskill();
}
inline float AiSettingsMessage::nitroskill() const {
  return nitroskill_;
}
inline void AiSettingsMessage::set_nitroskill(float value) {
  set_has_nitroskill();
  nitroskill_ = value;
}

// optional float maxHealth = 9;
inline bool AiSettingsMessage::has_maxhealth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AiSettingsMessage::set_has_maxhealth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AiSettingsMessage::clear_has_maxhealth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AiSettingsMessage::clear_maxhealth() {
  maxhealth_ = 0;
  clear_has_maxhealth();
}
inline float AiSettingsMessage::maxhealth() const {
  return maxhealth_;
}
inline void AiSettingsMessage::set_maxhealth(float value) {
  set_has_maxhealth();
  maxhealth_ = value;
}

// -------------------------------------------------------------------

// RaceEventMessage

// optional string raceType = 1;
inline bool RaceEventMessage::has_racetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaceEventMessage::set_has_racetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaceEventMessage::clear_has_racetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaceEventMessage::clear_racetype() {
  if (racetype_ != &::google::protobuf::internal::kEmptyString) {
    racetype_->clear();
  }
  clear_has_racetype();
}
inline const ::std::string& RaceEventMessage::racetype() const {
  return *racetype_;
}
inline void RaceEventMessage::set_racetype(const ::std::string& value) {
  set_has_racetype();
  if (racetype_ == &::google::protobuf::internal::kEmptyString) {
    racetype_ = new ::std::string;
  }
  racetype_->assign(value);
}
inline void RaceEventMessage::set_racetype(const char* value) {
  set_has_racetype();
  if (racetype_ == &::google::protobuf::internal::kEmptyString) {
    racetype_ = new ::std::string;
  }
  racetype_->assign(value);
}
inline void RaceEventMessage::set_racetype(const char* value, size_t size) {
  set_has_racetype();
  if (racetype_ == &::google::protobuf::internal::kEmptyString) {
    racetype_ = new ::std::string;
  }
  racetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_racetype() {
  set_has_racetype();
  if (racetype_ == &::google::protobuf::internal::kEmptyString) {
    racetype_ = new ::std::string;
  }
  return racetype_;
}
inline ::std::string* RaceEventMessage::release_racetype() {
  clear_has_racetype();
  if (racetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = racetype_;
    racetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string raceFSMPrefabOverride = 2;
inline bool RaceEventMessage::has_racefsmprefaboverride() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaceEventMessage::set_has_racefsmprefaboverride() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaceEventMessage::clear_has_racefsmprefaboverride() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaceEventMessage::clear_racefsmprefaboverride() {
  if (racefsmprefaboverride_ != &::google::protobuf::internal::kEmptyString) {
    racefsmprefaboverride_->clear();
  }
  clear_has_racefsmprefaboverride();
}
inline const ::std::string& RaceEventMessage::racefsmprefaboverride() const {
  return *racefsmprefaboverride_;
}
inline void RaceEventMessage::set_racefsmprefaboverride(const ::std::string& value) {
  set_has_racefsmprefaboverride();
  if (racefsmprefaboverride_ == &::google::protobuf::internal::kEmptyString) {
    racefsmprefaboverride_ = new ::std::string;
  }
  racefsmprefaboverride_->assign(value);
}
inline void RaceEventMessage::set_racefsmprefaboverride(const char* value) {
  set_has_racefsmprefaboverride();
  if (racefsmprefaboverride_ == &::google::protobuf::internal::kEmptyString) {
    racefsmprefaboverride_ = new ::std::string;
  }
  racefsmprefaboverride_->assign(value);
}
inline void RaceEventMessage::set_racefsmprefaboverride(const char* value, size_t size) {
  set_has_racefsmprefaboverride();
  if (racefsmprefaboverride_ == &::google::protobuf::internal::kEmptyString) {
    racefsmprefaboverride_ = new ::std::string;
  }
  racefsmprefaboverride_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_racefsmprefaboverride() {
  set_has_racefsmprefaboverride();
  if (racefsmprefaboverride_ == &::google::protobuf::internal::kEmptyString) {
    racefsmprefaboverride_ = new ::std::string;
  }
  return racefsmprefaboverride_;
}
inline ::std::string* RaceEventMessage::release_racefsmprefaboverride() {
  clear_has_racefsmprefaboverride();
  if (racefsmprefaboverride_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = racefsmprefaboverride_;
    racefsmprefaboverride_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string carRestriction = 3;
inline bool RaceEventMessage::has_carrestriction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RaceEventMessage::set_has_carrestriction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RaceEventMessage::clear_has_carrestriction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RaceEventMessage::clear_carrestriction() {
  if (carrestriction_ != &::google::protobuf::internal::kEmptyString) {
    carrestriction_->clear();
  }
  clear_has_carrestriction();
}
inline const ::std::string& RaceEventMessage::carrestriction() const {
  return *carrestriction_;
}
inline void RaceEventMessage::set_carrestriction(const ::std::string& value) {
  set_has_carrestriction();
  if (carrestriction_ == &::google::protobuf::internal::kEmptyString) {
    carrestriction_ = new ::std::string;
  }
  carrestriction_->assign(value);
}
inline void RaceEventMessage::set_carrestriction(const char* value) {
  set_has_carrestriction();
  if (carrestriction_ == &::google::protobuf::internal::kEmptyString) {
    carrestriction_ = new ::std::string;
  }
  carrestriction_->assign(value);
}
inline void RaceEventMessage::set_carrestriction(const char* value, size_t size) {
  set_has_carrestriction();
  if (carrestriction_ == &::google::protobuf::internal::kEmptyString) {
    carrestriction_ = new ::std::string;
  }
  carrestriction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_carrestriction() {
  set_has_carrestriction();
  if (carrestriction_ == &::google::protobuf::internal::kEmptyString) {
    carrestriction_ = new ::std::string;
  }
  return carrestriction_;
}
inline ::std::string* RaceEventMessage::release_carrestriction() {
  clear_has_carrestriction();
  if (carrestriction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carrestriction_;
    carrestriction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string trackName = 4;
inline bool RaceEventMessage::has_trackname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RaceEventMessage::set_has_trackname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RaceEventMessage::clear_has_trackname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RaceEventMessage::clear_trackname() {
  if (trackname_ != &::google::protobuf::internal::kEmptyString) {
    trackname_->clear();
  }
  clear_has_trackname();
}
inline const ::std::string& RaceEventMessage::trackname() const {
  return *trackname_;
}
inline void RaceEventMessage::set_trackname(const ::std::string& value) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(value);
}
inline void RaceEventMessage::set_trackname(const char* value) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(value);
}
inline void RaceEventMessage::set_trackname(const char* value, size_t size) {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  trackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_trackname() {
  set_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    trackname_ = new ::std::string;
  }
  return trackname_;
}
inline ::std::string* RaceEventMessage::release_trackname() {
  clear_has_trackname();
  if (trackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trackname_;
    trackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string name = 5;
inline bool RaceEventMessage::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RaceEventMessage::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RaceEventMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RaceEventMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RaceEventMessage::name() const {
  return *name_;
}
inline void RaceEventMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RaceEventMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RaceEventMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RaceEventMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string location = 6;
inline bool RaceEventMessage::has_location() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RaceEventMessage::set_has_location() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RaceEventMessage::clear_has_location() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RaceEventMessage::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& RaceEventMessage::location() const {
  return *location_;
}
inline void RaceEventMessage::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void RaceEventMessage::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void RaceEventMessage::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* RaceEventMessage::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool blacklistEvent = 7;
inline bool RaceEventMessage::has_blacklistevent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RaceEventMessage::set_has_blacklistevent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RaceEventMessage::clear_has_blacklistevent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RaceEventMessage::clear_blacklistevent() {
  blacklistevent_ = false;
  clear_has_blacklistevent();
}
inline bool RaceEventMessage::blacklistevent() const {
  return blacklistevent_;
}
inline void RaceEventMessage::set_blacklistevent(bool value) {
  set_has_blacklistevent();
  blacklistevent_ = value;
}

// optional int32 classRestriction = 8;
inline bool RaceEventMessage::has_classrestriction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RaceEventMessage::set_has_classrestriction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RaceEventMessage::clear_has_classrestriction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RaceEventMessage::clear_classrestriction() {
  classrestriction_ = 0;
  clear_has_classrestriction();
}
inline ::google::protobuf::int32 RaceEventMessage::classrestriction() const {
  return classrestriction_;
}
inline void RaceEventMessage::set_classrestriction(::google::protobuf::int32 value) {
  set_has_classrestriction();
  classrestriction_ = value;
}

// optional string environmentPrefab = 9;
inline bool RaceEventMessage::has_environmentprefab() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RaceEventMessage::set_has_environmentprefab() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RaceEventMessage::clear_has_environmentprefab() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RaceEventMessage::clear_environmentprefab() {
  if (environmentprefab_ != &::google::protobuf::internal::kEmptyString) {
    environmentprefab_->clear();
  }
  clear_has_environmentprefab();
}
inline const ::std::string& RaceEventMessage::environmentprefab() const {
  return *environmentprefab_;
}
inline void RaceEventMessage::set_environmentprefab(const ::std::string& value) {
  set_has_environmentprefab();
  if (environmentprefab_ == &::google::protobuf::internal::kEmptyString) {
    environmentprefab_ = new ::std::string;
  }
  environmentprefab_->assign(value);
}
inline void RaceEventMessage::set_environmentprefab(const char* value) {
  set_has_environmentprefab();
  if (environmentprefab_ == &::google::protobuf::internal::kEmptyString) {
    environmentprefab_ = new ::std::string;
  }
  environmentprefab_->assign(value);
}
inline void RaceEventMessage::set_environmentprefab(const char* value, size_t size) {
  set_has_environmentprefab();
  if (environmentprefab_ == &::google::protobuf::internal::kEmptyString) {
    environmentprefab_ = new ::std::string;
  }
  environmentprefab_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_environmentprefab() {
  set_has_environmentprefab();
  if (environmentprefab_ == &::google::protobuf::internal::kEmptyString) {
    environmentprefab_ = new ::std::string;
  }
  return environmentprefab_;
}
inline ::std::string* RaceEventMessage::release_environmentprefab() {
  clear_has_environmentprefab();
  if (environmentprefab_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = environmentprefab_;
    environmentprefab_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 trafficCarCount = 10;
inline bool RaceEventMessage::has_trafficcarcount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RaceEventMessage::set_has_trafficcarcount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RaceEventMessage::clear_has_trafficcarcount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RaceEventMessage::clear_trafficcarcount() {
  trafficcarcount_ = 0;
  clear_has_trafficcarcount();
}
inline ::google::protobuf::int32 RaceEventMessage::trafficcarcount() const {
  return trafficcarcount_;
}
inline void RaceEventMessage::set_trafficcarcount(::google::protobuf::int32 value) {
  set_has_trafficcarcount();
  trafficcarcount_ = value;
}

// optional bool openWorldTrack = 11;
inline bool RaceEventMessage::has_openworldtrack() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RaceEventMessage::set_has_openworldtrack() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RaceEventMessage::clear_has_openworldtrack() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RaceEventMessage::clear_openworldtrack() {
  openworldtrack_ = false;
  clear_has_openworldtrack();
}
inline bool RaceEventMessage::openworldtrack() const {
  return openworldtrack_;
}
inline void RaceEventMessage::set_openworldtrack(bool value) {
  set_has_openworldtrack();
  openworldtrack_ = value;
}

// optional int32 autoLogId = 12;
inline bool RaceEventMessage::has_autologid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RaceEventMessage::set_has_autologid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RaceEventMessage::clear_has_autologid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RaceEventMessage::clear_autologid() {
  autologid_ = 0;
  clear_has_autologid();
}
inline ::google::protobuf::int32 RaceEventMessage::autologid() const {
  return autologid_;
}
inline void RaceEventMessage::set_autologid(::google::protobuf::int32 value) {
  set_has_autologid();
  autologid_ = value;
}

// optional string pursuitType = 13;
inline bool RaceEventMessage::has_pursuittype() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RaceEventMessage::set_has_pursuittype() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RaceEventMessage::clear_has_pursuittype() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RaceEventMessage::clear_pursuittype() {
  if (pursuittype_ != &::google::protobuf::internal::kEmptyString) {
    pursuittype_->clear();
  }
  clear_has_pursuittype();
}
inline const ::std::string& RaceEventMessage::pursuittype() const {
  return *pursuittype_;
}
inline void RaceEventMessage::set_pursuittype(const ::std::string& value) {
  set_has_pursuittype();
  if (pursuittype_ == &::google::protobuf::internal::kEmptyString) {
    pursuittype_ = new ::std::string;
  }
  pursuittype_->assign(value);
}
inline void RaceEventMessage::set_pursuittype(const char* value) {
  set_has_pursuittype();
  if (pursuittype_ == &::google::protobuf::internal::kEmptyString) {
    pursuittype_ = new ::std::string;
  }
  pursuittype_->assign(value);
}
inline void RaceEventMessage::set_pursuittype(const char* value, size_t size) {
  set_has_pursuittype();
  if (pursuittype_ == &::google::protobuf::internal::kEmptyString) {
    pursuittype_ = new ::std::string;
  }
  pursuittype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_pursuittype() {
  set_has_pursuittype();
  if (pursuittype_ == &::google::protobuf::internal::kEmptyString) {
    pursuittype_ = new ::std::string;
  }
  return pursuittype_;
}
inline ::std::string* RaceEventMessage::release_pursuittype() {
  clear_has_pursuittype();
  if (pursuittype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pursuittype_;
    pursuittype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional float startLineNoSpawnZone = 14;
inline bool RaceEventMessage::has_startlinenospawnzone() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RaceEventMessage::set_has_startlinenospawnzone() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RaceEventMessage::clear_has_startlinenospawnzone() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RaceEventMessage::clear_startlinenospawnzone() {
  startlinenospawnzone_ = 0;
  clear_has_startlinenospawnzone();
}
inline float RaceEventMessage::startlinenospawnzone() const {
  return startlinenospawnzone_;
}
inline void RaceEventMessage::set_startlinenospawnzone(float value) {
  set_has_startlinenospawnzone();
  startlinenospawnzone_ = value;
}

// optional float finishLineNoSpawnZone = 15;
inline bool RaceEventMessage::has_finishlinenospawnzone() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RaceEventMessage::set_has_finishlinenospawnzone() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RaceEventMessage::clear_has_finishlinenospawnzone() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RaceEventMessage::clear_finishlinenospawnzone() {
  finishlinenospawnzone_ = 0;
  clear_has_finishlinenospawnzone();
}
inline float RaceEventMessage::finishlinenospawnzone() const {
  return finishlinenospawnzone_;
}
inline void RaceEventMessage::set_finishlinenospawnzone(float value) {
  set_has_finishlinenospawnzone();
  finishlinenospawnzone_ = value;
}

// optional float spawnDistance = 16;
inline bool RaceEventMessage::has_spawndistance() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RaceEventMessage::set_has_spawndistance() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RaceEventMessage::clear_has_spawndistance() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RaceEventMessage::clear_spawndistance() {
  spawndistance_ = 0;
  clear_has_spawndistance();
}
inline float RaceEventMessage::spawndistance() const {
  return spawndistance_;
}
inline void RaceEventMessage::set_spawndistance(float value) {
  set_has_spawndistance();
  spawndistance_ = value;
}

// optional string startLine = 17;
inline bool RaceEventMessage::has_startline() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RaceEventMessage::set_has_startline() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RaceEventMessage::clear_has_startline() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RaceEventMessage::clear_startline() {
  if (startline_ != &::google::protobuf::internal::kEmptyString) {
    startline_->clear();
  }
  clear_has_startline();
}
inline const ::std::string& RaceEventMessage::startline() const {
  return *startline_;
}
inline void RaceEventMessage::set_startline(const ::std::string& value) {
  set_has_startline();
  if (startline_ == &::google::protobuf::internal::kEmptyString) {
    startline_ = new ::std::string;
  }
  startline_->assign(value);
}
inline void RaceEventMessage::set_startline(const char* value) {
  set_has_startline();
  if (startline_ == &::google::protobuf::internal::kEmptyString) {
    startline_ = new ::std::string;
  }
  startline_->assign(value);
}
inline void RaceEventMessage::set_startline(const char* value, size_t size) {
  set_has_startline();
  if (startline_ == &::google::protobuf::internal::kEmptyString) {
    startline_ = new ::std::string;
  }
  startline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_startline() {
  set_has_startline();
  if (startline_ == &::google::protobuf::internal::kEmptyString) {
    startline_ = new ::std::string;
  }
  return startline_;
}
inline ::std::string* RaceEventMessage::release_startline() {
  clear_has_startline();
  if (startline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startline_;
    startline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string finishLine = 18;
inline bool RaceEventMessage::has_finishline() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RaceEventMessage::set_has_finishline() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RaceEventMessage::clear_has_finishline() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RaceEventMessage::clear_finishline() {
  if (finishline_ != &::google::protobuf::internal::kEmptyString) {
    finishline_->clear();
  }
  clear_has_finishline();
}
inline const ::std::string& RaceEventMessage::finishline() const {
  return *finishline_;
}
inline void RaceEventMessage::set_finishline(const ::std::string& value) {
  set_has_finishline();
  if (finishline_ == &::google::protobuf::internal::kEmptyString) {
    finishline_ = new ::std::string;
  }
  finishline_->assign(value);
}
inline void RaceEventMessage::set_finishline(const char* value) {
  set_has_finishline();
  if (finishline_ == &::google::protobuf::internal::kEmptyString) {
    finishline_ = new ::std::string;
  }
  finishline_->assign(value);
}
inline void RaceEventMessage::set_finishline(const char* value, size_t size) {
  set_has_finishline();
  if (finishline_ == &::google::protobuf::internal::kEmptyString) {
    finishline_ = new ::std::string;
  }
  finishline_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_finishline() {
  set_has_finishline();
  if (finishline_ == &::google::protobuf::internal::kEmptyString) {
    finishline_ = new ::std::string;
  }
  return finishline_;
}
inline ::std::string* RaceEventMessage::release_finishline() {
  clear_has_finishline();
  if (finishline_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = finishline_;
    finishline_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string endOfTrack = 19;
inline bool RaceEventMessage::has_endoftrack() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RaceEventMessage::set_has_endoftrack() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RaceEventMessage::clear_has_endoftrack() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RaceEventMessage::clear_endoftrack() {
  if (endoftrack_ != &::google::protobuf::internal::kEmptyString) {
    endoftrack_->clear();
  }
  clear_has_endoftrack();
}
inline const ::std::string& RaceEventMessage::endoftrack() const {
  return *endoftrack_;
}
inline void RaceEventMessage::set_endoftrack(const ::std::string& value) {
  set_has_endoftrack();
  if (endoftrack_ == &::google::protobuf::internal::kEmptyString) {
    endoftrack_ = new ::std::string;
  }
  endoftrack_->assign(value);
}
inline void RaceEventMessage::set_endoftrack(const char* value) {
  set_has_endoftrack();
  if (endoftrack_ == &::google::protobuf::internal::kEmptyString) {
    endoftrack_ = new ::std::string;
  }
  endoftrack_->assign(value);
}
inline void RaceEventMessage::set_endoftrack(const char* value, size_t size) {
  set_has_endoftrack();
  if (endoftrack_ == &::google::protobuf::internal::kEmptyString) {
    endoftrack_ = new ::std::string;
  }
  endoftrack_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_endoftrack() {
  set_has_endoftrack();
  if (endoftrack_ == &::google::protobuf::internal::kEmptyString) {
    endoftrack_ = new ::std::string;
  }
  return endoftrack_;
}
inline ::std::string* RaceEventMessage::release_endoftrack() {
  clear_has_endoftrack();
  if (endoftrack_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endoftrack_;
    endoftrack_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string checkpointCollection = 20;
inline bool RaceEventMessage::has_checkpointcollection() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RaceEventMessage::set_has_checkpointcollection() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RaceEventMessage::clear_has_checkpointcollection() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RaceEventMessage::clear_checkpointcollection() {
  if (checkpointcollection_ != &::google::protobuf::internal::kEmptyString) {
    checkpointcollection_->clear();
  }
  clear_has_checkpointcollection();
}
inline const ::std::string& RaceEventMessage::checkpointcollection() const {
  return *checkpointcollection_;
}
inline void RaceEventMessage::set_checkpointcollection(const ::std::string& value) {
  set_has_checkpointcollection();
  if (checkpointcollection_ == &::google::protobuf::internal::kEmptyString) {
    checkpointcollection_ = new ::std::string;
  }
  checkpointcollection_->assign(value);
}
inline void RaceEventMessage::set_checkpointcollection(const char* value) {
  set_has_checkpointcollection();
  if (checkpointcollection_ == &::google::protobuf::internal::kEmptyString) {
    checkpointcollection_ = new ::std::string;
  }
  checkpointcollection_->assign(value);
}
inline void RaceEventMessage::set_checkpointcollection(const char* value, size_t size) {
  set_has_checkpointcollection();
  if (checkpointcollection_ == &::google::protobuf::internal::kEmptyString) {
    checkpointcollection_ = new ::std::string;
  }
  checkpointcollection_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaceEventMessage::mutable_checkpointcollection() {
  set_has_checkpointcollection();
  if (checkpointcollection_ == &::google::protobuf::internal::kEmptyString) {
    checkpointcollection_ = new ::std::string;
  }
  return checkpointcollection_;
}
inline ::std::string* RaceEventMessage::release_checkpointcollection() {
  clear_has_checkpointcollection();
  if (checkpointcollection_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = checkpointcollection_;
    checkpointcollection_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// TrafficFlowMessage

// optional int32 maxIncomingCarsOverride = 1;
inline bool TrafficFlowMessage::has_maxincomingcarsoverride() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficFlowMessage::set_has_maxincomingcarsoverride() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficFlowMessage::clear_has_maxincomingcarsoverride() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficFlowMessage::clear_maxincomingcarsoverride() {
  maxincomingcarsoverride_ = 0;
  clear_has_maxincomingcarsoverride();
}
inline ::google::protobuf::int32 TrafficFlowMessage::maxincomingcarsoverride() const {
  return maxincomingcarsoverride_;
}
inline void TrafficFlowMessage::set_maxincomingcarsoverride(::google::protobuf::int32 value) {
  set_has_maxincomingcarsoverride();
  maxincomingcarsoverride_ = value;
}

// optional int32 maxOutcomingCarsOverride = 2;
inline bool TrafficFlowMessage::has_maxoutcomingcarsoverride() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficFlowMessage::set_has_maxoutcomingcarsoverride() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficFlowMessage::clear_has_maxoutcomingcarsoverride() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficFlowMessage::clear_maxoutcomingcarsoverride() {
  maxoutcomingcarsoverride_ = 0;
  clear_has_maxoutcomingcarsoverride();
}
inline ::google::protobuf::int32 TrafficFlowMessage::maxoutcomingcarsoverride() const {
  return maxoutcomingcarsoverride_;
}
inline void TrafficFlowMessage::set_maxoutcomingcarsoverride(::google::protobuf::int32 value) {
  set_has_maxoutcomingcarsoverride();
  maxoutcomingcarsoverride_ = value;
}

// optional float outgoingLightMinDistance = 3;
inline bool TrafficFlowMessage::has_outgoinglightmindistance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficFlowMessage::set_has_outgoinglightmindistance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficFlowMessage::clear_has_outgoinglightmindistance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficFlowMessage::clear_outgoinglightmindistance() {
  outgoinglightmindistance_ = 0;
  clear_has_outgoinglightmindistance();
}
inline float TrafficFlowMessage::outgoinglightmindistance() const {
  return outgoinglightmindistance_;
}
inline void TrafficFlowMessage::set_outgoinglightmindistance(float value) {
  set_has_outgoinglightmindistance();
  outgoinglightmindistance_ = value;
}

// optional float outgoingLightMaxDistance = 4;
inline bool TrafficFlowMessage::has_outgoinglightmaxdistance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficFlowMessage::set_has_outgoinglightmaxdistance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficFlowMessage::clear_has_outgoinglightmaxdistance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficFlowMessage::clear_outgoinglightmaxdistance() {
  outgoinglightmaxdistance_ = 0;
  clear_has_outgoinglightmaxdistance();
}
inline float TrafficFlowMessage::outgoinglightmaxdistance() const {
  return outgoinglightmaxdistance_;
}
inline void TrafficFlowMessage::set_outgoinglightmaxdistance(float value) {
  set_has_outgoinglightmaxdistance();
  outgoinglightmaxdistance_ = value;
}

// optional float outgoingHeavyMinDistance = 5;
inline bool TrafficFlowMessage::has_outgoingheavymindistance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficFlowMessage::set_has_outgoingheavymindistance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficFlowMessage::clear_has_outgoingheavymindistance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficFlowMessage::clear_outgoingheavymindistance() {
  outgoingheavymindistance_ = 0;
  clear_has_outgoingheavymindistance();
}
inline float TrafficFlowMessage::outgoingheavymindistance() const {
  return outgoingheavymindistance_;
}
inline void TrafficFlowMessage::set_outgoingheavymindistance(float value) {
  set_has_outgoingheavymindistance();
  outgoingheavymindistance_ = value;
}

// optional float outgoingHeavyMaxDistance = 6;
inline bool TrafficFlowMessage::has_outgoingheavymaxdistance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficFlowMessage::set_has_outgoingheavymaxdistance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficFlowMessage::clear_has_outgoingheavymaxdistance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficFlowMessage::clear_outgoingheavymaxdistance() {
  outgoingheavymaxdistance_ = 0;
  clear_has_outgoingheavymaxdistance();
}
inline float TrafficFlowMessage::outgoingheavymaxdistance() const {
  return outgoingheavymaxdistance_;
}
inline void TrafficFlowMessage::set_outgoingheavymaxdistance(float value) {
  set_has_outgoingheavymaxdistance();
  outgoingheavymaxdistance_ = value;
}

// optional float incomingLightMinDistance = 7;
inline bool TrafficFlowMessage::has_incominglightmindistance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrafficFlowMessage::set_has_incominglightmindistance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrafficFlowMessage::clear_has_incominglightmindistance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrafficFlowMessage::clear_incominglightmindistance() {
  incominglightmindistance_ = 0;
  clear_has_incominglightmindistance();
}
inline float TrafficFlowMessage::incominglightmindistance() const {
  return incominglightmindistance_;
}
inline void TrafficFlowMessage::set_incominglightmindistance(float value) {
  set_has_incominglightmindistance();
  incominglightmindistance_ = value;
}

// optional float incomingLightMaxDistance = 8;
inline bool TrafficFlowMessage::has_incominglightmaxdistance() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrafficFlowMessage::set_has_incominglightmaxdistance() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrafficFlowMessage::clear_has_incominglightmaxdistance() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrafficFlowMessage::clear_incominglightmaxdistance() {
  incominglightmaxdistance_ = 0;
  clear_has_incominglightmaxdistance();
}
inline float TrafficFlowMessage::incominglightmaxdistance() const {
  return incominglightmaxdistance_;
}
inline void TrafficFlowMessage::set_incominglightmaxdistance(float value) {
  set_has_incominglightmaxdistance();
  incominglightmaxdistance_ = value;
}

// optional float incomingHeavyMinDistance = 9;
inline bool TrafficFlowMessage::has_incomingheavymindistance() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrafficFlowMessage::set_has_incomingheavymindistance() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrafficFlowMessage::clear_has_incomingheavymindistance() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrafficFlowMessage::clear_incomingheavymindistance() {
  incomingheavymindistance_ = 0;
  clear_has_incomingheavymindistance();
}
inline float TrafficFlowMessage::incomingheavymindistance() const {
  return incomingheavymindistance_;
}
inline void TrafficFlowMessage::set_incomingheavymindistance(float value) {
  set_has_incomingheavymindistance();
  incomingheavymindistance_ = value;
}

// optional float incomingHeavyMaxDistance = 10;
inline bool TrafficFlowMessage::has_incomingheavymaxdistance() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrafficFlowMessage::set_has_incomingheavymaxdistance() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrafficFlowMessage::clear_has_incomingheavymaxdistance() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrafficFlowMessage::clear_incomingheavymaxdistance() {
  incomingheavymaxdistance_ = 0;
  clear_has_incomingheavymaxdistance();
}
inline float TrafficFlowMessage::incomingheavymaxdistance() const {
  return incomingheavymaxdistance_;
}
inline void TrafficFlowMessage::set_incomingheavymaxdistance(float value) {
  set_has_incomingheavymaxdistance();
  incomingheavymaxdistance_ = value;
}

// optional float intialNoTrafficDistance = 11;
inline bool TrafficFlowMessage::has_intialnotrafficdistance() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TrafficFlowMessage::set_has_intialnotrafficdistance() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TrafficFlowMessage::clear_has_intialnotrafficdistance() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TrafficFlowMessage::clear_intialnotrafficdistance() {
  intialnotrafficdistance_ = 0;
  clear_has_intialnotrafficdistance();
}
inline float TrafficFlowMessage::intialnotrafficdistance() const {
  return intialnotrafficdistance_;
}
inline void TrafficFlowMessage::set_intialnotrafficdistance(float value) {
  set_has_intialnotrafficdistance();
  intialnotrafficdistance_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.RaceTrafficCongestionMessage raceTrafficCongestion = 12;
inline int TrafficFlowMessage::racetrafficcongestion_size() const {
  return racetrafficcongestion_.size();
}
inline void TrafficFlowMessage::clear_racetrafficcongestion() {
  racetrafficcongestion_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage& TrafficFlowMessage::racetrafficcongestion(int index) const {
  return racetrafficcongestion_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage* TrafficFlowMessage::mutable_racetrafficcongestion(int index) {
  return racetrafficcongestion_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage* TrafficFlowMessage::add_racetrafficcongestion() {
  return racetrafficcongestion_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage >&
TrafficFlowMessage::racetrafficcongestion() const {
  return racetrafficcongestion_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RaceTrafficCongestionMessage >*
TrafficFlowMessage::mutable_racetrafficcongestion() {
  return &racetrafficcongestion_;
}

// optional .com.ea.eamobile.nfsmw.protoc.TrafficCarSpawnDescsMessage trfficCarSpawnDescs = 13;
inline bool TrafficFlowMessage::has_trfficcarspawndescs() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TrafficFlowMessage::set_has_trfficcarspawndescs() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TrafficFlowMessage::clear_has_trfficcarspawndescs() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TrafficFlowMessage::clear_trfficcarspawndescs() {
  if (trfficcarspawndescs_ != NULL) trfficcarspawndescs_->::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage::Clear();
  clear_has_trfficcarspawndescs();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage& TrafficFlowMessage::trfficcarspawndescs() const {
  return trfficcarspawndescs_ != NULL ? *trfficcarspawndescs_ : *default_instance_->trfficcarspawndescs_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage* TrafficFlowMessage::mutable_trfficcarspawndescs() {
  set_has_trfficcarspawndescs();
  if (trfficcarspawndescs_ == NULL) trfficcarspawndescs_ = new ::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage;
  return trfficcarspawndescs_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage* TrafficFlowMessage::release_trfficcarspawndescs() {
  clear_has_trfficcarspawndescs();
  ::com::ea::eamobile::nfsmw::protoc::TrafficCarSpawnDescsMessage* temp = trfficcarspawndescs_;
  trfficcarspawndescs_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RaceTrafficCongestionMessage

// optional float raceCompletetionFactor = 1;
inline bool RaceTrafficCongestionMessage::has_racecompletetionfactor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaceTrafficCongestionMessage::set_has_racecompletetionfactor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaceTrafficCongestionMessage::clear_has_racecompletetionfactor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaceTrafficCongestionMessage::clear_racecompletetionfactor() {
  racecompletetionfactor_ = 0;
  clear_has_racecompletetionfactor();
}
inline float RaceTrafficCongestionMessage::racecompletetionfactor() const {
  return racecompletetionfactor_;
}
inline void RaceTrafficCongestionMessage::set_racecompletetionfactor(float value) {
  set_has_racecompletetionfactor();
  racecompletetionfactor_ = value;
}

// optional float outgoingTrafficCongestionFactor = 2;
inline bool RaceTrafficCongestionMessage::has_outgoingtrafficcongestionfactor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaceTrafficCongestionMessage::set_has_outgoingtrafficcongestionfactor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaceTrafficCongestionMessage::clear_has_outgoingtrafficcongestionfactor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaceTrafficCongestionMessage::clear_outgoingtrafficcongestionfactor() {
  outgoingtrafficcongestionfactor_ = 0;
  clear_has_outgoingtrafficcongestionfactor();
}
inline float RaceTrafficCongestionMessage::outgoingtrafficcongestionfactor() const {
  return outgoingtrafficcongestionfactor_;
}
inline void RaceTrafficCongestionMessage::set_outgoingtrafficcongestionfactor(float value) {
  set_has_outgoingtrafficcongestionfactor();
  outgoingtrafficcongestionfactor_ = value;
}

// optional float oncomingTrafficCongestionFactor = 3;
inline bool RaceTrafficCongestionMessage::has_oncomingtrafficcongestionfactor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RaceTrafficCongestionMessage::set_has_oncomingtrafficcongestionfactor() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RaceTrafficCongestionMessage::clear_has_oncomingtrafficcongestionfactor() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RaceTrafficCongestionMessage::clear_oncomingtrafficcongestionfactor() {
  oncomingtrafficcongestionfactor_ = 0;
  clear_has_oncomingtrafficcongestionfactor();
}
inline float RaceTrafficCongestionMessage::oncomingtrafficcongestionfactor() const {
  return oncomingtrafficcongestionfactor_;
}
inline void RaceTrafficCongestionMessage::set_oncomingtrafficcongestionfactor(float value) {
  set_has_oncomingtrafficcongestionfactor();
  oncomingtrafficcongestionfactor_ = value;
}

// -------------------------------------------------------------------

// TrafficCarSpawnDescsMessage

// repeated string prefabld = 1;
inline int TrafficCarSpawnDescsMessage::prefabld_size() const {
  return prefabld_.size();
}
inline void TrafficCarSpawnDescsMessage::clear_prefabld() {
  prefabld_.Clear();
}
inline const ::std::string& TrafficCarSpawnDescsMessage::prefabld(int index) const {
  return prefabld_.Get(index);
}
inline ::std::string* TrafficCarSpawnDescsMessage::mutable_prefabld(int index) {
  return prefabld_.Mutable(index);
}
inline void TrafficCarSpawnDescsMessage::set_prefabld(int index, const ::std::string& value) {
  prefabld_.Mutable(index)->assign(value);
}
inline void TrafficCarSpawnDescsMessage::set_prefabld(int index, const char* value) {
  prefabld_.Mutable(index)->assign(value);
}
inline void TrafficCarSpawnDescsMessage::set_prefabld(int index, const char* value, size_t size) {
  prefabld_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrafficCarSpawnDescsMessage::add_prefabld() {
  return prefabld_.Add();
}
inline void TrafficCarSpawnDescsMessage::add_prefabld(const ::std::string& value) {
  prefabld_.Add()->assign(value);
}
inline void TrafficCarSpawnDescsMessage::add_prefabld(const char* value) {
  prefabld_.Add()->assign(value);
}
inline void TrafficCarSpawnDescsMessage::add_prefabld(const char* value, size_t size) {
  prefabld_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TrafficCarSpawnDescsMessage::prefabld() const {
  return prefabld_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TrafficCarSpawnDescsMessage::mutable_prefabld() {
  return &prefabld_;
}

// -------------------------------------------------------------------

// RequestRegistJaguarCommand

// required int32 jaguarType = 1;
inline bool RequestRegistJaguarCommand::has_jaguartype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRegistJaguarCommand::set_has_jaguartype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRegistJaguarCommand::clear_has_jaguartype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRegistJaguarCommand::clear_jaguartype() {
  jaguartype_ = 0;
  clear_has_jaguartype();
}
inline ::google::protobuf::int32 RequestRegistJaguarCommand::jaguartype() const {
  return jaguartype_;
}
inline void RequestRegistJaguarCommand::set_jaguartype(::google::protobuf::int32 value) {
  set_has_jaguartype();
  jaguartype_ = value;
}

// -------------------------------------------------------------------

// ResponseRegistJaguarCommand

// required bool levelRaceCanUse = 1;
inline bool ResponseRegistJaguarCommand::has_levelracecanuse() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRegistJaguarCommand::set_has_levelracecanuse() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRegistJaguarCommand::clear_has_levelracecanuse() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRegistJaguarCommand::clear_levelracecanuse() {
  levelracecanuse_ = false;
  clear_has_levelracecanuse();
}
inline bool ResponseRegistJaguarCommand::levelracecanuse() const {
  return levelracecanuse_;
}
inline void ResponseRegistJaguarCommand::set_levelracecanuse(bool value) {
  set_has_levelracecanuse();
  levelracecanuse_ = value;
}

// -------------------------------------------------------------------

// RequestRpLeaderboardCommand

// required int32 type = 1;
inline bool RequestRpLeaderboardCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRpLeaderboardCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRpLeaderboardCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRpLeaderboardCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 RequestRpLeaderboardCommand::type() const {
  return type_;
}
inline void RequestRpLeaderboardCommand::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional bool hasProfileUI = 2;
inline bool RequestRpLeaderboardCommand::has_hasprofileui() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRpLeaderboardCommand::set_has_hasprofileui() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRpLeaderboardCommand::clear_has_hasprofileui() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRpLeaderboardCommand::clear_hasprofileui() {
  hasprofileui_ = false;
  clear_has_hasprofileui();
}
inline bool RequestRpLeaderboardCommand::hasprofileui() const {
  return hasprofileui_;
}
inline void RequestRpLeaderboardCommand::set_hasprofileui(bool value) {
  set_has_hasprofileui();
  hasprofileui_ = value;
}

// -------------------------------------------------------------------

// ResponseRpLeaderboardCommand

// required int32 type = 1;
inline bool ResponseRpLeaderboardCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseRpLeaderboardCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseRpLeaderboardCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseRpLeaderboardCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ResponseRpLeaderboardCommand::type() const {
  return type_;
}
inline void ResponseRpLeaderboardCommand::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.RpLeaderboardMessage rpLeaderboard = 2;
inline int ResponseRpLeaderboardCommand::rpleaderboard_size() const {
  return rpleaderboard_.size();
}
inline void ResponseRpLeaderboardCommand::clear_rpleaderboard() {
  rpleaderboard_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage& ResponseRpLeaderboardCommand::rpleaderboard(int index) const {
  return rpleaderboard_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage* ResponseRpLeaderboardCommand::mutable_rpleaderboard(int index) {
  return rpleaderboard_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage* ResponseRpLeaderboardCommand::add_rpleaderboard() {
  return rpleaderboard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage >&
ResponseRpLeaderboardCommand::rpleaderboard() const {
  return rpleaderboard_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage >*
ResponseRpLeaderboardCommand::mutable_rpleaderboard() {
  return &rpleaderboard_;
}

// required int32 selfRank = 3;
inline bool ResponseRpLeaderboardCommand::has_selfrank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseRpLeaderboardCommand::set_has_selfrank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseRpLeaderboardCommand::clear_has_selfrank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseRpLeaderboardCommand::clear_selfrank() {
  selfrank_ = 0;
  clear_has_selfrank();
}
inline ::google::protobuf::int32 ResponseRpLeaderboardCommand::selfrank() const {
  return selfrank_;
}
inline void ResponseRpLeaderboardCommand::set_selfrank(::google::protobuf::int32 value) {
  set_has_selfrank();
  selfrank_ = value;
}

// required int32 selfHeadIndex = 4;
inline bool ResponseRpLeaderboardCommand::has_selfheadindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseRpLeaderboardCommand::set_has_selfheadindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseRpLeaderboardCommand::clear_has_selfheadindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseRpLeaderboardCommand::clear_selfheadindex() {
  selfheadindex_ = 0;
  clear_has_selfheadindex();
}
inline ::google::protobuf::int32 ResponseRpLeaderboardCommand::selfheadindex() const {
  return selfheadindex_;
}
inline void ResponseRpLeaderboardCommand::set_selfheadindex(::google::protobuf::int32 value) {
  set_has_selfheadindex();
  selfheadindex_ = value;
}

// optional string selfHeadUrl = 5;
inline bool ResponseRpLeaderboardCommand::has_selfheadurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseRpLeaderboardCommand::set_has_selfheadurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseRpLeaderboardCommand::clear_has_selfheadurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseRpLeaderboardCommand::clear_selfheadurl() {
  if (selfheadurl_ != &::google::protobuf::internal::kEmptyString) {
    selfheadurl_->clear();
  }
  clear_has_selfheadurl();
}
inline const ::std::string& ResponseRpLeaderboardCommand::selfheadurl() const {
  return *selfheadurl_;
}
inline void ResponseRpLeaderboardCommand::set_selfheadurl(const ::std::string& value) {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  selfheadurl_->assign(value);
}
inline void ResponseRpLeaderboardCommand::set_selfheadurl(const char* value) {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  selfheadurl_->assign(value);
}
inline void ResponseRpLeaderboardCommand::set_selfheadurl(const char* value, size_t size) {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  selfheadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseRpLeaderboardCommand::mutable_selfheadurl() {
  set_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    selfheadurl_ = new ::std::string;
  }
  return selfheadurl_;
}
inline ::std::string* ResponseRpLeaderboardCommand::release_selfheadurl() {
  clear_has_selfheadurl();
  if (selfheadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfheadurl_;
    selfheadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string selfName = 6;
inline bool ResponseRpLeaderboardCommand::has_selfname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseRpLeaderboardCommand::set_has_selfname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseRpLeaderboardCommand::clear_has_selfname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseRpLeaderboardCommand::clear_selfname() {
  if (selfname_ != &::google::protobuf::internal::kEmptyString) {
    selfname_->clear();
  }
  clear_has_selfname();
}
inline const ::std::string& ResponseRpLeaderboardCommand::selfname() const {
  return *selfname_;
}
inline void ResponseRpLeaderboardCommand::set_selfname(const ::std::string& value) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(value);
}
inline void ResponseRpLeaderboardCommand::set_selfname(const char* value) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(value);
}
inline void ResponseRpLeaderboardCommand::set_selfname(const char* value, size_t size) {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  selfname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseRpLeaderboardCommand::mutable_selfname() {
  set_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    selfname_ = new ::std::string;
  }
  return selfname_;
}
inline ::std::string* ResponseRpLeaderboardCommand::release_selfname() {
  clear_has_selfname();
  if (selfname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selfname_;
    selfname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 selfRpLevel = 7;
inline bool ResponseRpLeaderboardCommand::has_selfrplevel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseRpLeaderboardCommand::set_has_selfrplevel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseRpLeaderboardCommand::clear_has_selfrplevel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseRpLeaderboardCommand::clear_selfrplevel() {
  selfrplevel_ = 0;
  clear_has_selfrplevel();
}
inline ::google::protobuf::int32 ResponseRpLeaderboardCommand::selfrplevel() const {
  return selfrplevel_;
}
inline void ResponseRpLeaderboardCommand::set_selfrplevel(::google::protobuf::int32 value) {
  set_has_selfrplevel();
  selfrplevel_ = value;
}

// required int32 selfRpNum = 8;
inline bool ResponseRpLeaderboardCommand::has_selfrpnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseRpLeaderboardCommand::set_has_selfrpnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseRpLeaderboardCommand::clear_has_selfrpnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseRpLeaderboardCommand::clear_selfrpnum() {
  selfrpnum_ = 0;
  clear_has_selfrpnum();
}
inline ::google::protobuf::int32 ResponseRpLeaderboardCommand::selfrpnum() const {
  return selfrpnum_;
}
inline void ResponseRpLeaderboardCommand::set_selfrpnum(::google::protobuf::int32 value) {
  set_has_selfrpnum();
  selfrpnum_ = value;
}

// -------------------------------------------------------------------

// RpLeaderboardMessage

// required int32 rank = 1;
inline bool RpLeaderboardMessage::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RpLeaderboardMessage::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RpLeaderboardMessage::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RpLeaderboardMessage::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 RpLeaderboardMessage::rank() const {
  return rank_;
}
inline void RpLeaderboardMessage::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// required int32 headIndex = 2;
inline bool RpLeaderboardMessage::has_headindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RpLeaderboardMessage::set_has_headindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RpLeaderboardMessage::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RpLeaderboardMessage::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 RpLeaderboardMessage::headindex() const {
  return headindex_;
}
inline void RpLeaderboardMessage::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// optional string headUrl = 3;
inline bool RpLeaderboardMessage::has_headurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RpLeaderboardMessage::set_has_headurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RpLeaderboardMessage::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RpLeaderboardMessage::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& RpLeaderboardMessage::headurl() const {
  return *headurl_;
}
inline void RpLeaderboardMessage::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void RpLeaderboardMessage::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void RpLeaderboardMessage::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpLeaderboardMessage::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* RpLeaderboardMessage::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string name = 4;
inline bool RpLeaderboardMessage::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RpLeaderboardMessage::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RpLeaderboardMessage::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RpLeaderboardMessage::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RpLeaderboardMessage::name() const {
  return *name_;
}
inline void RpLeaderboardMessage::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RpLeaderboardMessage::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RpLeaderboardMessage::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RpLeaderboardMessage::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RpLeaderboardMessage::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 rpLevel = 5;
inline bool RpLeaderboardMessage::has_rplevel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RpLeaderboardMessage::set_has_rplevel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RpLeaderboardMessage::clear_has_rplevel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RpLeaderboardMessage::clear_rplevel() {
  rplevel_ = 0;
  clear_has_rplevel();
}
inline ::google::protobuf::int32 RpLeaderboardMessage::rplevel() const {
  return rplevel_;
}
inline void RpLeaderboardMessage::set_rplevel(::google::protobuf::int32 value) {
  set_has_rplevel();
  rplevel_ = value;
}

// required int32 rpNum = 6;
inline bool RpLeaderboardMessage::has_rpnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RpLeaderboardMessage::set_has_rpnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RpLeaderboardMessage::clear_has_rpnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RpLeaderboardMessage::clear_rpnum() {
  rpnum_ = 0;
  clear_has_rpnum();
}
inline ::google::protobuf::int32 RpLeaderboardMessage::rpnum() const {
  return rpnum_;
}
inline void RpLeaderboardMessage::set_rpnum(::google::protobuf::int32 value) {
  set_has_rpnum();
  rpnum_ = value;
}

// optional int64 userId = 7;
inline bool RpLeaderboardMessage::has_userid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RpLeaderboardMessage::set_has_userid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RpLeaderboardMessage::clear_has_userid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RpLeaderboardMessage::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 RpLeaderboardMessage::userid() const {
  return userid_;
}
inline void RpLeaderboardMessage::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// ProfileCarInfo

// required int64 userCarId = 1;
inline bool ProfileCarInfo::has_usercarid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProfileCarInfo::set_has_usercarid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProfileCarInfo::clear_has_usercarid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProfileCarInfo::clear_usercarid() {
  usercarid_ = GOOGLE_LONGLONG(0);
  clear_has_usercarid();
}
inline ::google::protobuf::int64 ProfileCarInfo::usercarid() const {
  return usercarid_;
}
inline void ProfileCarInfo::set_usercarid(::google::protobuf::int64 value) {
  set_has_usercarid();
  usercarid_ = value;
}

// required string carId = 2;
inline bool ProfileCarInfo::has_carid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProfileCarInfo::set_has_carid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProfileCarInfo::clear_has_carid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProfileCarInfo::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& ProfileCarInfo::carid() const {
  return *carid_;
}
inline void ProfileCarInfo::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void ProfileCarInfo::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void ProfileCarInfo::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProfileCarInfo::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* ProfileCarInfo::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 slotLevel = 3;
inline int ProfileCarInfo::slotlevel_size() const {
  return slotlevel_.size();
}
inline void ProfileCarInfo::clear_slotlevel() {
  slotlevel_.Clear();
}
inline ::google::protobuf::int32 ProfileCarInfo::slotlevel(int index) const {
  return slotlevel_.Get(index);
}
inline void ProfileCarInfo::set_slotlevel(int index, ::google::protobuf::int32 value) {
  slotlevel_.Set(index, value);
}
inline void ProfileCarInfo::add_slotlevel(::google::protobuf::int32 value) {
  slotlevel_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ProfileCarInfo::slotlevel() const {
  return slotlevel_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ProfileCarInfo::mutable_slotlevel() {
  return &slotlevel_;
}

// required int32 carPaintJobIndex = 4;
inline bool ProfileCarInfo::has_carpaintjobindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProfileCarInfo::set_has_carpaintjobindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProfileCarInfo::clear_has_carpaintjobindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProfileCarInfo::clear_carpaintjobindex() {
  carpaintjobindex_ = 0;
  clear_has_carpaintjobindex();
}
inline ::google::protobuf::int32 ProfileCarInfo::carpaintjobindex() const {
  return carpaintjobindex_;
}
inline void ProfileCarInfo::set_carpaintjobindex(::google::protobuf::int32 value) {
  set_has_carpaintjobindex();
  carpaintjobindex_ = value;
}

// required int32 carScore = 5;
inline bool ProfileCarInfo::has_carscore() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProfileCarInfo::set_has_carscore() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProfileCarInfo::clear_has_carscore() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProfileCarInfo::clear_carscore() {
  carscore_ = 0;
  clear_has_carscore();
}
inline ::google::protobuf::int32 ProfileCarInfo::carscore() const {
  return carscore_;
}
inline void ProfileCarInfo::set_carscore(::google::protobuf::int32 value) {
  set_has_carscore();
  carscore_ = value;
}

// required int64 likeNum = 6;
inline bool ProfileCarInfo::has_likenum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProfileCarInfo::set_has_likenum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProfileCarInfo::clear_has_likenum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProfileCarInfo::clear_likenum() {
  likenum_ = GOOGLE_LONGLONG(0);
  clear_has_likenum();
}
inline ::google::protobuf::int64 ProfileCarInfo::likenum() const {
  return likenum_;
}
inline void ProfileCarInfo::set_likenum(::google::protobuf::int64 value) {
  set_has_likenum();
  likenum_ = value;
}

// required bool canLike = 7;
inline bool ProfileCarInfo::has_canlike() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProfileCarInfo::set_has_canlike() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProfileCarInfo::clear_has_canlike() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProfileCarInfo::clear_canlike() {
  canlike_ = false;
  clear_has_canlike();
}
inline bool ProfileCarInfo::canlike() const {
  return canlike_;
}
inline void ProfileCarInfo::set_canlike(bool value) {
  set_has_canlike();
  canlike_ = value;
}

// -------------------------------------------------------------------

// RequestProfileUserDataCommand

// required int64 profileId = 1;
inline bool RequestProfileUserDataCommand::has_profileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestProfileUserDataCommand::set_has_profileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestProfileUserDataCommand::clear_has_profileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestProfileUserDataCommand::clear_profileid() {
  profileid_ = GOOGLE_LONGLONG(0);
  clear_has_profileid();
}
inline ::google::protobuf::int64 RequestProfileUserDataCommand::profileid() const {
  return profileid_;
}
inline void RequestProfileUserDataCommand::set_profileid(::google::protobuf::int64 value) {
  set_has_profileid();
  profileid_ = value;
}

// required int32 sourceTypeId = 2;
inline bool RequestProfileUserDataCommand::has_sourcetypeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestProfileUserDataCommand::set_has_sourcetypeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestProfileUserDataCommand::clear_has_sourcetypeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestProfileUserDataCommand::clear_sourcetypeid() {
  sourcetypeid_ = 0;
  clear_has_sourcetypeid();
}
inline ::google::protobuf::int32 RequestProfileUserDataCommand::sourcetypeid() const {
  return sourcetypeid_;
}
inline void RequestProfileUserDataCommand::set_sourcetypeid(::google::protobuf::int32 value) {
  set_has_sourcetypeid();
  sourcetypeid_ = value;
}

// required int32 tournamentOnlineId = 3;
inline bool RequestProfileUserDataCommand::has_tournamentonlineid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestProfileUserDataCommand::set_has_tournamentonlineid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestProfileUserDataCommand::clear_has_tournamentonlineid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestProfileUserDataCommand::clear_tournamentonlineid() {
  tournamentonlineid_ = 0;
  clear_has_tournamentonlineid();
}
inline ::google::protobuf::int32 RequestProfileUserDataCommand::tournamentonlineid() const {
  return tournamentonlineid_;
}
inline void RequestProfileUserDataCommand::set_tournamentonlineid(::google::protobuf::int32 value) {
  set_has_tournamentonlineid();
  tournamentonlineid_ = value;
}

// required int32 tournamentGroupId = 4;
inline bool RequestProfileUserDataCommand::has_tournamentgroupid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestProfileUserDataCommand::set_has_tournamentgroupid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestProfileUserDataCommand::clear_has_tournamentgroupid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestProfileUserDataCommand::clear_tournamentgroupid() {
  tournamentgroupid_ = 0;
  clear_has_tournamentgroupid();
}
inline ::google::protobuf::int32 RequestProfileUserDataCommand::tournamentgroupid() const {
  return tournamentgroupid_;
}
inline void RequestProfileUserDataCommand::set_tournamentgroupid(::google::protobuf::int32 value) {
  set_has_tournamentgroupid();
  tournamentgroupid_ = value;
}

// -------------------------------------------------------------------

// ResponseProfileUserDataCommand

// required string nickname = 1;
inline bool ResponseProfileUserDataCommand::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseProfileUserDataCommand::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseProfileUserDataCommand::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& ResponseProfileUserDataCommand::nickname() const {
  return *nickname_;
}
inline void ResponseProfileUserDataCommand::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void ResponseProfileUserDataCommand::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void ResponseProfileUserDataCommand::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseProfileUserDataCommand::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* ResponseProfileUserDataCommand::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string headUrl = 2;
inline bool ResponseProfileUserDataCommand::has_headurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_headurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseProfileUserDataCommand::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseProfileUserDataCommand::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& ResponseProfileUserDataCommand::headurl() const {
  return *headurl_;
}
inline void ResponseProfileUserDataCommand::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void ResponseProfileUserDataCommand::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void ResponseProfileUserDataCommand::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseProfileUserDataCommand::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* ResponseProfileUserDataCommand::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 headIndex = 3;
inline bool ResponseProfileUserDataCommand::has_headindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_headindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseProfileUserDataCommand::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseProfileUserDataCommand::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 ResponseProfileUserDataCommand::headindex() const {
  return headindex_;
}
inline void ResponseProfileUserDataCommand::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// required int32 rpLevel = 4;
inline bool ResponseProfileUserDataCommand::has_rplevel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_rplevel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseProfileUserDataCommand::clear_has_rplevel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseProfileUserDataCommand::clear_rplevel() {
  rplevel_ = 0;
  clear_has_rplevel();
}
inline ::google::protobuf::int32 ResponseProfileUserDataCommand::rplevel() const {
  return rplevel_;
}
inline void ResponseProfileUserDataCommand::set_rplevel(::google::protobuf::int32 value) {
  set_has_rplevel();
  rplevel_ = value;
}

// required int32 rpExp = 5;
inline bool ResponseProfileUserDataCommand::has_rpexp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_rpexp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseProfileUserDataCommand::clear_has_rpexp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseProfileUserDataCommand::clear_rpexp() {
  rpexp_ = 0;
  clear_has_rpexp();
}
inline ::google::protobuf::int32 ResponseProfileUserDataCommand::rpexp() const {
  return rpexp_;
}
inline void ResponseProfileUserDataCommand::set_rpexp(::google::protobuf::int32 value) {
  set_has_rpexp();
  rpexp_ = value;
}

// required int32 mostwantedNum = 6;
inline bool ResponseProfileUserDataCommand::has_mostwantednum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_mostwantednum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseProfileUserDataCommand::clear_has_mostwantednum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseProfileUserDataCommand::clear_mostwantednum() {
  mostwantednum_ = 0;
  clear_has_mostwantednum();
}
inline ::google::protobuf::int32 ResponseProfileUserDataCommand::mostwantednum() const {
  return mostwantednum_;
}
inline void ResponseProfileUserDataCommand::set_mostwantednum(::google::protobuf::int32 value) {
  set_has_mostwantednum();
  mostwantednum_ = value;
}

// required int32 carNum = 7;
inline bool ResponseProfileUserDataCommand::has_carnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_carnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseProfileUserDataCommand::clear_has_carnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseProfileUserDataCommand::clear_carnum() {
  carnum_ = 0;
  clear_has_carnum();
}
inline ::google::protobuf::int32 ResponseProfileUserDataCommand::carnum() const {
  return carnum_;
}
inline void ResponseProfileUserDataCommand::set_carnum(::google::protobuf::int32 value) {
  set_has_carnum();
  carnum_ = value;
}

// required int32 garageScore = 8;
inline bool ResponseProfileUserDataCommand::has_garagescore() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_garagescore() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseProfileUserDataCommand::clear_has_garagescore() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseProfileUserDataCommand::clear_garagescore() {
  garagescore_ = 0;
  clear_has_garagescore();
}
inline ::google::protobuf::int32 ResponseProfileUserDataCommand::garagescore() const {
  return garagescore_;
}
inline void ResponseProfileUserDataCommand::set_garagescore(::google::protobuf::int32 value) {
  set_has_garagescore();
  garagescore_ = value;
}

// required bool canReport = 9;
inline bool ResponseProfileUserDataCommand::has_canreport() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_canreport() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseProfileUserDataCommand::clear_has_canreport() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseProfileUserDataCommand::clear_canreport() {
  canreport_ = false;
  clear_has_canreport();
}
inline bool ResponseProfileUserDataCommand::canreport() const {
  return canreport_;
}
inline void ResponseProfileUserDataCommand::set_canreport(bool value) {
  set_has_canreport();
  canreport_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.ProfileCarInfo carInfo = 10;
inline bool ResponseProfileUserDataCommand::has_carinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseProfileUserDataCommand::set_has_carinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseProfileUserDataCommand::clear_has_carinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseProfileUserDataCommand::clear_carinfo() {
  if (carinfo_ != NULL) carinfo_->::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo::Clear();
  clear_has_carinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo& ResponseProfileUserDataCommand::carinfo() const {
  return carinfo_ != NULL ? *carinfo_ : *default_instance_->carinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* ResponseProfileUserDataCommand::mutable_carinfo() {
  set_has_carinfo();
  if (carinfo_ == NULL) carinfo_ = new ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo;
  return carinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* ResponseProfileUserDataCommand::release_carinfo() {
  clear_has_carinfo();
  ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* temp = carinfo_;
  carinfo_ = NULL;
  return temp;
}

// repeated string ownedCarId = 11;
inline int ResponseProfileUserDataCommand::ownedcarid_size() const {
  return ownedcarid_.size();
}
inline void ResponseProfileUserDataCommand::clear_ownedcarid() {
  ownedcarid_.Clear();
}
inline const ::std::string& ResponseProfileUserDataCommand::ownedcarid(int index) const {
  return ownedcarid_.Get(index);
}
inline ::std::string* ResponseProfileUserDataCommand::mutable_ownedcarid(int index) {
  return ownedcarid_.Mutable(index);
}
inline void ResponseProfileUserDataCommand::set_ownedcarid(int index, const ::std::string& value) {
  ownedcarid_.Mutable(index)->assign(value);
}
inline void ResponseProfileUserDataCommand::set_ownedcarid(int index, const char* value) {
  ownedcarid_.Mutable(index)->assign(value);
}
inline void ResponseProfileUserDataCommand::set_ownedcarid(int index, const char* value, size_t size) {
  ownedcarid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseProfileUserDataCommand::add_ownedcarid() {
  return ownedcarid_.Add();
}
inline void ResponseProfileUserDataCommand::add_ownedcarid(const ::std::string& value) {
  ownedcarid_.Add()->assign(value);
}
inline void ResponseProfileUserDataCommand::add_ownedcarid(const char* value) {
  ownedcarid_.Add()->assign(value);
}
inline void ResponseProfileUserDataCommand::add_ownedcarid(const char* value, size_t size) {
  ownedcarid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseProfileUserDataCommand::ownedcarid() const {
  return ownedcarid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseProfileUserDataCommand::mutable_ownedcarid() {
  return &ownedcarid_;
}

// repeated int64 ownedUserCarId = 12;
inline int ResponseProfileUserDataCommand::ownedusercarid_size() const {
  return ownedusercarid_.size();
}
inline void ResponseProfileUserDataCommand::clear_ownedusercarid() {
  ownedusercarid_.Clear();
}
inline ::google::protobuf::int64 ResponseProfileUserDataCommand::ownedusercarid(int index) const {
  return ownedusercarid_.Get(index);
}
inline void ResponseProfileUserDataCommand::set_ownedusercarid(int index, ::google::protobuf::int64 value) {
  ownedusercarid_.Set(index, value);
}
inline void ResponseProfileUserDataCommand::add_ownedusercarid(::google::protobuf::int64 value) {
  ownedusercarid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ResponseProfileUserDataCommand::ownedusercarid() const {
  return ownedusercarid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ResponseProfileUserDataCommand::mutable_ownedusercarid() {
  return &ownedusercarid_;
}

// -------------------------------------------------------------------

// RequestProfileNextCarCommand

// required int64 userCarId = 1;
inline bool RequestProfileNextCarCommand::has_usercarid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestProfileNextCarCommand::set_has_usercarid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestProfileNextCarCommand::clear_has_usercarid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestProfileNextCarCommand::clear_usercarid() {
  usercarid_ = GOOGLE_LONGLONG(0);
  clear_has_usercarid();
}
inline ::google::protobuf::int64 RequestProfileNextCarCommand::usercarid() const {
  return usercarid_;
}
inline void RequestProfileNextCarCommand::set_usercarid(::google::protobuf::int64 value) {
  set_has_usercarid();
  usercarid_ = value;
}

// -------------------------------------------------------------------

// ResponseProfileNextCarCommand

// required .com.ea.eamobile.nfsmw.protoc.ProfileCarInfo carInfo = 1;
inline bool ResponseProfileNextCarCommand::has_carinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseProfileNextCarCommand::set_has_carinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseProfileNextCarCommand::clear_has_carinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseProfileNextCarCommand::clear_carinfo() {
  if (carinfo_ != NULL) carinfo_->::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo::Clear();
  clear_has_carinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo& ResponseProfileNextCarCommand::carinfo() const {
  return carinfo_ != NULL ? *carinfo_ : *default_instance_->carinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* ResponseProfileNextCarCommand::mutable_carinfo() {
  set_has_carinfo();
  if (carinfo_ == NULL) carinfo_ = new ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo;
  return carinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* ResponseProfileNextCarCommand::release_carinfo() {
  clear_has_carinfo();
  ::com::ea::eamobile::nfsmw::protoc::ProfileCarInfo* temp = carinfo_;
  carinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RequestProfileLikeCommand

// required int64 userCarId = 1;
inline bool RequestProfileLikeCommand::has_usercarid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestProfileLikeCommand::set_has_usercarid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestProfileLikeCommand::clear_has_usercarid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestProfileLikeCommand::clear_usercarid() {
  usercarid_ = GOOGLE_LONGLONG(0);
  clear_has_usercarid();
}
inline ::google::protobuf::int64 RequestProfileLikeCommand::usercarid() const {
  return usercarid_;
}
inline void RequestProfileLikeCommand::set_usercarid(::google::protobuf::int64 value) {
  set_has_usercarid();
  usercarid_ = value;
}

// -------------------------------------------------------------------

// ResponseProfileLikeCommand

// required int64 likeNum = 1;
inline bool ResponseProfileLikeCommand::has_likenum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseProfileLikeCommand::set_has_likenum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseProfileLikeCommand::clear_has_likenum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseProfileLikeCommand::clear_likenum() {
  likenum_ = GOOGLE_LONGLONG(0);
  clear_has_likenum();
}
inline ::google::protobuf::int64 ResponseProfileLikeCommand::likenum() const {
  return likenum_;
}
inline void ResponseProfileLikeCommand::set_likenum(::google::protobuf::int64 value) {
  set_has_likenum();
  likenum_ = value;
}

// -------------------------------------------------------------------

// RequestProfileReportCommand

// required int64 profileId = 1;
inline bool RequestProfileReportCommand::has_profileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestProfileReportCommand::set_has_profileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestProfileReportCommand::clear_has_profileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestProfileReportCommand::clear_profileid() {
  profileid_ = GOOGLE_LONGLONG(0);
  clear_has_profileid();
}
inline ::google::protobuf::int64 RequestProfileReportCommand::profileid() const {
  return profileid_;
}
inline void RequestProfileReportCommand::set_profileid(::google::protobuf::int64 value) {
  set_has_profileid();
  profileid_ = value;
}

// -------------------------------------------------------------------

// ResponseProfileReportCommand

// -------------------------------------------------------------------

// UserVSProfile

// required string titleStr = 1;
inline bool UserVSProfile::has_titlestr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserVSProfile::set_has_titlestr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserVSProfile::clear_has_titlestr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserVSProfile::clear_titlestr() {
  if (titlestr_ != &::google::protobuf::internal::kEmptyString) {
    titlestr_->clear();
  }
  clear_has_titlestr();
}
inline const ::std::string& UserVSProfile::titlestr() const {
  return *titlestr_;
}
inline void UserVSProfile::set_titlestr(const ::std::string& value) {
  set_has_titlestr();
  if (titlestr_ == &::google::protobuf::internal::kEmptyString) {
    titlestr_ = new ::std::string;
  }
  titlestr_->assign(value);
}
inline void UserVSProfile::set_titlestr(const char* value) {
  set_has_titlestr();
  if (titlestr_ == &::google::protobuf::internal::kEmptyString) {
    titlestr_ = new ::std::string;
  }
  titlestr_->assign(value);
}
inline void UserVSProfile::set_titlestr(const char* value, size_t size) {
  set_has_titlestr();
  if (titlestr_ == &::google::protobuf::internal::kEmptyString) {
    titlestr_ = new ::std::string;
  }
  titlestr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserVSProfile::mutable_titlestr() {
  set_has_titlestr();
  if (titlestr_ == &::google::protobuf::internal::kEmptyString) {
    titlestr_ = new ::std::string;
  }
  return titlestr_;
}
inline ::std::string* UserVSProfile::release_titlestr() {
  clear_has_titlestr();
  if (titlestr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = titlestr_;
    titlestr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 playerValue = 2;
inline bool UserVSProfile::has_playervalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserVSProfile::set_has_playervalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserVSProfile::clear_has_playervalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserVSProfile::clear_playervalue() {
  playervalue_ = 0;
  clear_has_playervalue();
}
inline ::google::protobuf::int32 UserVSProfile::playervalue() const {
  return playervalue_;
}
inline void UserVSProfile::set_playervalue(::google::protobuf::int32 value) {
  set_has_playervalue();
  playervalue_ = value;
}

// required int32 ghostValue = 3;
inline bool UserVSProfile::has_ghostvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserVSProfile::set_has_ghostvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserVSProfile::clear_has_ghostvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserVSProfile::clear_ghostvalue() {
  ghostvalue_ = 0;
  clear_has_ghostvalue();
}
inline ::google::protobuf::int32 UserVSProfile::ghostvalue() const {
  return ghostvalue_;
}
inline void UserVSProfile::set_ghostvalue(::google::protobuf::int32 value) {
  set_has_ghostvalue();
  ghostvalue_ = value;
}

// required bool hasProgressBar = 4;
inline bool UserVSProfile::has_hasprogressbar() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserVSProfile::set_has_hasprogressbar() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserVSProfile::clear_has_hasprogressbar() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserVSProfile::clear_hasprogressbar() {
  hasprogressbar_ = false;
  clear_has_hasprogressbar();
}
inline bool UserVSProfile::hasprogressbar() const {
  return hasprogressbar_;
}
inline void UserVSProfile::set_hasprogressbar(bool value) {
  set_has_hasprogressbar();
  hasprogressbar_ = value;
}

// required string subTitleStr = 5;
inline bool UserVSProfile::has_subtitlestr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserVSProfile::set_has_subtitlestr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserVSProfile::clear_has_subtitlestr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserVSProfile::clear_subtitlestr() {
  if (subtitlestr_ != &::google::protobuf::internal::kEmptyString) {
    subtitlestr_->clear();
  }
  clear_has_subtitlestr();
}
inline const ::std::string& UserVSProfile::subtitlestr() const {
  return *subtitlestr_;
}
inline void UserVSProfile::set_subtitlestr(const ::std::string& value) {
  set_has_subtitlestr();
  if (subtitlestr_ == &::google::protobuf::internal::kEmptyString) {
    subtitlestr_ = new ::std::string;
  }
  subtitlestr_->assign(value);
}
inline void UserVSProfile::set_subtitlestr(const char* value) {
  set_has_subtitlestr();
  if (subtitlestr_ == &::google::protobuf::internal::kEmptyString) {
    subtitlestr_ = new ::std::string;
  }
  subtitlestr_->assign(value);
}
inline void UserVSProfile::set_subtitlestr(const char* value, size_t size) {
  set_has_subtitlestr();
  if (subtitlestr_ == &::google::protobuf::internal::kEmptyString) {
    subtitlestr_ = new ::std::string;
  }
  subtitlestr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserVSProfile::mutable_subtitlestr() {
  set_has_subtitlestr();
  if (subtitlestr_ == &::google::protobuf::internal::kEmptyString) {
    subtitlestr_ = new ::std::string;
  }
  return subtitlestr_;
}
inline ::std::string* UserVSProfile::release_subtitlestr() {
  clear_has_subtitlestr();
  if (subtitlestr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtitlestr_;
    subtitlestr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string unitsStr = 6;
inline bool UserVSProfile::has_unitsstr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserVSProfile::set_has_unitsstr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserVSProfile::clear_has_unitsstr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserVSProfile::clear_unitsstr() {
  if (unitsstr_ != &::google::protobuf::internal::kEmptyString) {
    unitsstr_->clear();
  }
  clear_has_unitsstr();
}
inline const ::std::string& UserVSProfile::unitsstr() const {
  return *unitsstr_;
}
inline void UserVSProfile::set_unitsstr(const ::std::string& value) {
  set_has_unitsstr();
  if (unitsstr_ == &::google::protobuf::internal::kEmptyString) {
    unitsstr_ = new ::std::string;
  }
  unitsstr_->assign(value);
}
inline void UserVSProfile::set_unitsstr(const char* value) {
  set_has_unitsstr();
  if (unitsstr_ == &::google::protobuf::internal::kEmptyString) {
    unitsstr_ = new ::std::string;
  }
  unitsstr_->assign(value);
}
inline void UserVSProfile::set_unitsstr(const char* value, size_t size) {
  set_has_unitsstr();
  if (unitsstr_ == &::google::protobuf::internal::kEmptyString) {
    unitsstr_ = new ::std::string;
  }
  unitsstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserVSProfile::mutable_unitsstr() {
  set_has_unitsstr();
  if (unitsstr_ == &::google::protobuf::internal::kEmptyString) {
    unitsstr_ = new ::std::string;
  }
  return unitsstr_;
}
inline ::std::string* UserVSProfile::release_unitsstr() {
  clear_has_unitsstr();
  if (unitsstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = unitsstr_;
    unitsstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 valueType = 7;
inline bool UserVSProfile::has_valuetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserVSProfile::set_has_valuetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserVSProfile::clear_has_valuetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserVSProfile::clear_valuetype() {
  valuetype_ = 0;
  clear_has_valuetype();
}
inline ::google::protobuf::int32 UserVSProfile::valuetype() const {
  return valuetype_;
}
inline void UserVSProfile::set_valuetype(::google::protobuf::int32 value) {
  set_has_valuetype();
  valuetype_ = value;
}

// -------------------------------------------------------------------

// RequestProfileVSCommand

// required int64 profileId = 1;
inline bool RequestProfileVSCommand::has_profileid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestProfileVSCommand::set_has_profileid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestProfileVSCommand::clear_has_profileid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestProfileVSCommand::clear_profileid() {
  profileid_ = GOOGLE_LONGLONG(0);
  clear_has_profileid();
}
inline ::google::protobuf::int64 RequestProfileVSCommand::profileid() const {
  return profileid_;
}
inline void RequestProfileVSCommand::set_profileid(::google::protobuf::int64 value) {
  set_has_profileid();
  profileid_ = value;
}

// -------------------------------------------------------------------

// ResponseProfileVSCommand

// repeated .com.ea.eamobile.nfsmw.protoc.UserVSProfile vsData = 1;
inline int ResponseProfileVSCommand::vsdata_size() const {
  return vsdata_.size();
}
inline void ResponseProfileVSCommand::clear_vsdata() {
  vsdata_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::UserVSProfile& ResponseProfileVSCommand::vsdata(int index) const {
  return vsdata_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::UserVSProfile* ResponseProfileVSCommand::mutable_vsdata(int index) {
  return vsdata_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::UserVSProfile* ResponseProfileVSCommand::add_vsdata() {
  return vsdata_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::UserVSProfile >&
ResponseProfileVSCommand::vsdata() const {
  return vsdata_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::UserVSProfile >*
ResponseProfileVSCommand::mutable_vsdata() {
  return &vsdata_;
}

// -------------------------------------------------------------------

// RequestRecordUserRaceActionCommand

// required int32 copsKill = 1;
inline bool RequestRecordUserRaceActionCommand::has_copskill() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestRecordUserRaceActionCommand::set_has_copskill() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestRecordUserRaceActionCommand::clear_has_copskill() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestRecordUserRaceActionCommand::clear_copskill() {
  copskill_ = 0;
  clear_has_copskill();
}
inline ::google::protobuf::int32 RequestRecordUserRaceActionCommand::copskill() const {
  return copskill_;
}
inline void RequestRecordUserRaceActionCommand::set_copskill(::google::protobuf::int32 value) {
  set_has_copskill();
  copskill_ = value;
}

// required int32 consumable = 2;
inline bool RequestRecordUserRaceActionCommand::has_consumable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestRecordUserRaceActionCommand::set_has_consumable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestRecordUserRaceActionCommand::clear_has_consumable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestRecordUserRaceActionCommand::clear_consumable() {
  consumable_ = 0;
  clear_has_consumable();
}
inline ::google::protobuf::int32 RequestRecordUserRaceActionCommand::consumable() const {
  return consumable_;
}
inline void RequestRecordUserRaceActionCommand::set_consumable(::google::protobuf::int32 value) {
  set_has_consumable();
  consumable_ = value;
}

// required int32 drift = 3;
inline bool RequestRecordUserRaceActionCommand::has_drift() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestRecordUserRaceActionCommand::set_has_drift() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestRecordUserRaceActionCommand::clear_has_drift() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestRecordUserRaceActionCommand::clear_drift() {
  drift_ = 0;
  clear_has_drift();
}
inline ::google::protobuf::int32 RequestRecordUserRaceActionCommand::drift() const {
  return drift_;
}
inline void RequestRecordUserRaceActionCommand::set_drift(::google::protobuf::int32 value) {
  set_has_drift();
  drift_ = value;
}

// required int32 jump = 4;
inline bool RequestRecordUserRaceActionCommand::has_jump() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestRecordUserRaceActionCommand::set_has_jump() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestRecordUserRaceActionCommand::clear_has_jump() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestRecordUserRaceActionCommand::clear_jump() {
  jump_ = 0;
  clear_has_jump();
}
inline ::google::protobuf::int32 RequestRecordUserRaceActionCommand::jump() const {
  return jump_;
}
inline void RequestRecordUserRaceActionCommand::set_jump(::google::protobuf::int32 value) {
  set_has_jump();
  jump_ = value;
}

// required int32 billBoard = 5;
inline bool RequestRecordUserRaceActionCommand::has_billboard() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestRecordUserRaceActionCommand::set_has_billboard() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestRecordUserRaceActionCommand::clear_has_billboard() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestRecordUserRaceActionCommand::clear_billboard() {
  billboard_ = 0;
  clear_has_billboard();
}
inline ::google::protobuf::int32 RequestRecordUserRaceActionCommand::billboard() const {
  return billboard_;
}
inline void RequestRecordUserRaceActionCommand::set_billboard(::google::protobuf::int32 value) {
  set_has_billboard();
  billboard_ = value;
}

// -------------------------------------------------------------------

// RequestQuickRaceCommand

// -------------------------------------------------------------------

// ResponseQuickRaceCommand

// required .com.ea.eamobile.nfsmw.protoc.TrackInfo track = 1;
inline bool ResponseQuickRaceCommand::has_track() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseQuickRaceCommand::set_has_track() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseQuickRaceCommand::clear_has_track() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseQuickRaceCommand::clear_track() {
  if (track_ != NULL) track_->::com::ea::eamobile::nfsmw::protoc::TrackInfo::Clear();
  clear_has_track();
}
inline const ::com::ea::eamobile::nfsmw::protoc::TrackInfo& ResponseQuickRaceCommand::track() const {
  return track_ != NULL ? *track_ : *default_instance_->track_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TrackInfo* ResponseQuickRaceCommand::mutable_track() {
  set_has_track();
  if (track_ == NULL) track_ = new ::com::ea::eamobile::nfsmw::protoc::TrackInfo;
  return track_;
}
inline ::com::ea::eamobile::nfsmw::protoc::TrackInfo* ResponseQuickRaceCommand::release_track() {
  clear_has_track();
  ::com::ea::eamobile::nfsmw::protoc::TrackInfo* temp = track_;
  track_ = NULL;
  return temp;
}

// required int32 trackIndex = 2;
inline bool ResponseQuickRaceCommand::has_trackindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseQuickRaceCommand::set_has_trackindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseQuickRaceCommand::clear_has_trackindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseQuickRaceCommand::clear_trackindex() {
  trackindex_ = 0;
  clear_has_trackindex();
}
inline ::google::protobuf::int32 ResponseQuickRaceCommand::trackindex() const {
  return trackindex_;
}
inline void ResponseQuickRaceCommand::set_trackindex(::google::protobuf::int32 value) {
  set_has_trackindex();
  trackindex_ = value;
}

// required int32 modeId = 3;
inline bool ResponseQuickRaceCommand::has_modeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseQuickRaceCommand::set_has_modeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseQuickRaceCommand::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseQuickRaceCommand::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 ResponseQuickRaceCommand::modeid() const {
  return modeid_;
}
inline void ResponseQuickRaceCommand::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.CheckPointInfo checkPointInfo = 4;
inline bool ResponseQuickRaceCommand::has_checkpointinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseQuickRaceCommand::set_has_checkpointinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseQuickRaceCommand::clear_has_checkpointinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseQuickRaceCommand::clear_checkpointinfo() {
  if (checkpointinfo_ != NULL) checkpointinfo_->::com::ea::eamobile::nfsmw::protoc::CheckPointInfo::Clear();
  clear_has_checkpointinfo();
}
inline const ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo& ResponseQuickRaceCommand::checkpointinfo() const {
  return checkpointinfo_ != NULL ? *checkpointinfo_ : *default_instance_->checkpointinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* ResponseQuickRaceCommand::mutable_checkpointinfo() {
  set_has_checkpointinfo();
  if (checkpointinfo_ == NULL) checkpointinfo_ = new ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo;
  return checkpointinfo_;
}
inline ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* ResponseQuickRaceCommand::release_checkpointinfo() {
  clear_has_checkpointinfo();
  ::com::ea::eamobile::nfsmw::protoc::CheckPointInfo* temp = checkpointinfo_;
  checkpointinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ResponseNotificationCommand

// required int32 iconId = 1;
inline bool ResponseNotificationCommand::has_iconid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseNotificationCommand::set_has_iconid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseNotificationCommand::clear_has_iconid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseNotificationCommand::clear_iconid() {
  iconid_ = 0;
  clear_has_iconid();
}
inline ::google::protobuf::int32 ResponseNotificationCommand::iconid() const {
  return iconid_;
}
inline void ResponseNotificationCommand::set_iconid(::google::protobuf::int32 value) {
  set_has_iconid();
  iconid_ = value;
}

// required float duration = 2;
inline bool ResponseNotificationCommand::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseNotificationCommand::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseNotificationCommand::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseNotificationCommand::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float ResponseNotificationCommand::duration() const {
  return duration_;
}
inline void ResponseNotificationCommand::set_duration(float value) {
  set_has_duration();
  duration_ = value;
}

// required string content = 3;
inline bool ResponseNotificationCommand::has_content() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseNotificationCommand::set_has_content() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseNotificationCommand::clear_has_content() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseNotificationCommand::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& ResponseNotificationCommand::content() const {
  return *content_;
}
inline void ResponseNotificationCommand::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ResponseNotificationCommand::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void ResponseNotificationCommand::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseNotificationCommand::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* ResponseNotificationCommand::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestGhostRecordCommand

// required int32 modeId = 1;
inline bool RequestGhostRecordCommand::has_modeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGhostRecordCommand::set_has_modeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGhostRecordCommand::clear_has_modeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGhostRecordCommand::clear_modeid() {
  modeid_ = 0;
  clear_has_modeid();
}
inline ::google::protobuf::int32 RequestGhostRecordCommand::modeid() const {
  return modeid_;
}
inline void RequestGhostRecordCommand::set_modeid(::google::protobuf::int32 value) {
  set_has_modeid();
  modeid_ = value;
}

// required float raceTime = 2;
inline bool RequestGhostRecordCommand::has_racetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGhostRecordCommand::set_has_racetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGhostRecordCommand::clear_has_racetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGhostRecordCommand::clear_racetime() {
  racetime_ = 0;
  clear_has_racetime();
}
inline float RequestGhostRecordCommand::racetime() const {
  return racetime_;
}
inline void RequestGhostRecordCommand::set_racetime(float value) {
  set_has_racetime();
  racetime_ = value;
}

// required string carId = 3;
inline bool RequestGhostRecordCommand::has_carid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestGhostRecordCommand::set_has_carid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestGhostRecordCommand::clear_has_carid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestGhostRecordCommand::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& RequestGhostRecordCommand::carid() const {
  return *carid_;
}
inline void RequestGhostRecordCommand::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestGhostRecordCommand::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestGhostRecordCommand::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGhostRecordCommand::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* RequestGhostRecordCommand::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated int32 carModType = 4;
inline int RequestGhostRecordCommand::carmodtype_size() const {
  return carmodtype_.size();
}
inline void RequestGhostRecordCommand::clear_carmodtype() {
  carmodtype_.Clear();
}
inline ::google::protobuf::int32 RequestGhostRecordCommand::carmodtype(int index) const {
  return carmodtype_.Get(index);
}
inline void RequestGhostRecordCommand::set_carmodtype(int index, ::google::protobuf::int32 value) {
  carmodtype_.Set(index, value);
}
inline void RequestGhostRecordCommand::add_carmodtype(::google::protobuf::int32 value) {
  carmodtype_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RequestGhostRecordCommand::carmodtype() const {
  return carmodtype_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RequestGhostRecordCommand::mutable_carmodtype() {
  return &carmodtype_;
}

// repeated float carModValue = 5;
inline int RequestGhostRecordCommand::carmodvalue_size() const {
  return carmodvalue_.size();
}
inline void RequestGhostRecordCommand::clear_carmodvalue() {
  carmodvalue_.Clear();
}
inline float RequestGhostRecordCommand::carmodvalue(int index) const {
  return carmodvalue_.Get(index);
}
inline void RequestGhostRecordCommand::set_carmodvalue(int index, float value) {
  carmodvalue_.Set(index, value);
}
inline void RequestGhostRecordCommand::add_carmodvalue(float value) {
  carmodvalue_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RequestGhostRecordCommand::carmodvalue() const {
  return carmodvalue_;
}
inline ::google::protobuf::RepeatedField< float >*
RequestGhostRecordCommand::mutable_carmodvalue() {
  return &carmodvalue_;
}

// repeated int32 carModLevel = 6;
inline int RequestGhostRecordCommand::carmodlevel_size() const {
  return carmodlevel_.size();
}
inline void RequestGhostRecordCommand::clear_carmodlevel() {
  carmodlevel_.Clear();
}
inline ::google::protobuf::int32 RequestGhostRecordCommand::carmodlevel(int index) const {
  return carmodlevel_.Get(index);
}
inline void RequestGhostRecordCommand::set_carmodlevel(int index, ::google::protobuf::int32 value) {
  carmodlevel_.Set(index, value);
}
inline void RequestGhostRecordCommand::add_carmodlevel(::google::protobuf::int32 value) {
  carmodlevel_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RequestGhostRecordCommand::carmodlevel() const {
  return carmodlevel_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RequestGhostRecordCommand::mutable_carmodlevel() {
  return &carmodlevel_;
}

// repeated int32 carModId = 7;
inline int RequestGhostRecordCommand::carmodid_size() const {
  return carmodid_.size();
}
inline void RequestGhostRecordCommand::clear_carmodid() {
  carmodid_.Clear();
}
inline ::google::protobuf::int32 RequestGhostRecordCommand::carmodid(int index) const {
  return carmodid_.Get(index);
}
inline void RequestGhostRecordCommand::set_carmodid(int index, ::google::protobuf::int32 value) {
  carmodid_.Set(index, value);
}
inline void RequestGhostRecordCommand::add_carmodid(::google::protobuf::int32 value) {
  carmodid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RequestGhostRecordCommand::carmodid() const {
  return carmodid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RequestGhostRecordCommand::mutable_carmodid() {
  return &carmodid_;
}

// required int32 samplePeriod = 8;
inline bool RequestGhostRecordCommand::has_sampleperiod() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestGhostRecordCommand::set_has_sampleperiod() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestGhostRecordCommand::clear_has_sampleperiod() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestGhostRecordCommand::clear_sampleperiod() {
  sampleperiod_ = 0;
  clear_has_sampleperiod();
}
inline ::google::protobuf::int32 RequestGhostRecordCommand::sampleperiod() const {
  return sampleperiod_;
}
inline void RequestGhostRecordCommand::set_sampleperiod(::google::protobuf::int32 value) {
  set_has_sampleperiod();
  sampleperiod_ = value;
}

// repeated float sampleData = 9;
inline int RequestGhostRecordCommand::sampledata_size() const {
  return sampledata_.size();
}
inline void RequestGhostRecordCommand::clear_sampledata() {
  sampledata_.Clear();
}
inline float RequestGhostRecordCommand::sampledata(int index) const {
  return sampledata_.Get(index);
}
inline void RequestGhostRecordCommand::set_sampledata(int index, float value) {
  sampledata_.Set(index, value);
}
inline void RequestGhostRecordCommand::add_sampledata(float value) {
  sampledata_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
RequestGhostRecordCommand::sampledata() const {
  return sampledata_;
}
inline ::google::protobuf::RepeatedField< float >*
RequestGhostRecordCommand::mutable_sampledata() {
  return &sampledata_;
}

// -------------------------------------------------------------------

// ResponseGhostRecordCommand

// required bool success = 1;
inline bool ResponseGhostRecordCommand::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseGhostRecordCommand::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseGhostRecordCommand::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseGhostRecordCommand::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ResponseGhostRecordCommand::success() const {
  return success_;
}
inline void ResponseGhostRecordCommand::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string message = 2;
inline bool ResponseGhostRecordCommand::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseGhostRecordCommand::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseGhostRecordCommand::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseGhostRecordCommand::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ResponseGhostRecordCommand::message() const {
  return *message_;
}
inline void ResponseGhostRecordCommand::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseGhostRecordCommand::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseGhostRecordCommand::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseGhostRecordCommand::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ResponseGhostRecordCommand::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestIapCheckCommand

// required string receiptData = 1;
inline bool RequestIapCheckCommand::has_receiptdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestIapCheckCommand::set_has_receiptdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestIapCheckCommand::clear_has_receiptdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestIapCheckCommand::clear_receiptdata() {
  if (receiptdata_ != &::google::protobuf::internal::kEmptyString) {
    receiptdata_->clear();
  }
  clear_has_receiptdata();
}
inline const ::std::string& RequestIapCheckCommand::receiptdata() const {
  return *receiptdata_;
}
inline void RequestIapCheckCommand::set_receiptdata(const ::std::string& value) {
  set_has_receiptdata();
  if (receiptdata_ == &::google::protobuf::internal::kEmptyString) {
    receiptdata_ = new ::std::string;
  }
  receiptdata_->assign(value);
}
inline void RequestIapCheckCommand::set_receiptdata(const char* value) {
  set_has_receiptdata();
  if (receiptdata_ == &::google::protobuf::internal::kEmptyString) {
    receiptdata_ = new ::std::string;
  }
  receiptdata_->assign(value);
}
inline void RequestIapCheckCommand::set_receiptdata(const char* value, size_t size) {
  set_has_receiptdata();
  if (receiptdata_ == &::google::protobuf::internal::kEmptyString) {
    receiptdata_ = new ::std::string;
  }
  receiptdata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestIapCheckCommand::mutable_receiptdata() {
  set_has_receiptdata();
  if (receiptdata_ == &::google::protobuf::internal::kEmptyString) {
    receiptdata_ = new ::std::string;
  }
  return receiptdata_;
}
inline ::std::string* RequestIapCheckCommand::release_receiptdata() {
  clear_has_receiptdata();
  if (receiptdata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = receiptdata_;
    receiptdata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 ipspPurchaseItemCallBackType = 2;
inline bool RequestIapCheckCommand::has_ipsppurchaseitemcallbacktype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestIapCheckCommand::set_has_ipsppurchaseitemcallbacktype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestIapCheckCommand::clear_has_ipsppurchaseitemcallbacktype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestIapCheckCommand::clear_ipsppurchaseitemcallbacktype() {
  ipsppurchaseitemcallbacktype_ = 0;
  clear_has_ipsppurchaseitemcallbacktype();
}
inline ::google::protobuf::int32 RequestIapCheckCommand::ipsppurchaseitemcallbacktype() const {
  return ipsppurchaseitemcallbacktype_;
}
inline void RequestIapCheckCommand::set_ipsppurchaseitemcallbacktype(::google::protobuf::int32 value) {
  set_has_ipsppurchaseitemcallbacktype();
  ipsppurchaseitemcallbacktype_ = value;
}

// -------------------------------------------------------------------

// ResponseIapCheckCommand

// required bool success = 1;
inline bool ResponseIapCheckCommand::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseIapCheckCommand::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseIapCheckCommand::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseIapCheckCommand::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ResponseIapCheckCommand::success() const {
  return success_;
}
inline void ResponseIapCheckCommand::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string message = 2;
inline bool ResponseIapCheckCommand::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseIapCheckCommand::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseIapCheckCommand::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseIapCheckCommand::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ResponseIapCheckCommand::message() const {
  return *message_;
}
inline void ResponseIapCheckCommand::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseIapCheckCommand::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ResponseIapCheckCommand::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseIapCheckCommand::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ResponseIapCheckCommand::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseTournamentNotificationCommand

// repeated string message = 1;
inline int ResponseTournamentNotificationCommand::message_size() const {
  return message_.size();
}
inline void ResponseTournamentNotificationCommand::clear_message() {
  message_.Clear();
}
inline const ::std::string& ResponseTournamentNotificationCommand::message(int index) const {
  return message_.Get(index);
}
inline ::std::string* ResponseTournamentNotificationCommand::mutable_message(int index) {
  return message_.Mutable(index);
}
inline void ResponseTournamentNotificationCommand::set_message(int index, const ::std::string& value) {
  message_.Mutable(index)->assign(value);
}
inline void ResponseTournamentNotificationCommand::set_message(int index, const char* value) {
  message_.Mutable(index)->assign(value);
}
inline void ResponseTournamentNotificationCommand::set_message(int index, const char* value, size_t size) {
  message_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseTournamentNotificationCommand::add_message() {
  return message_.Add();
}
inline void ResponseTournamentNotificationCommand::add_message(const ::std::string& value) {
  message_.Add()->assign(value);
}
inline void ResponseTournamentNotificationCommand::add_message(const char* value) {
  message_.Add()->assign(value);
}
inline void ResponseTournamentNotificationCommand::add_message(const char* value, size_t size) {
  message_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ResponseTournamentNotificationCommand::message() const {
  return message_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ResponseTournamentNotificationCommand::mutable_message() {
  return &message_;
}

// -------------------------------------------------------------------

// RequestTutorialRewardCommand

// required bool finishedAllTutorial = 1;
inline bool RequestTutorialRewardCommand::has_finishedalltutorial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestTutorialRewardCommand::set_has_finishedalltutorial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestTutorialRewardCommand::clear_has_finishedalltutorial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestTutorialRewardCommand::clear_finishedalltutorial() {
  finishedalltutorial_ = false;
  clear_has_finishedalltutorial();
}
inline bool RequestTutorialRewardCommand::finishedalltutorial() const {
  return finishedalltutorial_;
}
inline void RequestTutorialRewardCommand::set_finishedalltutorial(bool value) {
  set_has_finishedalltutorial();
  finishedalltutorial_ = value;
}

// -------------------------------------------------------------------

// ResponseTutorialRewardCommand

// required bool success = 1;
inline bool ResponseTutorialRewardCommand::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseTutorialRewardCommand::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseTutorialRewardCommand::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseTutorialRewardCommand::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ResponseTutorialRewardCommand::success() const {
  return success_;
}
inline void ResponseTutorialRewardCommand::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional .com.ea.eamobile.nfsmw.protoc.Reward reward = 2;
inline bool ResponseTutorialRewardCommand::has_reward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseTutorialRewardCommand::set_has_reward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseTutorialRewardCommand::clear_has_reward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseTutorialRewardCommand::clear_reward() {
  if (reward_ != NULL) reward_->::com::ea::eamobile::nfsmw::protoc::Reward::Clear();
  clear_has_reward();
}
inline const ::com::ea::eamobile::nfsmw::protoc::Reward& ResponseTutorialRewardCommand::reward() const {
  return reward_ != NULL ? *reward_ : *default_instance_->reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseTutorialRewardCommand::mutable_reward() {
  set_has_reward();
  if (reward_ == NULL) reward_ = new ::com::ea::eamobile::nfsmw::protoc::Reward;
  return reward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::Reward* ResponseTutorialRewardCommand::release_reward() {
  clear_has_reward();
  ::com::ea::eamobile::nfsmw::protoc::Reward* temp = reward_;
  reward_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ResponsePopupCommand

// required int32 popScreen = 1;
inline bool ResponsePopupCommand::has_popscreen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponsePopupCommand::set_has_popscreen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponsePopupCommand::clear_has_popscreen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponsePopupCommand::clear_popscreen() {
  popscreen_ = 0;
  clear_has_popscreen();
}
inline ::google::protobuf::int32 ResponsePopupCommand::popscreen() const {
  return popscreen_;
}
inline void ResponsePopupCommand::set_popscreen(::google::protobuf::int32 value) {
  set_has_popscreen();
  popscreen_ = value;
}

// optional string flowID = 2;
inline bool ResponsePopupCommand::has_flowid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponsePopupCommand::set_has_flowid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponsePopupCommand::clear_has_flowid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponsePopupCommand::clear_flowid() {
  if (flowid_ != &::google::protobuf::internal::kEmptyString) {
    flowid_->clear();
  }
  clear_has_flowid();
}
inline const ::std::string& ResponsePopupCommand::flowid() const {
  return *flowid_;
}
inline void ResponsePopupCommand::set_flowid(const ::std::string& value) {
  set_has_flowid();
  if (flowid_ == &::google::protobuf::internal::kEmptyString) {
    flowid_ = new ::std::string;
  }
  flowid_->assign(value);
}
inline void ResponsePopupCommand::set_flowid(const char* value) {
  set_has_flowid();
  if (flowid_ == &::google::protobuf::internal::kEmptyString) {
    flowid_ = new ::std::string;
  }
  flowid_->assign(value);
}
inline void ResponsePopupCommand::set_flowid(const char* value, size_t size) {
  set_has_flowid();
  if (flowid_ == &::google::protobuf::internal::kEmptyString) {
    flowid_ = new ::std::string;
  }
  flowid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponsePopupCommand::mutable_flowid() {
  set_has_flowid();
  if (flowid_ == &::google::protobuf::internal::kEmptyString) {
    flowid_ = new ::std::string;
  }
  return flowid_;
}
inline ::std::string* ResponsePopupCommand::release_flowid() {
  clear_has_flowid();
  if (flowid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = flowid_;
    flowid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string text = 3;
inline bool ResponsePopupCommand::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponsePopupCommand::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponsePopupCommand::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponsePopupCommand::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ResponsePopupCommand::text() const {
  return *text_;
}
inline void ResponsePopupCommand::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ResponsePopupCommand::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ResponsePopupCommand::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponsePopupCommand::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ResponsePopupCommand::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string heading = 4;
inline bool ResponsePopupCommand::has_heading() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponsePopupCommand::set_has_heading() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponsePopupCommand::clear_has_heading() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponsePopupCommand::clear_heading() {
  if (heading_ != &::google::protobuf::internal::kEmptyString) {
    heading_->clear();
  }
  clear_has_heading();
}
inline const ::std::string& ResponsePopupCommand::heading() const {
  return *heading_;
}
inline void ResponsePopupCommand::set_heading(const ::std::string& value) {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    heading_ = new ::std::string;
  }
  heading_->assign(value);
}
inline void ResponsePopupCommand::set_heading(const char* value) {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    heading_ = new ::std::string;
  }
  heading_->assign(value);
}
inline void ResponsePopupCommand::set_heading(const char* value, size_t size) {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    heading_ = new ::std::string;
  }
  heading_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponsePopupCommand::mutable_heading() {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    heading_ = new ::std::string;
  }
  return heading_;
}
inline ::std::string* ResponsePopupCommand::release_heading() {
  clear_has_heading();
  if (heading_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = heading_;
    heading_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string yesButtonID = 5;
inline bool ResponsePopupCommand::has_yesbuttonid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponsePopupCommand::set_has_yesbuttonid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponsePopupCommand::clear_has_yesbuttonid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponsePopupCommand::clear_yesbuttonid() {
  if (yesbuttonid_ != &::google::protobuf::internal::kEmptyString) {
    yesbuttonid_->clear();
  }
  clear_has_yesbuttonid();
}
inline const ::std::string& ResponsePopupCommand::yesbuttonid() const {
  return *yesbuttonid_;
}
inline void ResponsePopupCommand::set_yesbuttonid(const ::std::string& value) {
  set_has_yesbuttonid();
  if (yesbuttonid_ == &::google::protobuf::internal::kEmptyString) {
    yesbuttonid_ = new ::std::string;
  }
  yesbuttonid_->assign(value);
}
inline void ResponsePopupCommand::set_yesbuttonid(const char* value) {
  set_has_yesbuttonid();
  if (yesbuttonid_ == &::google::protobuf::internal::kEmptyString) {
    yesbuttonid_ = new ::std::string;
  }
  yesbuttonid_->assign(value);
}
inline void ResponsePopupCommand::set_yesbuttonid(const char* value, size_t size) {
  set_has_yesbuttonid();
  if (yesbuttonid_ == &::google::protobuf::internal::kEmptyString) {
    yesbuttonid_ = new ::std::string;
  }
  yesbuttonid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponsePopupCommand::mutable_yesbuttonid() {
  set_has_yesbuttonid();
  if (yesbuttonid_ == &::google::protobuf::internal::kEmptyString) {
    yesbuttonid_ = new ::std::string;
  }
  return yesbuttonid_;
}
inline ::std::string* ResponsePopupCommand::release_yesbuttonid() {
  clear_has_yesbuttonid();
  if (yesbuttonid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = yesbuttonid_;
    yesbuttonid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string noButtonID = 6;
inline bool ResponsePopupCommand::has_nobuttonid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponsePopupCommand::set_has_nobuttonid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponsePopupCommand::clear_has_nobuttonid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponsePopupCommand::clear_nobuttonid() {
  if (nobuttonid_ != &::google::protobuf::internal::kEmptyString) {
    nobuttonid_->clear();
  }
  clear_has_nobuttonid();
}
inline const ::std::string& ResponsePopupCommand::nobuttonid() const {
  return *nobuttonid_;
}
inline void ResponsePopupCommand::set_nobuttonid(const ::std::string& value) {
  set_has_nobuttonid();
  if (nobuttonid_ == &::google::protobuf::internal::kEmptyString) {
    nobuttonid_ = new ::std::string;
  }
  nobuttonid_->assign(value);
}
inline void ResponsePopupCommand::set_nobuttonid(const char* value) {
  set_has_nobuttonid();
  if (nobuttonid_ == &::google::protobuf::internal::kEmptyString) {
    nobuttonid_ = new ::std::string;
  }
  nobuttonid_->assign(value);
}
inline void ResponsePopupCommand::set_nobuttonid(const char* value, size_t size) {
  set_has_nobuttonid();
  if (nobuttonid_ == &::google::protobuf::internal::kEmptyString) {
    nobuttonid_ = new ::std::string;
  }
  nobuttonid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponsePopupCommand::mutable_nobuttonid() {
  set_has_nobuttonid();
  if (nobuttonid_ == &::google::protobuf::internal::kEmptyString) {
    nobuttonid_ = new ::std::string;
  }
  return nobuttonid_;
}
inline ::std::string* ResponsePopupCommand::release_nobuttonid() {
  clear_has_nobuttonid();
  if (nobuttonid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nobuttonid_;
    nobuttonid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponsePopupListCommand

// repeated .com.ea.eamobile.nfsmw.protoc.ResponsePopupCommand popups = 1;
inline int ResponsePopupListCommand::popups_size() const {
  return popups_.size();
}
inline void ResponsePopupListCommand::clear_popups() {
  popups_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand& ResponsePopupListCommand::popups(int index) const {
  return popups_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* ResponsePopupListCommand::mutable_popups(int index) {
  return popups_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* ResponsePopupListCommand::add_popups() {
  return popups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand >&
ResponsePopupListCommand::popups() const {
  return popups_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand >*
ResponsePopupListCommand::mutable_popups() {
  return &popups_;
}

// -------------------------------------------------------------------

// ResponseTournamentRewardNumCommand

// required int32 rewardNum = 1;
inline bool ResponseTournamentRewardNumCommand::has_rewardnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseTournamentRewardNumCommand::set_has_rewardnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseTournamentRewardNumCommand::clear_has_rewardnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseTournamentRewardNumCommand::clear_rewardnum() {
  rewardnum_ = 0;
  clear_has_rewardnum();
}
inline ::google::protobuf::int32 ResponseTournamentRewardNumCommand::rewardnum() const {
  return rewardnum_;
}
inline void ResponseTournamentRewardNumCommand::set_rewardnum(::google::protobuf::int32 value) {
  set_has_rewardnum();
  rewardnum_ = value;
}

// repeated int32 endTime = 2;
inline int ResponseTournamentRewardNumCommand::endtime_size() const {
  return endtime_.size();
}
inline void ResponseTournamentRewardNumCommand::clear_endtime() {
  endtime_.Clear();
}
inline ::google::protobuf::int32 ResponseTournamentRewardNumCommand::endtime(int index) const {
  return endtime_.Get(index);
}
inline void ResponseTournamentRewardNumCommand::set_endtime(int index, ::google::protobuf::int32 value) {
  endtime_.Set(index, value);
}
inline void ResponseTournamentRewardNumCommand::add_endtime(::google::protobuf::int32 value) {
  endtime_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ResponseTournamentRewardNumCommand::endtime() const {
  return endtime_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ResponseTournamentRewardNumCommand::mutable_endtime() {
  return &endtime_;
}

// -------------------------------------------------------------------

// RequestGotchaCommand

// required int32 level = 1;
inline bool RequestGotchaCommand::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestGotchaCommand::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestGotchaCommand::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestGotchaCommand::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 RequestGotchaCommand::level() const {
  return level_;
}
inline void RequestGotchaCommand::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// required string carId = 2;
inline bool RequestGotchaCommand::has_carid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestGotchaCommand::set_has_carid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestGotchaCommand::clear_has_carid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestGotchaCommand::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& RequestGotchaCommand::carid() const {
  return *carid_;
}
inline void RequestGotchaCommand::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestGotchaCommand::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestGotchaCommand::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestGotchaCommand::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* RequestGotchaCommand::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseGotchaCommand

// repeated .com.ea.eamobile.nfsmw.protoc.GotchaItemInfo gotchaItems = 1;
inline int ResponseGotchaCommand::gotchaitems_size() const {
  return gotchaitems_.size();
}
inline void ResponseGotchaCommand::clear_gotchaitems() {
  gotchaitems_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo& ResponseGotchaCommand::gotchaitems(int index) const {
  return gotchaitems_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo* ResponseGotchaCommand::mutable_gotchaitems(int index) {
  return gotchaitems_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo* ResponseGotchaCommand::add_gotchaitems() {
  return gotchaitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo >&
ResponseGotchaCommand::gotchaitems() const {
  return gotchaitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::GotchaItemInfo >*
ResponseGotchaCommand::mutable_gotchaitems() {
  return &gotchaitems_;
}

// optional string globalMessage = 2;
inline bool ResponseGotchaCommand::has_globalmessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseGotchaCommand::set_has_globalmessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseGotchaCommand::clear_has_globalmessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseGotchaCommand::clear_globalmessage() {
  if (globalmessage_ != &::google::protobuf::internal::kEmptyString) {
    globalmessage_->clear();
  }
  clear_has_globalmessage();
}
inline const ::std::string& ResponseGotchaCommand::globalmessage() const {
  return *globalmessage_;
}
inline void ResponseGotchaCommand::set_globalmessage(const ::std::string& value) {
  set_has_globalmessage();
  if (globalmessage_ == &::google::protobuf::internal::kEmptyString) {
    globalmessage_ = new ::std::string;
  }
  globalmessage_->assign(value);
}
inline void ResponseGotchaCommand::set_globalmessage(const char* value) {
  set_has_globalmessage();
  if (globalmessage_ == &::google::protobuf::internal::kEmptyString) {
    globalmessage_ = new ::std::string;
  }
  globalmessage_->assign(value);
}
inline void ResponseGotchaCommand::set_globalmessage(const char* value, size_t size) {
  set_has_globalmessage();
  if (globalmessage_ == &::google::protobuf::internal::kEmptyString) {
    globalmessage_ = new ::std::string;
  }
  globalmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseGotchaCommand::mutable_globalmessage() {
  set_has_globalmessage();
  if (globalmessage_ == &::google::protobuf::internal::kEmptyString) {
    globalmessage_ = new ::std::string;
  }
  return globalmessage_;
}
inline ::std::string* ResponseGotchaCommand::release_globalmessage() {
  clear_has_globalmessage();
  if (globalmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = globalmessage_;
    globalmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GotchaItemInfo

// required int32 type = 1;
inline bool GotchaItemInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GotchaItemInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GotchaItemInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GotchaItemInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 GotchaItemInfo::type() const {
  return type_;
}
inline void GotchaItemInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string name = 2;
inline bool GotchaItemInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GotchaItemInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GotchaItemInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GotchaItemInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GotchaItemInfo::name() const {
  return *name_;
}
inline void GotchaItemInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GotchaItemInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GotchaItemInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GotchaItemInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GotchaItemInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 number = 3;
inline bool GotchaItemInfo::has_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GotchaItemInfo::set_has_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GotchaItemInfo::clear_has_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GotchaItemInfo::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 GotchaItemInfo::number() const {
  return number_;
}
inline void GotchaItemInfo::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// RequestCheatInfoCommand

// required int32 CheatType = 1;
inline bool RequestCheatInfoCommand::has_cheattype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCheatInfoCommand::set_has_cheattype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCheatInfoCommand::clear_has_cheattype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCheatInfoCommand::clear_cheattype() {
  cheattype_ = 0;
  clear_has_cheattype();
}
inline ::google::protobuf::int32 RequestCheatInfoCommand::cheattype() const {
  return cheattype_;
}
inline void RequestCheatInfoCommand::set_cheattype(::google::protobuf::int32 value) {
  set_has_cheattype();
  cheattype_ = value;
}

// optional string CarConfigName = 2;
inline bool RequestCheatInfoCommand::has_carconfigname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCheatInfoCommand::set_has_carconfigname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCheatInfoCommand::clear_has_carconfigname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCheatInfoCommand::clear_carconfigname() {
  if (carconfigname_ != &::google::protobuf::internal::kEmptyString) {
    carconfigname_->clear();
  }
  clear_has_carconfigname();
}
inline const ::std::string& RequestCheatInfoCommand::carconfigname() const {
  return *carconfigname_;
}
inline void RequestCheatInfoCommand::set_carconfigname(const ::std::string& value) {
  set_has_carconfigname();
  if (carconfigname_ == &::google::protobuf::internal::kEmptyString) {
    carconfigname_ = new ::std::string;
  }
  carconfigname_->assign(value);
}
inline void RequestCheatInfoCommand::set_carconfigname(const char* value) {
  set_has_carconfigname();
  if (carconfigname_ == &::google::protobuf::internal::kEmptyString) {
    carconfigname_ = new ::std::string;
  }
  carconfigname_->assign(value);
}
inline void RequestCheatInfoCommand::set_carconfigname(const char* value, size_t size) {
  set_has_carconfigname();
  if (carconfigname_ == &::google::protobuf::internal::kEmptyString) {
    carconfigname_ = new ::std::string;
  }
  carconfigname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestCheatInfoCommand::mutable_carconfigname() {
  set_has_carconfigname();
  if (carconfigname_ == &::google::protobuf::internal::kEmptyString) {
    carconfigname_ = new ::std::string;
  }
  return carconfigname_;
}
inline ::std::string* RequestCheatInfoCommand::release_carconfigname() {
  clear_has_carconfigname();
  if (carconfigname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carconfigname_;
    carconfigname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 MidGearSpd = 3;
inline bool RequestCheatInfoCommand::has_midgearspd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestCheatInfoCommand::set_has_midgearspd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestCheatInfoCommand::clear_has_midgearspd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestCheatInfoCommand::clear_midgearspd() {
  midgearspd_ = 0;
  clear_has_midgearspd();
}
inline ::google::protobuf::int32 RequestCheatInfoCommand::midgearspd() const {
  return midgearspd_;
}
inline void RequestCheatInfoCommand::set_midgearspd(::google::protobuf::int32 value) {
  set_has_midgearspd();
  midgearspd_ = value;
}

// optional int32 TopGearSpd = 4;
inline bool RequestCheatInfoCommand::has_topgearspd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestCheatInfoCommand::set_has_topgearspd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestCheatInfoCommand::clear_has_topgearspd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestCheatInfoCommand::clear_topgearspd() {
  topgearspd_ = 0;
  clear_has_topgearspd();
}
inline ::google::protobuf::int32 RequestCheatInfoCommand::topgearspd() const {
  return topgearspd_;
}
inline void RequestCheatInfoCommand::set_topgearspd(::google::protobuf::int32 value) {
  set_has_topgearspd();
  topgearspd_ = value;
}

// optional string ExeFileMD5 = 5;
inline bool RequestCheatInfoCommand::has_exefilemd5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestCheatInfoCommand::set_has_exefilemd5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestCheatInfoCommand::clear_has_exefilemd5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestCheatInfoCommand::clear_exefilemd5() {
  if (exefilemd5_ != &::google::protobuf::internal::kEmptyString) {
    exefilemd5_->clear();
  }
  clear_has_exefilemd5();
}
inline const ::std::string& RequestCheatInfoCommand::exefilemd5() const {
  return *exefilemd5_;
}
inline void RequestCheatInfoCommand::set_exefilemd5(const ::std::string& value) {
  set_has_exefilemd5();
  if (exefilemd5_ == &::google::protobuf::internal::kEmptyString) {
    exefilemd5_ = new ::std::string;
  }
  exefilemd5_->assign(value);
}
inline void RequestCheatInfoCommand::set_exefilemd5(const char* value) {
  set_has_exefilemd5();
  if (exefilemd5_ == &::google::protobuf::internal::kEmptyString) {
    exefilemd5_ = new ::std::string;
  }
  exefilemd5_->assign(value);
}
inline void RequestCheatInfoCommand::set_exefilemd5(const char* value, size_t size) {
  set_has_exefilemd5();
  if (exefilemd5_ == &::google::protobuf::internal::kEmptyString) {
    exefilemd5_ = new ::std::string;
  }
  exefilemd5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestCheatInfoCommand::mutable_exefilemd5() {
  set_has_exefilemd5();
  if (exefilemd5_ == &::google::protobuf::internal::kEmptyString) {
    exefilemd5_ = new ::std::string;
  }
  return exefilemd5_;
}
inline ::std::string* RequestCheatInfoCommand::release_exefilemd5() {
  clear_has_exefilemd5();
  if (exefilemd5_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exefilemd5_;
    exefilemd5_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string UserSelectCarID = 6;
inline bool RequestCheatInfoCommand::has_userselectcarid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestCheatInfoCommand::set_has_userselectcarid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestCheatInfoCommand::clear_has_userselectcarid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestCheatInfoCommand::clear_userselectcarid() {
  if (userselectcarid_ != &::google::protobuf::internal::kEmptyString) {
    userselectcarid_->clear();
  }
  clear_has_userselectcarid();
}
inline const ::std::string& RequestCheatInfoCommand::userselectcarid() const {
  return *userselectcarid_;
}
inline void RequestCheatInfoCommand::set_userselectcarid(const ::std::string& value) {
  set_has_userselectcarid();
  if (userselectcarid_ == &::google::protobuf::internal::kEmptyString) {
    userselectcarid_ = new ::std::string;
  }
  userselectcarid_->assign(value);
}
inline void RequestCheatInfoCommand::set_userselectcarid(const char* value) {
  set_has_userselectcarid();
  if (userselectcarid_ == &::google::protobuf::internal::kEmptyString) {
    userselectcarid_ = new ::std::string;
  }
  userselectcarid_->assign(value);
}
inline void RequestCheatInfoCommand::set_userselectcarid(const char* value, size_t size) {
  set_has_userselectcarid();
  if (userselectcarid_ == &::google::protobuf::internal::kEmptyString) {
    userselectcarid_ = new ::std::string;
  }
  userselectcarid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestCheatInfoCommand::mutable_userselectcarid() {
  set_has_userselectcarid();
  if (userselectcarid_ == &::google::protobuf::internal::kEmptyString) {
    userselectcarid_ = new ::std::string;
  }
  return userselectcarid_;
}
inline ::std::string* RequestCheatInfoCommand::release_userselectcarid() {
  clear_has_userselectcarid();
  if (userselectcarid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userselectcarid_;
    userselectcarid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LeaderboardClass

// required int32 id = 1;
inline bool LeaderboardClass::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderboardClass::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderboardClass::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderboardClass::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 LeaderboardClass::id() const {
  return id_;
}
inline void LeaderboardClass::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool LeaderboardClass::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaderboardClass::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaderboardClass::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaderboardClass::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LeaderboardClass::name() const {
  return *name_;
}
inline void LeaderboardClass::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaderboardClass::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaderboardClass::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderboardClass::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LeaderboardClass::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 type = 3;
inline bool LeaderboardClass::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaderboardClass::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaderboardClass::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaderboardClass::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 LeaderboardClass::type() const {
  return type_;
}
inline void LeaderboardClass::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// LeaderboardItem

// required int32 rank = 1;
inline bool LeaderboardItem::has_rank() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderboardItem::set_has_rank() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderboardItem::clear_has_rank() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderboardItem::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 LeaderboardItem::rank() const {
  return rank_;
}
inline void LeaderboardItem::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// required string name = 2;
inline bool LeaderboardItem::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaderboardItem::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaderboardItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaderboardItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LeaderboardItem::name() const {
  return *name_;
}
inline void LeaderboardItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaderboardItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LeaderboardItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderboardItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LeaderboardItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int64 userId = 3;
inline bool LeaderboardItem::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaderboardItem::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaderboardItem::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaderboardItem::clear_userid() {
  userid_ = GOOGLE_LONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::int64 LeaderboardItem::userid() const {
  return userid_;
}
inline void LeaderboardItem::set_userid(::google::protobuf::int64 value) {
  set_has_userid();
  userid_ = value;
}

// required int32 headIndex = 4;
inline bool LeaderboardItem::has_headindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LeaderboardItem::set_has_headindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LeaderboardItem::clear_has_headindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LeaderboardItem::clear_headindex() {
  headindex_ = 0;
  clear_has_headindex();
}
inline ::google::protobuf::int32 LeaderboardItem::headindex() const {
  return headindex_;
}
inline void LeaderboardItem::set_headindex(::google::protobuf::int32 value) {
  set_has_headindex();
  headindex_ = value;
}

// optional string headUrl = 5;
inline bool LeaderboardItem::has_headurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LeaderboardItem::set_has_headurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LeaderboardItem::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LeaderboardItem::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& LeaderboardItem::headurl() const {
  return *headurl_;
}
inline void LeaderboardItem::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void LeaderboardItem::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void LeaderboardItem::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderboardItem::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* LeaderboardItem::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string text = 6;
inline bool LeaderboardItem::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LeaderboardItem::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LeaderboardItem::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LeaderboardItem::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& LeaderboardItem::text() const {
  return *text_;
}
inline void LeaderboardItem::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LeaderboardItem::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void LeaderboardItem::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LeaderboardItem::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* LeaderboardItem::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 rpLevel = 7;
inline bool LeaderboardItem::has_rplevel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LeaderboardItem::set_has_rplevel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LeaderboardItem::clear_has_rplevel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LeaderboardItem::clear_rplevel() {
  rplevel_ = 0;
  clear_has_rplevel();
}
inline ::google::protobuf::int32 LeaderboardItem::rplevel() const {
  return rplevel_;
}
inline void LeaderboardItem::set_rplevel(::google::protobuf::int32 value) {
  set_has_rplevel();
  rplevel_ = value;
}

// optional int32 rpNum = 8;
inline bool LeaderboardItem::has_rpnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LeaderboardItem::set_has_rpnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LeaderboardItem::clear_has_rpnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LeaderboardItem::clear_rpnum() {
  rpnum_ = 0;
  clear_has_rpnum();
}
inline ::google::protobuf::int32 LeaderboardItem::rpnum() const {
  return rpnum_;
}
inline void LeaderboardItem::set_rpnum(::google::protobuf::int32 value) {
  set_has_rpnum();
  rpnum_ = value;
}

// optional bool isMyself = 9;
inline bool LeaderboardItem::has_ismyself() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LeaderboardItem::set_has_ismyself() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LeaderboardItem::clear_has_ismyself() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LeaderboardItem::clear_ismyself() {
  ismyself_ = false;
  clear_has_ismyself();
}
inline bool LeaderboardItem::ismyself() const {
  return ismyself_;
}
inline void LeaderboardItem::set_ismyself(bool value) {
  set_has_ismyself();
  ismyself_ = value;
}

// -------------------------------------------------------------------

// RequestLeaderboardClass

// -------------------------------------------------------------------

// ResponseLeaderboardClass

// repeated .com.ea.eamobile.nfsmw.protoc.LeaderboardClass clases = 1;
inline int ResponseLeaderboardClass::clases_size() const {
  return clases_.size();
}
inline void ResponseLeaderboardClass::clear_clases() {
  clases_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass& ResponseLeaderboardClass::clases(int index) const {
  return clases_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass* ResponseLeaderboardClass::mutable_clases(int index) {
  return clases_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass* ResponseLeaderboardClass::add_clases() {
  return clases_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass >&
ResponseLeaderboardClass::clases() const {
  return clases_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardClass >*
ResponseLeaderboardClass::mutable_clases() {
  return &clases_;
}

// -------------------------------------------------------------------

// LeaderboardHeadInfo

// required int32 classId = 1;
inline bool LeaderboardHeadInfo::has_classid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderboardHeadInfo::set_has_classid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderboardHeadInfo::clear_has_classid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderboardHeadInfo::clear_classid() {
  classid_ = 0;
  clear_has_classid();
}
inline ::google::protobuf::int32 LeaderboardHeadInfo::classid() const {
  return classid_;
}
inline void LeaderboardHeadInfo::set_classid(::google::protobuf::int32 value) {
  set_has_classid();
  classid_ = value;
}

// required int32 tier = 2;
inline bool LeaderboardHeadInfo::has_tier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaderboardHeadInfo::set_has_tier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaderboardHeadInfo::clear_has_tier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaderboardHeadInfo::clear_tier() {
  tier_ = 0;
  clear_has_tier();
}
inline ::google::protobuf::int32 LeaderboardHeadInfo::tier() const {
  return tier_;
}
inline void LeaderboardHeadInfo::set_tier(::google::protobuf::int32 value) {
  set_has_tier();
  tier_ = value;
}

// required int32 range = 3;
inline bool LeaderboardHeadInfo::has_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaderboardHeadInfo::set_has_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaderboardHeadInfo::clear_has_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaderboardHeadInfo::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline ::google::protobuf::int32 LeaderboardHeadInfo::range() const {
  return range_;
}
inline void LeaderboardHeadInfo::set_range(::google::protobuf::int32 value) {
  set_has_range();
  range_ = value;
}

// -------------------------------------------------------------------

// RequestLeaderboard

// required .com.ea.eamobile.nfsmw.protoc.LeaderboardHeadInfo info = 1;
inline bool RequestLeaderboard::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestLeaderboard::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestLeaderboard::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestLeaderboard::clear_info() {
  if (info_ != NULL) info_->::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo::Clear();
  clear_has_info();
}
inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo& RequestLeaderboard::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* RequestLeaderboard::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo;
  return info_;
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* RequestLeaderboard::release_info() {
  clear_has_info();
  ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* temp = info_;
  info_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ResponseLeaderboard

// required .com.ea.eamobile.nfsmw.protoc.LeaderboardHeadInfo info = 1;
inline bool ResponseLeaderboard::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseLeaderboard::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseLeaderboard::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseLeaderboard::clear_info() {
  if (info_ != NULL) info_->::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo::Clear();
  clear_has_info();
}
inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo& ResponseLeaderboard::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* ResponseLeaderboard::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo;
  return info_;
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* ResponseLeaderboard::release_info() {
  clear_has_info();
  ::com::ea::eamobile::nfsmw::protoc::LeaderboardHeadInfo* temp = info_;
  info_ = NULL;
  return temp;
}

// repeated .com.ea.eamobile.nfsmw.protoc.LeaderboardItem items = 2;
inline int ResponseLeaderboard::items_size() const {
  return items_.size();
}
inline void ResponseLeaderboard::clear_items() {
  items_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem& ResponseLeaderboard::items(int index) const {
  return items_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem* ResponseLeaderboard::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem* ResponseLeaderboard::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem >&
ResponseLeaderboard::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::LeaderboardItem >*
ResponseLeaderboard::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// RequestTournamentNum

// -------------------------------------------------------------------

// ResponseTournamentNum

// required int32 rewardNum = 1;
inline bool ResponseTournamentNum::has_rewardnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseTournamentNum::set_has_rewardnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseTournamentNum::clear_has_rewardnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseTournamentNum::clear_rewardnum() {
  rewardnum_ = 0;
  clear_has_rewardnum();
}
inline ::google::protobuf::int32 ResponseTournamentNum::rewardnum() const {
  return rewardnum_;
}
inline void ResponseTournamentNum::set_rewardnum(::google::protobuf::int32 value) {
  set_has_rewardnum();
  rewardnum_ = value;
}

// -------------------------------------------------------------------

// RequestCollectEnergyCommand

// -------------------------------------------------------------------

// RequestEnergyTimeCommand

// -------------------------------------------------------------------

// ResponseEnergyTimeCommand

// required int32 starttime = 1;
inline bool ResponseEnergyTimeCommand::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseEnergyTimeCommand::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseEnergyTimeCommand::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseEnergyTimeCommand::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline ::google::protobuf::int32 ResponseEnergyTimeCommand::starttime() const {
  return starttime_;
}
inline void ResponseEnergyTimeCommand::set_starttime(::google::protobuf::int32 value) {
  set_has_starttime();
  starttime_ = value;
}

// required int32 endtime = 2;
inline bool ResponseEnergyTimeCommand::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseEnergyTimeCommand::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseEnergyTimeCommand::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseEnergyTimeCommand::clear_endtime() {
  endtime_ = 0;
  clear_has_endtime();
}
inline ::google::protobuf::int32 ResponseEnergyTimeCommand::endtime() const {
  return endtime_;
}
inline void ResponseEnergyTimeCommand::set_endtime(::google::protobuf::int32 value) {
  set_has_endtime();
  endtime_ = value;
}

// required int32 energy = 3;
inline bool ResponseEnergyTimeCommand::has_energy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseEnergyTimeCommand::set_has_energy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseEnergyTimeCommand::clear_has_energy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseEnergyTimeCommand::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline ::google::protobuf::int32 ResponseEnergyTimeCommand::energy() const {
  return energy_;
}
inline void ResponseEnergyTimeCommand::set_energy(::google::protobuf::int32 value) {
  set_has_energy();
  energy_ = value;
}

// -------------------------------------------------------------------

// RequestFansRewardCommand

// required int32 id = 1;
inline bool RequestFansRewardCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFansRewardCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFansRewardCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFansRewardCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestFansRewardCommand::id() const {
  return id_;
}
inline void RequestFansRewardCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ResponseFansRewardTimeCommand

// optional int32 id = 1;
inline bool ResponseFansRewardTimeCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseFansRewardTimeCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseFansRewardTimeCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseFansRewardTimeCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ResponseFansRewardTimeCommand::id() const {
  return id_;
}
inline void ResponseFansRewardTimeCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 starttime = 2;
inline bool ResponseFansRewardTimeCommand::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseFansRewardTimeCommand::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseFansRewardTimeCommand::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseFansRewardTimeCommand::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline ::google::protobuf::int32 ResponseFansRewardTimeCommand::starttime() const {
  return starttime_;
}
inline void ResponseFansRewardTimeCommand::set_starttime(::google::protobuf::int32 value) {
  set_has_starttime();
  starttime_ = value;
}

// -------------------------------------------------------------------

// RequestPropPurchaseCommand

// required int32 id = 1;
inline bool RequestPropPurchaseCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPropPurchaseCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPropPurchaseCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPropPurchaseCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestPropPurchaseCommand::id() const {
  return id_;
}
inline void RequestPropPurchaseCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 count = 2;
inline bool RequestPropPurchaseCommand::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPropPurchaseCommand::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPropPurchaseCommand::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPropPurchaseCommand::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 RequestPropPurchaseCommand::count() const {
  return count_;
}
inline void RequestPropPurchaseCommand::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// RequestMissionRewardCommand

// -------------------------------------------------------------------

// RequestMissionFinishCommand

// required int32 id = 1;
inline bool RequestMissionFinishCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestMissionFinishCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestMissionFinishCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestMissionFinishCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestMissionFinishCommand::id() const {
  return id_;
}
inline void RequestMissionFinishCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ResponseMissionListCommand

// repeated .com.ea.eamobile.nfsmw.protoc.MissionInfo missions = 1;
inline int ResponseMissionListCommand::missions_size() const {
  return missions_.size();
}
inline void ResponseMissionListCommand::clear_missions() {
  missions_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::MissionInfo& ResponseMissionListCommand::missions(int index) const {
  return missions_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::MissionInfo* ResponseMissionListCommand::mutable_missions(int index) {
  return missions_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::MissionInfo* ResponseMissionListCommand::add_missions() {
  return missions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::MissionInfo >&
ResponseMissionListCommand::missions() const {
  return missions_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::MissionInfo >*
ResponseMissionListCommand::mutable_missions() {
  return &missions_;
}

// -------------------------------------------------------------------

// RequestLotteryCommand

// required int32 lotteryType = 1;
inline bool RequestLotteryCommand::has_lotterytype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestLotteryCommand::set_has_lotterytype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestLotteryCommand::clear_has_lotterytype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestLotteryCommand::clear_lotterytype() {
  lotterytype_ = 0;
  clear_has_lotterytype();
}
inline ::google::protobuf::int32 RequestLotteryCommand::lotterytype() const {
  return lotterytype_;
}
inline void RequestLotteryCommand::set_lotterytype(::google::protobuf::int32 value) {
  set_has_lotterytype();
  lotterytype_ = value;
}

// -------------------------------------------------------------------

// ResponseLotteryCommand

// repeated .com.ea.eamobile.nfsmw.protoc.RewardList rewards = 1;
inline int ResponseLotteryCommand::rewards_size() const {
  return rewards_.size();
}
inline void ResponseLotteryCommand::clear_rewards() {
  rewards_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RewardList& ResponseLotteryCommand::rewards(int index) const {
  return rewards_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RewardList* ResponseLotteryCommand::mutable_rewards(int index) {
  return rewards_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RewardList* ResponseLotteryCommand::add_rewards() {
  return rewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >&
ResponseLotteryCommand::rewards() const {
  return rewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >*
ResponseLotteryCommand::mutable_rewards() {
  return &rewards_;
}

// -------------------------------------------------------------------

// RequestFleetRaceCommand

// -------------------------------------------------------------------

// ResponseFleetRaceCommand

// repeated .com.ea.eamobile.nfsmw.protoc.FleetRace races = 1;
inline int ResponseFleetRaceCommand::races_size() const {
  return races_.size();
}
inline void ResponseFleetRaceCommand::clear_races() {
  races_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::FleetRace& ResponseFleetRaceCommand::races(int index) const {
  return races_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::FleetRace* ResponseFleetRaceCommand::mutable_races(int index) {
  return races_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::FleetRace* ResponseFleetRaceCommand::add_races() {
  return races_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::FleetRace >&
ResponseFleetRaceCommand::races() const {
  return races_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::FleetRace >*
ResponseFleetRaceCommand::mutable_races() {
  return &races_;
}

// repeated .com.ea.eamobile.nfsmw.protoc.RpLeaderboardMessage rpLeaderboard = 2;
inline int ResponseFleetRaceCommand::rpleaderboard_size() const {
  return rpleaderboard_.size();
}
inline void ResponseFleetRaceCommand::clear_rpleaderboard() {
  rpleaderboard_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage& ResponseFleetRaceCommand::rpleaderboard(int index) const {
  return rpleaderboard_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage* ResponseFleetRaceCommand::mutable_rpleaderboard(int index) {
  return rpleaderboard_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage* ResponseFleetRaceCommand::add_rpleaderboard() {
  return rpleaderboard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage >&
ResponseFleetRaceCommand::rpleaderboard() const {
  return rpleaderboard_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RpLeaderboardMessage >*
ResponseFleetRaceCommand::mutable_rpleaderboard() {
  return &rpleaderboard_;
}

// required int32 selfRank = 3;
inline bool ResponseFleetRaceCommand::has_selfrank() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseFleetRaceCommand::set_has_selfrank() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseFleetRaceCommand::clear_has_selfrank() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseFleetRaceCommand::clear_selfrank() {
  selfrank_ = 0;
  clear_has_selfrank();
}
inline ::google::protobuf::int32 ResponseFleetRaceCommand::selfrank() const {
  return selfrank_;
}
inline void ResponseFleetRaceCommand::set_selfrank(::google::protobuf::int32 value) {
  set_has_selfrank();
  selfrank_ = value;
}

// -------------------------------------------------------------------

// RequestFleetStartCommand

// required int32 id = 1;
inline bool RequestFleetStartCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFleetStartCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFleetStartCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFleetStartCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestFleetStartCommand::id() const {
  return id_;
}
inline void RequestFleetStartCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated string cars = 2;
inline int RequestFleetStartCommand::cars_size() const {
  return cars_.size();
}
inline void RequestFleetStartCommand::clear_cars() {
  cars_.Clear();
}
inline const ::std::string& RequestFleetStartCommand::cars(int index) const {
  return cars_.Get(index);
}
inline ::std::string* RequestFleetStartCommand::mutable_cars(int index) {
  return cars_.Mutable(index);
}
inline void RequestFleetStartCommand::set_cars(int index, const ::std::string& value) {
  cars_.Mutable(index)->assign(value);
}
inline void RequestFleetStartCommand::set_cars(int index, const char* value) {
  cars_.Mutable(index)->assign(value);
}
inline void RequestFleetStartCommand::set_cars(int index, const char* value, size_t size) {
  cars_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestFleetStartCommand::add_cars() {
  return cars_.Add();
}
inline void RequestFleetStartCommand::add_cars(const ::std::string& value) {
  cars_.Add()->assign(value);
}
inline void RequestFleetStartCommand::add_cars(const char* value) {
  cars_.Add()->assign(value);
}
inline void RequestFleetStartCommand::add_cars(const char* value, size_t size) {
  cars_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RequestFleetStartCommand::cars() const {
  return cars_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RequestFleetStartCommand::mutable_cars() {
  return &cars_;
}

// -------------------------------------------------------------------

// ResponseFleetStartCommand

// required int32 id = 1;
inline bool ResponseFleetStartCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseFleetStartCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseFleetStartCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseFleetStartCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ResponseFleetStartCommand::id() const {
  return id_;
}
inline void ResponseFleetStartCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 result = 2;
inline bool ResponseFleetStartCommand::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseFleetStartCommand::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseFleetStartCommand::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseFleetStartCommand::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseFleetStartCommand::result() const {
  return result_;
}
inline void ResponseFleetStartCommand::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string displayName = 3;
inline bool ResponseFleetStartCommand::has_displayname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseFleetStartCommand::set_has_displayname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseFleetStartCommand::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseFleetStartCommand::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& ResponseFleetStartCommand::displayname() const {
  return *displayname_;
}
inline void ResponseFleetStartCommand::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ResponseFleetStartCommand::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ResponseFleetStartCommand::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseFleetStartCommand::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* ResponseFleetStartCommand::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestFleetEndCommand

// required int32 id = 1;
inline bool RequestFleetEndCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFleetEndCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFleetEndCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFleetEndCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestFleetEndCommand::id() const {
  return id_;
}
inline void RequestFleetEndCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional bool advanced = 2;
inline bool RequestFleetEndCommand::has_advanced() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestFleetEndCommand::set_has_advanced() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestFleetEndCommand::clear_has_advanced() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestFleetEndCommand::clear_advanced() {
  advanced_ = false;
  clear_has_advanced();
}
inline bool RequestFleetEndCommand::advanced() const {
  return advanced_;
}
inline void RequestFleetEndCommand::set_advanced(bool value) {
  set_has_advanced();
  advanced_ = value;
}

// -------------------------------------------------------------------

// ResponseFleetEndCommand

// required int32 id = 1;
inline bool ResponseFleetEndCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseFleetEndCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseFleetEndCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseFleetEndCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ResponseFleetEndCommand::id() const {
  return id_;
}
inline void ResponseFleetEndCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 result = 2;
inline bool ResponseFleetEndCommand::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseFleetEndCommand::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseFleetEndCommand::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseFleetEndCommand::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseFleetEndCommand::result() const {
  return result_;
}
inline void ResponseFleetEndCommand::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string displayName = 3;
inline bool ResponseFleetEndCommand::has_displayname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseFleetEndCommand::set_has_displayname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseFleetEndCommand::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseFleetEndCommand::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& ResponseFleetEndCommand::displayname() const {
  return *displayname_;
}
inline void ResponseFleetEndCommand::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ResponseFleetEndCommand::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ResponseFleetEndCommand::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseFleetEndCommand::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* ResponseFleetEndCommand::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 rank = 4;
inline bool ResponseFleetEndCommand::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseFleetEndCommand::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseFleetEndCommand::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseFleetEndCommand::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 ResponseFleetEndCommand::rank() const {
  return rank_;
}
inline void ResponseFleetEndCommand::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
}

// repeated .com.ea.eamobile.nfsmw.protoc.RewardList rewards = 5;
inline int ResponseFleetEndCommand::rewards_size() const {
  return rewards_.size();
}
inline void ResponseFleetEndCommand::clear_rewards() {
  rewards_.Clear();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RewardList& ResponseFleetEndCommand::rewards(int index) const {
  return rewards_.Get(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RewardList* ResponseFleetEndCommand::mutable_rewards(int index) {
  return rewards_.Mutable(index);
}
inline ::com::ea::eamobile::nfsmw::protoc::RewardList* ResponseFleetEndCommand::add_rewards() {
  return rewards_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >&
ResponseFleetEndCommand::rewards() const {
  return rewards_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::ea::eamobile::nfsmw::protoc::RewardList >*
ResponseFleetEndCommand::mutable_rewards() {
  return &rewards_;
}

// -------------------------------------------------------------------

// RequestFleetDoubleCommand

// required int32 id = 1;
inline bool RequestFleetDoubleCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFleetDoubleCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFleetDoubleCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFleetDoubleCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RequestFleetDoubleCommand::id() const {
  return id_;
}
inline void RequestFleetDoubleCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ResponseFleetDoubleCommand

// required int32 id = 1;
inline bool ResponseFleetDoubleCommand::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseFleetDoubleCommand::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseFleetDoubleCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseFleetDoubleCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ResponseFleetDoubleCommand::id() const {
  return id_;
}
inline void ResponseFleetDoubleCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 result = 2;
inline bool ResponseFleetDoubleCommand::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseFleetDoubleCommand::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseFleetDoubleCommand::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseFleetDoubleCommand::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseFleetDoubleCommand::result() const {
  return result_;
}
inline void ResponseFleetDoubleCommand::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string displayName = 3;
inline bool ResponseFleetDoubleCommand::has_displayname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseFleetDoubleCommand::set_has_displayname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseFleetDoubleCommand::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseFleetDoubleCommand::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& ResponseFleetDoubleCommand::displayname() const {
  return *displayname_;
}
inline void ResponseFleetDoubleCommand::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ResponseFleetDoubleCommand::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ResponseFleetDoubleCommand::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseFleetDoubleCommand::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* ResponseFleetDoubleCommand::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestFixCarLimitCommand

// required string carId = 1;
inline bool RequestFixCarLimitCommand::has_carid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestFixCarLimitCommand::set_has_carid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestFixCarLimitCommand::clear_has_carid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestFixCarLimitCommand::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& RequestFixCarLimitCommand::carid() const {
  return *carid_;
}
inline void RequestFixCarLimitCommand::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestFixCarLimitCommand::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void RequestFixCarLimitCommand::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequestFixCarLimitCommand::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* RequestFixCarLimitCommand::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ResponseFixCarLimitCommand

// required string carId = 1;
inline bool ResponseFixCarLimitCommand::has_carid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseFixCarLimitCommand::set_has_carid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseFixCarLimitCommand::clear_has_carid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseFixCarLimitCommand::clear_carid() {
  if (carid_ != &::google::protobuf::internal::kEmptyString) {
    carid_->clear();
  }
  clear_has_carid();
}
inline const ::std::string& ResponseFixCarLimitCommand::carid() const {
  return *carid_;
}
inline void ResponseFixCarLimitCommand::set_carid(const ::std::string& value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void ResponseFixCarLimitCommand::set_carid(const char* value) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(value);
}
inline void ResponseFixCarLimitCommand::set_carid(const char* value, size_t size) {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  carid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseFixCarLimitCommand::mutable_carid() {
  set_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    carid_ = new ::std::string;
  }
  return carid_;
}
inline ::std::string* ResponseFixCarLimitCommand::release_carid() {
  clear_has_carid();
  if (carid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = carid_;
    carid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 result = 2;
inline bool ResponseFixCarLimitCommand::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseFixCarLimitCommand::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseFixCarLimitCommand::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseFixCarLimitCommand::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::google::protobuf::int32 ResponseFixCarLimitCommand::result() const {
  return result_;
}
inline void ResponseFixCarLimitCommand::set_result(::google::protobuf::int32 value) {
  set_has_result();
  result_ = value;
}

// required string displayName = 3;
inline bool ResponseFixCarLimitCommand::has_displayname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseFixCarLimitCommand::set_has_displayname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseFixCarLimitCommand::clear_has_displayname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseFixCarLimitCommand::clear_displayname() {
  if (displayname_ != &::google::protobuf::internal::kEmptyString) {
    displayname_->clear();
  }
  clear_has_displayname();
}
inline const ::std::string& ResponseFixCarLimitCommand::displayname() const {
  return *displayname_;
}
inline void ResponseFixCarLimitCommand::set_displayname(const ::std::string& value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ResponseFixCarLimitCommand::set_displayname(const char* value) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(value);
}
inline void ResponseFixCarLimitCommand::set_displayname(const char* value, size_t size) {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  displayname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseFixCarLimitCommand::mutable_displayname() {
  set_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    displayname_ = new ::std::string;
  }
  return displayname_;
}
inline ::std::string* ResponseFixCarLimitCommand::release_displayname() {
  clear_has_displayname();
  if (displayname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = displayname_;
    displayname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RequestCommand

// required .com.ea.eamobile.nfsmw.protoc.HeadInfo head = 1;
inline bool RequestCommand::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCommand::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCommand::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCommand::clear_head() {
  if (head_ != NULL) head_->::com::ea::eamobile::nfsmw::protoc::HeadInfo::Clear();
  clear_has_head();
}
inline const ::com::ea::eamobile::nfsmw::protoc::HeadInfo& RequestCommand::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::com::ea::eamobile::nfsmw::protoc::HeadInfo* RequestCommand::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::com::ea::eamobile::nfsmw::protoc::HeadInfo;
  return head_;
}
inline ::com::ea::eamobile::nfsmw::protoc::HeadInfo* RequestCommand::release_head() {
  clear_has_head();
  ::com::ea::eamobile::nfsmw::protoc::HeadInfo* temp = head_;
  head_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestTrackCommand trackCommand = 2;
inline bool RequestCommand::has_trackcommand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCommand::set_has_trackcommand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCommand::clear_has_trackcommand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCommand::clear_trackcommand() {
  if (trackcommand_ != NULL) trackcommand_->::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand::Clear();
  clear_has_trackcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand& RequestCommand::trackcommand() const {
  return trackcommand_ != NULL ? *trackcommand_ : *default_instance_->trackcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand* RequestCommand::mutable_trackcommand() {
  set_has_trackcommand();
  if (trackcommand_ == NULL) trackcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand;
  return trackcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand* RequestCommand::release_trackcommand() {
  clear_has_trackcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestTrackCommand* temp = trackcommand_;
  trackcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestUserInfoCommand loginCommand = 3;
inline bool RequestCommand::has_logincommand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestCommand::set_has_logincommand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestCommand::clear_has_logincommand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestCommand::clear_logincommand() {
  if (logincommand_ != NULL) logincommand_->::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand::Clear();
  clear_has_logincommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand& RequestCommand::logincommand() const {
  return logincommand_ != NULL ? *logincommand_ : *default_instance_->logincommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand* RequestCommand::mutable_logincommand() {
  set_has_logincommand();
  if (logincommand_ == NULL) logincommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand;
  return logincommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand* RequestCommand::release_logincommand() {
  clear_has_logincommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestUserInfoCommand* temp = logincommand_;
  logincommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestModeInfoCommand ghostCommand = 4;
inline bool RequestCommand::has_ghostcommand() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RequestCommand::set_has_ghostcommand() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RequestCommand::clear_has_ghostcommand() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RequestCommand::clear_ghostcommand() {
  if (ghostcommand_ != NULL) ghostcommand_->::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand::Clear();
  clear_has_ghostcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand& RequestCommand::ghostcommand() const {
  return ghostcommand_ != NULL ? *ghostcommand_ : *default_instance_->ghostcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand* RequestCommand::mutable_ghostcommand() {
  set_has_ghostcommand();
  if (ghostcommand_ == NULL) ghostcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand;
  return ghostcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand* RequestCommand::release_ghostcommand() {
  clear_has_ghostcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestModeInfoCommand* temp = ghostcommand_;
  ghostcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestRaceResultCommand raceResultCommand = 5;
inline bool RequestCommand::has_raceresultcommand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RequestCommand::set_has_raceresultcommand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RequestCommand::clear_has_raceresultcommand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RequestCommand::clear_raceresultcommand() {
  if (raceresultcommand_ != NULL) raceresultcommand_->::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand::Clear();
  clear_has_raceresultcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand& RequestCommand::raceresultcommand() const {
  return raceresultcommand_ != NULL ? *raceresultcommand_ : *default_instance_->raceresultcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand* RequestCommand::mutable_raceresultcommand() {
  set_has_raceresultcommand();
  if (raceresultcommand_ == NULL) raceresultcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand;
  return raceresultcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand* RequestCommand::release_raceresultcommand() {
  clear_has_raceresultcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestRaceResultCommand* temp = raceresultcommand_;
  raceresultcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentDetailCommand tournamentDetailCommand = 6;
inline bool RequestCommand::has_tournamentdetailcommand() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RequestCommand::set_has_tournamentdetailcommand() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RequestCommand::clear_has_tournamentdetailcommand() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RequestCommand::clear_tournamentdetailcommand() {
  if (tournamentdetailcommand_ != NULL) tournamentdetailcommand_->::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand::Clear();
  clear_has_tournamentdetailcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand& RequestCommand::tournamentdetailcommand() const {
  return tournamentdetailcommand_ != NULL ? *tournamentdetailcommand_ : *default_instance_->tournamentdetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand* RequestCommand::mutable_tournamentdetailcommand() {
  set_has_tournamentdetailcommand();
  if (tournamentdetailcommand_ == NULL) tournamentdetailcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand;
  return tournamentdetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand* RequestCommand::release_tournamentdetailcommand() {
  clear_has_tournamentdetailcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentDetailCommand* temp = tournamentdetailcommand_;
  tournamentdetailcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentRewardDetailCommand tournamentRewardDetailCommand = 7;
inline bool RequestCommand::has_tournamentrewarddetailcommand() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RequestCommand::set_has_tournamentrewarddetailcommand() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RequestCommand::clear_has_tournamentrewarddetailcommand() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RequestCommand::clear_tournamentrewarddetailcommand() {
  if (tournamentrewarddetailcommand_ != NULL) tournamentrewarddetailcommand_->::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand::Clear();
  clear_has_tournamentrewarddetailcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand& RequestCommand::tournamentrewarddetailcommand() const {
  return tournamentrewarddetailcommand_ != NULL ? *tournamentrewarddetailcommand_ : *default_instance_->tournamentrewarddetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand* RequestCommand::mutable_tournamentrewarddetailcommand() {
  set_has_tournamentrewarddetailcommand();
  if (tournamentrewarddetailcommand_ == NULL) tournamentrewarddetailcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand;
  return tournamentrewarddetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand* RequestCommand::release_tournamentrewarddetailcommand() {
  clear_has_tournamentrewarddetailcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentRewardDetailCommand* temp = tournamentrewarddetailcommand_;
  tournamentrewarddetailcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentCommand tournamentCommand = 9;
inline bool RequestCommand::has_tournamentcommand() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RequestCommand::set_has_tournamentcommand() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RequestCommand::clear_has_tournamentcommand() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RequestCommand::clear_tournamentcommand() {
  if (tournamentcommand_ != NULL) tournamentcommand_->::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand::Clear();
  clear_has_tournamentcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand& RequestCommand::tournamentcommand() const {
  return tournamentcommand_ != NULL ? *tournamentcommand_ : *default_instance_->tournamentcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand* RequestCommand::mutable_tournamentcommand() {
  set_has_tournamentcommand();
  if (tournamentcommand_ == NULL) tournamentcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand;
  return tournamentcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand* RequestCommand::release_tournamentcommand() {
  clear_has_tournamentcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentCommand* temp = tournamentcommand_;
  tournamentcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestResourceCommand resourceCommand = 10;
inline bool RequestCommand::has_resourcecommand() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RequestCommand::set_has_resourcecommand() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RequestCommand::clear_has_resourcecommand() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RequestCommand::clear_resourcecommand() {
  if (resourcecommand_ != NULL) resourcecommand_->::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand::Clear();
  clear_has_resourcecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand& RequestCommand::resourcecommand() const {
  return resourcecommand_ != NULL ? *resourcecommand_ : *default_instance_->resourcecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand* RequestCommand::mutable_resourcecommand() {
  set_has_resourcecommand();
  if (resourcecommand_ == NULL) resourcecommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand;
  return resourcecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand* RequestCommand::release_resourcecommand() {
  clear_has_resourcecommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestResourceCommand* temp = resourcecommand_;
  resourcecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentSignUpCommand tournamentSignUpCommand = 16;
inline bool RequestCommand::has_tournamentsignupcommand() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RequestCommand::set_has_tournamentsignupcommand() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RequestCommand::clear_has_tournamentsignupcommand() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RequestCommand::clear_tournamentsignupcommand() {
  if (tournamentsignupcommand_ != NULL) tournamentsignupcommand_->::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand::Clear();
  clear_has_tournamentsignupcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand& RequestCommand::tournamentsignupcommand() const {
  return tournamentsignupcommand_ != NULL ? *tournamentsignupcommand_ : *default_instance_->tournamentsignupcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand* RequestCommand::mutable_tournamentsignupcommand() {
  set_has_tournamentsignupcommand();
  if (tournamentsignupcommand_ == NULL) tournamentsignupcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand;
  return tournamentsignupcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand* RequestCommand::release_tournamentsignupcommand() {
  clear_has_tournamentsignupcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentSignUpCommand* temp = tournamentsignupcommand_;
  tournamentsignupcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestRaceStartCommand raceStartCommand = 18;
inline bool RequestCommand::has_racestartcommand() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RequestCommand::set_has_racestartcommand() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RequestCommand::clear_has_racestartcommand() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RequestCommand::clear_racestartcommand() {
  if (racestartcommand_ != NULL) racestartcommand_->::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand::Clear();
  clear_has_racestartcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand& RequestCommand::racestartcommand() const {
  return racestartcommand_ != NULL ? *racestartcommand_ : *default_instance_->racestartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand* RequestCommand::mutable_racestartcommand() {
  set_has_racestartcommand();
  if (racestartcommand_ == NULL) racestartcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand;
  return racestartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand* RequestCommand::release_racestartcommand() {
  clear_has_racestartcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestRaceStartCommand* temp = racestartcommand_;
  racestartcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestBindingStartCommand bindingStartCommand = 19;
inline bool RequestCommand::has_bindingstartcommand() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RequestCommand::set_has_bindingstartcommand() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RequestCommand::clear_has_bindingstartcommand() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RequestCommand::clear_bindingstartcommand() {
  if (bindingstartcommand_ != NULL) bindingstartcommand_->::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand::Clear();
  clear_has_bindingstartcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand& RequestCommand::bindingstartcommand() const {
  return bindingstartcommand_ != NULL ? *bindingstartcommand_ : *default_instance_->bindingstartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand* RequestCommand::mutable_bindingstartcommand() {
  set_has_bindingstartcommand();
  if (bindingstartcommand_ == NULL) bindingstartcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand;
  return bindingstartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand* RequestCommand::release_bindingstartcommand() {
  clear_has_bindingstartcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingStartCommand* temp = bindingstartcommand_;
  bindingstartcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestBindingResultCommand bindingResultCommand = 20;
inline bool RequestCommand::has_bindingresultcommand() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RequestCommand::set_has_bindingresultcommand() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RequestCommand::clear_has_bindingresultcommand() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RequestCommand::clear_bindingresultcommand() {
  if (bindingresultcommand_ != NULL) bindingresultcommand_->::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand::Clear();
  clear_has_bindingresultcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand& RequestCommand::bindingresultcommand() const {
  return bindingresultcommand_ != NULL ? *bindingresultcommand_ : *default_instance_->bindingresultcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand* RequestCommand::mutable_bindingresultcommand() {
  set_has_bindingresultcommand();
  if (bindingresultcommand_ == NULL) bindingresultcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand;
  return bindingresultcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand* RequestCommand::release_bindingresultcommand() {
  clear_has_bindingresultcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingResultCommand* temp = bindingresultcommand_;
  bindingresultcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestBindingConfirmCommand bindingConfirmCommand = 21;
inline bool RequestCommand::has_bindingconfirmcommand() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RequestCommand::set_has_bindingconfirmcommand() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RequestCommand::clear_has_bindingconfirmcommand() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RequestCommand::clear_bindingconfirmcommand() {
  if (bindingconfirmcommand_ != NULL) bindingconfirmcommand_->::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand::Clear();
  clear_has_bindingconfirmcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand& RequestCommand::bindingconfirmcommand() const {
  return bindingconfirmcommand_ != NULL ? *bindingconfirmcommand_ : *default_instance_->bindingconfirmcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand* RequestCommand::mutable_bindingconfirmcommand() {
  set_has_bindingconfirmcommand();
  if (bindingconfirmcommand_ == NULL) bindingconfirmcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand;
  return bindingconfirmcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand* RequestCommand::release_bindingconfirmcommand() {
  clear_has_bindingconfirmcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingConfirmCommand* temp = bindingconfirmcommand_;
  bindingconfirmcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestGetRewardCommand getRward = 22;
inline bool RequestCommand::has_getrward() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RequestCommand::set_has_getrward() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RequestCommand::clear_has_getrward() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RequestCommand::clear_getrward() {
  if (getrward_ != NULL) getrward_->::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand::Clear();
  clear_has_getrward();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand& RequestCommand::getrward() const {
  return getrward_ != NULL ? *getrward_ : *default_instance_->getrward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand* RequestCommand::mutable_getrward() {
  set_has_getrward();
  if (getrward_ == NULL) getrward_ = new ::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand;
  return getrward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand* RequestCommand::release_getrward() {
  clear_has_getrward();
  ::com::ea::eamobile::nfsmw::protoc::RequestGetRewardCommand* temp = getrward_;
  getrward_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestGarageCommand garageCommand = 23;
inline bool RequestCommand::has_garagecommand() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RequestCommand::set_has_garagecommand() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RequestCommand::clear_has_garagecommand() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RequestCommand::clear_garagecommand() {
  if (garagecommand_ != NULL) garagecommand_->::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand::Clear();
  clear_has_garagecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand& RequestCommand::garagecommand() const {
  return garagecommand_ != NULL ? *garagecommand_ : *default_instance_->garagecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand* RequestCommand::mutable_garagecommand() {
  set_has_garagecommand();
  if (garagecommand_ == NULL) garagecommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand;
  return garagecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand* RequestCommand::release_garagecommand() {
  clear_has_garagecommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestGarageCommand* temp = garagecommand_;
  garagecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestBuyCarCommand buyCarCommand = 24;
inline bool RequestCommand::has_buycarcommand() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RequestCommand::set_has_buycarcommand() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RequestCommand::clear_has_buycarcommand() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RequestCommand::clear_buycarcommand() {
  if (buycarcommand_ != NULL) buycarcommand_->::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand::Clear();
  clear_has_buycarcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand& RequestCommand::buycarcommand() const {
  return buycarcommand_ != NULL ? *buycarcommand_ : *default_instance_->buycarcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand* RequestCommand::mutable_buycarcommand() {
  set_has_buycarcommand();
  if (buycarcommand_ == NULL) buycarcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand;
  return buycarcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand* RequestCommand::release_buycarcommand() {
  clear_has_buycarcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestBuyCarCommand* temp = buycarcommand_;
  buycarcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestCarDataCommand carDataCommand = 25;
inline bool RequestCommand::has_cardatacommand() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RequestCommand::set_has_cardatacommand() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RequestCommand::clear_has_cardatacommand() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RequestCommand::clear_cardatacommand() {
  if (cardatacommand_ != NULL) cardatacommand_->::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand::Clear();
  clear_has_cardatacommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand& RequestCommand::cardatacommand() const {
  return cardatacommand_ != NULL ? *cardatacommand_ : *default_instance_->cardatacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand* RequestCommand::mutable_cardatacommand() {
  set_has_cardatacommand();
  if (cardatacommand_ == NULL) cardatacommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand;
  return cardatacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand* RequestCommand::release_cardatacommand() {
  clear_has_cardatacommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestCarDataCommand* temp = cardatacommand_;
  cardatacommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestUpgradeSlotCommand upgradeSlotCommand = 26;
inline bool RequestCommand::has_upgradeslotcommand() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RequestCommand::set_has_upgradeslotcommand() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RequestCommand::clear_has_upgradeslotcommand() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RequestCommand::clear_upgradeslotcommand() {
  if (upgradeslotcommand_ != NULL) upgradeslotcommand_->::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand::Clear();
  clear_has_upgradeslotcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand& RequestCommand::upgradeslotcommand() const {
  return upgradeslotcommand_ != NULL ? *upgradeslotcommand_ : *default_instance_->upgradeslotcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand* RequestCommand::mutable_upgradeslotcommand() {
  set_has_upgradeslotcommand();
  if (upgradeslotcommand_ == NULL) upgradeslotcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand;
  return upgradeslotcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand* RequestCommand::release_upgradeslotcommand() {
  clear_has_upgradeslotcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestUpgradeSlotCommand* temp = upgradeslotcommand_;
  upgradeslotcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestUseChartletCommand useChartletCommand = 27;
inline bool RequestCommand::has_usechartletcommand() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RequestCommand::set_has_usechartletcommand() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RequestCommand::clear_has_usechartletcommand() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RequestCommand::clear_usechartletcommand() {
  if (usechartletcommand_ != NULL) usechartletcommand_->::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand::Clear();
  clear_has_usechartletcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand& RequestCommand::usechartletcommand() const {
  return usechartletcommand_ != NULL ? *usechartletcommand_ : *default_instance_->usechartletcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand* RequestCommand::mutable_usechartletcommand() {
  set_has_usechartletcommand();
  if (usechartletcommand_ == NULL) usechartletcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand;
  return usechartletcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand* RequestCommand::release_usechartletcommand() {
  clear_has_usechartletcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestUseChartletCommand* temp = usechartletcommand_;
  usechartletcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestModifyUserInfoCommand modifyUserInfoCommand = 28;
inline bool RequestCommand::has_modifyuserinfocommand() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RequestCommand::set_has_modifyuserinfocommand() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RequestCommand::clear_has_modifyuserinfocommand() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RequestCommand::clear_modifyuserinfocommand() {
  if (modifyuserinfocommand_ != NULL) modifyuserinfocommand_->::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand::Clear();
  clear_has_modifyuserinfocommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand& RequestCommand::modifyuserinfocommand() const {
  return modifyuserinfocommand_ != NULL ? *modifyuserinfocommand_ : *default_instance_->modifyuserinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand* RequestCommand::mutable_modifyuserinfocommand() {
  set_has_modifyuserinfocommand();
  if (modifyuserinfocommand_ == NULL) modifyuserinfocommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand;
  return modifyuserinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand* RequestCommand::release_modifyuserinfocommand() {
  clear_has_modifyuserinfocommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestModifyUserInfoCommand* temp = modifyuserinfocommand_;
  modifyuserinfocommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestStoreDetailCommand storeDetailCommand = 29;
inline bool RequestCommand::has_storedetailcommand() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RequestCommand::set_has_storedetailcommand() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RequestCommand::clear_has_storedetailcommand() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RequestCommand::clear_storedetailcommand() {
  if (storedetailcommand_ != NULL) storedetailcommand_->::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand::Clear();
  clear_has_storedetailcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand& RequestCommand::storedetailcommand() const {
  return storedetailcommand_ != NULL ? *storedetailcommand_ : *default_instance_->storedetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand* RequestCommand::mutable_storedetailcommand() {
  set_has_storedetailcommand();
  if (storedetailcommand_ == NULL) storedetailcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand;
  return storedetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand* RequestCommand::release_storedetailcommand() {
  clear_has_storedetailcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestStoreDetailCommand* temp = storedetailcommand_;
  storedetailcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestBuyItemCommand buyItemCommand = 30;
inline bool RequestCommand::has_buyitemcommand() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RequestCommand::set_has_buyitemcommand() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RequestCommand::clear_has_buyitemcommand() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RequestCommand::clear_buyitemcommand() {
  if (buyitemcommand_ != NULL) buyitemcommand_->::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand::Clear();
  clear_has_buyitemcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand& RequestCommand::buyitemcommand() const {
  return buyitemcommand_ != NULL ? *buyitemcommand_ : *default_instance_->buyitemcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand* RequestCommand::mutable_buyitemcommand() {
  set_has_buyitemcommand();
  if (buyitemcommand_ == NULL) buyitemcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand;
  return buyitemcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand* RequestCommand::release_buyitemcommand() {
  clear_has_buyitemcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestBuyItemCommand* temp = buyitemcommand_;
  buyitemcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestRegistJaguarCommand registJaguar = 31;
inline bool RequestCommand::has_registjaguar() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RequestCommand::set_has_registjaguar() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RequestCommand::clear_has_registjaguar() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RequestCommand::clear_registjaguar() {
  if (registjaguar_ != NULL) registjaguar_->::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand::Clear();
  clear_has_registjaguar();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand& RequestCommand::registjaguar() const {
  return registjaguar_ != NULL ? *registjaguar_ : *default_instance_->registjaguar_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand* RequestCommand::mutable_registjaguar() {
  set_has_registjaguar();
  if (registjaguar_ == NULL) registjaguar_ = new ::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand;
  return registjaguar_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand* RequestCommand::release_registjaguar() {
  clear_has_registjaguar();
  ::com::ea::eamobile::nfsmw::protoc::RequestRegistJaguarCommand* temp = registjaguar_;
  registjaguar_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestIapCheckCommand IapCheckCommand = 32;
inline bool RequestCommand::has_iapcheckcommand() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RequestCommand::set_has_iapcheckcommand() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RequestCommand::clear_has_iapcheckcommand() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RequestCommand::clear_iapcheckcommand() {
  if (iapcheckcommand_ != NULL) iapcheckcommand_->::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand::Clear();
  clear_has_iapcheckcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand& RequestCommand::iapcheckcommand() const {
  return iapcheckcommand_ != NULL ? *iapcheckcommand_ : *default_instance_->iapcheckcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand* RequestCommand::mutable_iapcheckcommand() {
  set_has_iapcheckcommand();
  if (iapcheckcommand_ == NULL) iapcheckcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand;
  return iapcheckcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand* RequestCommand::release_iapcheckcommand() {
  clear_has_iapcheckcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestIapCheckCommand* temp = iapcheckcommand_;
  iapcheckcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestTutorialRewardCommand tutorialRewardCommand = 33;
inline bool RequestCommand::has_tutorialrewardcommand() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RequestCommand::set_has_tutorialrewardcommand() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RequestCommand::clear_has_tutorialrewardcommand() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RequestCommand::clear_tutorialrewardcommand() {
  if (tutorialrewardcommand_ != NULL) tutorialrewardcommand_->::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand::Clear();
  clear_has_tutorialrewardcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand& RequestCommand::tutorialrewardcommand() const {
  return tutorialrewardcommand_ != NULL ? *tutorialrewardcommand_ : *default_instance_->tutorialrewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand* RequestCommand::mutable_tutorialrewardcommand() {
  set_has_tutorialrewardcommand();
  if (tutorialrewardcommand_ == NULL) tutorialrewardcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand;
  return tutorialrewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand* RequestCommand::release_tutorialrewardcommand() {
  clear_has_tutorialrewardcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestTutorialRewardCommand* temp = tutorialrewardcommand_;
  tutorialrewardcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestRpLeaderboardCommand rpLeaderboardCommand = 34;
inline bool RequestCommand::has_rpleaderboardcommand() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RequestCommand::set_has_rpleaderboardcommand() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RequestCommand::clear_has_rpleaderboardcommand() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RequestCommand::clear_rpleaderboardcommand() {
  if (rpleaderboardcommand_ != NULL) rpleaderboardcommand_->::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand::Clear();
  clear_has_rpleaderboardcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand& RequestCommand::rpleaderboardcommand() const {
  return rpleaderboardcommand_ != NULL ? *rpleaderboardcommand_ : *default_instance_->rpleaderboardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand* RequestCommand::mutable_rpleaderboardcommand() {
  set_has_rpleaderboardcommand();
  if (rpleaderboardcommand_ == NULL) rpleaderboardcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand;
  return rpleaderboardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand* RequestCommand::release_rpleaderboardcommand() {
  clear_has_rpleaderboardcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestRpLeaderboardCommand* temp = rpleaderboardcommand_;
  rpleaderboardcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestGhostRecordCommand ghostRecordCommand = 35;
inline bool RequestCommand::has_ghostrecordcommand() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void RequestCommand::set_has_ghostrecordcommand() {
  _has_bits_[0] |= 0x08000000u;
}
inline void RequestCommand::clear_has_ghostrecordcommand() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void RequestCommand::clear_ghostrecordcommand() {
  if (ghostrecordcommand_ != NULL) ghostrecordcommand_->::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand::Clear();
  clear_has_ghostrecordcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand& RequestCommand::ghostrecordcommand() const {
  return ghostrecordcommand_ != NULL ? *ghostrecordcommand_ : *default_instance_->ghostrecordcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand* RequestCommand::mutable_ghostrecordcommand() {
  set_has_ghostrecordcommand();
  if (ghostrecordcommand_ == NULL) ghostrecordcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand;
  return ghostrecordcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand* RequestCommand::release_ghostrecordcommand() {
  clear_has_ghostrecordcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestGhostRecordCommand* temp = ghostrecordcommand_;
  ghostrecordcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestChallengeMathInfoCommand challengeMathInfoCommand = 36;
inline bool RequestCommand::has_challengemathinfocommand() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void RequestCommand::set_has_challengemathinfocommand() {
  _has_bits_[0] |= 0x10000000u;
}
inline void RequestCommand::clear_has_challengemathinfocommand() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void RequestCommand::clear_challengemathinfocommand() {
  if (challengemathinfocommand_ != NULL) challengemathinfocommand_->::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand::Clear();
  clear_has_challengemathinfocommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand& RequestCommand::challengemathinfocommand() const {
  return challengemathinfocommand_ != NULL ? *challengemathinfocommand_ : *default_instance_->challengemathinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand* RequestCommand::mutable_challengemathinfocommand() {
  set_has_challengemathinfocommand();
  if (challengemathinfocommand_ == NULL) challengemathinfocommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand;
  return challengemathinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand* RequestCommand::release_challengemathinfocommand() {
  clear_has_challengemathinfocommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestChallengeMathInfoCommand* temp = challengemathinfocommand_;
  challengemathinfocommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestProfileUserDataCommand profileUserDataCommand = 37;
inline bool RequestCommand::has_profileuserdatacommand() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void RequestCommand::set_has_profileuserdatacommand() {
  _has_bits_[0] |= 0x20000000u;
}
inline void RequestCommand::clear_has_profileuserdatacommand() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void RequestCommand::clear_profileuserdatacommand() {
  if (profileuserdatacommand_ != NULL) profileuserdatacommand_->::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand::Clear();
  clear_has_profileuserdatacommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand& RequestCommand::profileuserdatacommand() const {
  return profileuserdatacommand_ != NULL ? *profileuserdatacommand_ : *default_instance_->profileuserdatacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand* RequestCommand::mutable_profileuserdatacommand() {
  set_has_profileuserdatacommand();
  if (profileuserdatacommand_ == NULL) profileuserdatacommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand;
  return profileuserdatacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand* RequestCommand::release_profileuserdatacommand() {
  clear_has_profileuserdatacommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileUserDataCommand* temp = profileuserdatacommand_;
  profileuserdatacommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestProfileNextCarCommand profileNextCarCommand = 38;
inline bool RequestCommand::has_profilenextcarcommand() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void RequestCommand::set_has_profilenextcarcommand() {
  _has_bits_[0] |= 0x40000000u;
}
inline void RequestCommand::clear_has_profilenextcarcommand() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void RequestCommand::clear_profilenextcarcommand() {
  if (profilenextcarcommand_ != NULL) profilenextcarcommand_->::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand::Clear();
  clear_has_profilenextcarcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand& RequestCommand::profilenextcarcommand() const {
  return profilenextcarcommand_ != NULL ? *profilenextcarcommand_ : *default_instance_->profilenextcarcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand* RequestCommand::mutable_profilenextcarcommand() {
  set_has_profilenextcarcommand();
  if (profilenextcarcommand_ == NULL) profilenextcarcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand;
  return profilenextcarcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand* RequestCommand::release_profilenextcarcommand() {
  clear_has_profilenextcarcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileNextCarCommand* temp = profilenextcarcommand_;
  profilenextcarcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestProfileLikeCommand profileLikeCommand = 39;
inline bool RequestCommand::has_profilelikecommand() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void RequestCommand::set_has_profilelikecommand() {
  _has_bits_[0] |= 0x80000000u;
}
inline void RequestCommand::clear_has_profilelikecommand() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void RequestCommand::clear_profilelikecommand() {
  if (profilelikecommand_ != NULL) profilelikecommand_->::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand::Clear();
  clear_has_profilelikecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand& RequestCommand::profilelikecommand() const {
  return profilelikecommand_ != NULL ? *profilelikecommand_ : *default_instance_->profilelikecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand* RequestCommand::mutable_profilelikecommand() {
  set_has_profilelikecommand();
  if (profilelikecommand_ == NULL) profilelikecommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand;
  return profilelikecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand* RequestCommand::release_profilelikecommand() {
  clear_has_profilelikecommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileLikeCommand* temp = profilelikecommand_;
  profilelikecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestProfileReportCommand profileReportCommand = 40;
inline bool RequestCommand::has_profilereportcommand() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void RequestCommand::set_has_profilereportcommand() {
  _has_bits_[1] |= 0x00000001u;
}
inline void RequestCommand::clear_has_profilereportcommand() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void RequestCommand::clear_profilereportcommand() {
  if (profilereportcommand_ != NULL) profilereportcommand_->::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand::Clear();
  clear_has_profilereportcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand& RequestCommand::profilereportcommand() const {
  return profilereportcommand_ != NULL ? *profilereportcommand_ : *default_instance_->profilereportcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand* RequestCommand::mutable_profilereportcommand() {
  set_has_profilereportcommand();
  if (profilereportcommand_ == NULL) profilereportcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand;
  return profilereportcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand* RequestCommand::release_profilereportcommand() {
  clear_has_profilereportcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileReportCommand* temp = profilereportcommand_;
  profilereportcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestProfileVSCommand profileVSCommand = 41;
inline bool RequestCommand::has_profilevscommand() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void RequestCommand::set_has_profilevscommand() {
  _has_bits_[1] |= 0x00000002u;
}
inline void RequestCommand::clear_has_profilevscommand() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void RequestCommand::clear_profilevscommand() {
  if (profilevscommand_ != NULL) profilevscommand_->::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand::Clear();
  clear_has_profilevscommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand& RequestCommand::profilevscommand() const {
  return profilevscommand_ != NULL ? *profilevscommand_ : *default_instance_->profilevscommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand* RequestCommand::mutable_profilevscommand() {
  set_has_profilevscommand();
  if (profilevscommand_ == NULL) profilevscommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand;
  return profilevscommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand* RequestCommand::release_profilevscommand() {
  clear_has_profilevscommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestProfileVSCommand* temp = profilevscommand_;
  profilevscommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestGotchaCommand gotchaCommand = 42;
inline bool RequestCommand::has_gotchacommand() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void RequestCommand::set_has_gotchacommand() {
  _has_bits_[1] |= 0x00000004u;
}
inline void RequestCommand::clear_has_gotchacommand() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void RequestCommand::clear_gotchacommand() {
  if (gotchacommand_ != NULL) gotchacommand_->::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand::Clear();
  clear_has_gotchacommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand& RequestCommand::gotchacommand() const {
  return gotchacommand_ != NULL ? *gotchacommand_ : *default_instance_->gotchacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand* RequestCommand::mutable_gotchacommand() {
  set_has_gotchacommand();
  if (gotchacommand_ == NULL) gotchacommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand;
  return gotchacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand* RequestCommand::release_gotchacommand() {
  clear_has_gotchacommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestGotchaCommand* temp = gotchacommand_;
  gotchacommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestCheatInfoCommand cheatInfoCommand = 43;
inline bool RequestCommand::has_cheatinfocommand() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void RequestCommand::set_has_cheatinfocommand() {
  _has_bits_[1] |= 0x00000008u;
}
inline void RequestCommand::clear_has_cheatinfocommand() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void RequestCommand::clear_cheatinfocommand() {
  if (cheatinfocommand_ != NULL) cheatinfocommand_->::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand::Clear();
  clear_has_cheatinfocommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand& RequestCommand::cheatinfocommand() const {
  return cheatinfocommand_ != NULL ? *cheatinfocommand_ : *default_instance_->cheatinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand* RequestCommand::mutable_cheatinfocommand() {
  set_has_cheatinfocommand();
  if (cheatinfocommand_ == NULL) cheatinfocommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand;
  return cheatinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand* RequestCommand::release_cheatinfocommand() {
  clear_has_cheatinfocommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestCheatInfoCommand* temp = cheatinfocommand_;
  cheatinfocommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestRecordUserRaceActionCommand recordUserRaceActionCommand = 44;
inline bool RequestCommand::has_recorduserraceactioncommand() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void RequestCommand::set_has_recorduserraceactioncommand() {
  _has_bits_[1] |= 0x00000010u;
}
inline void RequestCommand::clear_has_recorduserraceactioncommand() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void RequestCommand::clear_recorduserraceactioncommand() {
  if (recorduserraceactioncommand_ != NULL) recorduserraceactioncommand_->::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand::Clear();
  clear_has_recorduserraceactioncommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand& RequestCommand::recorduserraceactioncommand() const {
  return recorduserraceactioncommand_ != NULL ? *recorduserraceactioncommand_ : *default_instance_->recorduserraceactioncommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand* RequestCommand::mutable_recorduserraceactioncommand() {
  set_has_recorduserraceactioncommand();
  if (recorduserraceactioncommand_ == NULL) recorduserraceactioncommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand;
  return recorduserraceactioncommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand* RequestCommand::release_recorduserraceactioncommand() {
  clear_has_recorduserraceactioncommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestRecordUserRaceActionCommand* temp = recorduserraceactioncommand_;
  recorduserraceactioncommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestSystemCommand systemCommand = 45;
inline bool RequestCommand::has_systemcommand() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void RequestCommand::set_has_systemcommand() {
  _has_bits_[1] |= 0x00000020u;
}
inline void RequestCommand::clear_has_systemcommand() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void RequestCommand::clear_systemcommand() {
  if (systemcommand_ != NULL) systemcommand_->::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand::Clear();
  clear_has_systemcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand& RequestCommand::systemcommand() const {
  return systemcommand_ != NULL ? *systemcommand_ : *default_instance_->systemcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand* RequestCommand::mutable_systemcommand() {
  set_has_systemcommand();
  if (systemcommand_ == NULL) systemcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand;
  return systemcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand* RequestCommand::release_systemcommand() {
  clear_has_systemcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand* temp = systemcommand_;
  systemcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestLeaderboardClass leaderboardClassCommand = 46;
inline bool RequestCommand::has_leaderboardclasscommand() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void RequestCommand::set_has_leaderboardclasscommand() {
  _has_bits_[1] |= 0x00000040u;
}
inline void RequestCommand::clear_has_leaderboardclasscommand() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void RequestCommand::clear_leaderboardclasscommand() {
  if (leaderboardclasscommand_ != NULL) leaderboardclasscommand_->::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass::Clear();
  clear_has_leaderboardclasscommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass& RequestCommand::leaderboardclasscommand() const {
  return leaderboardclasscommand_ != NULL ? *leaderboardclasscommand_ : *default_instance_->leaderboardclasscommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass* RequestCommand::mutable_leaderboardclasscommand() {
  set_has_leaderboardclasscommand();
  if (leaderboardclasscommand_ == NULL) leaderboardclasscommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass;
  return leaderboardclasscommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass* RequestCommand::release_leaderboardclasscommand() {
  clear_has_leaderboardclasscommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboardClass* temp = leaderboardclasscommand_;
  leaderboardclasscommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestLeaderboard leaderboardCommand = 47;
inline bool RequestCommand::has_leaderboardcommand() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void RequestCommand::set_has_leaderboardcommand() {
  _has_bits_[1] |= 0x00000080u;
}
inline void RequestCommand::clear_has_leaderboardcommand() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void RequestCommand::clear_leaderboardcommand() {
  if (leaderboardcommand_ != NULL) leaderboardcommand_->::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard::Clear();
  clear_has_leaderboardcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard& RequestCommand::leaderboardcommand() const {
  return leaderboardcommand_ != NULL ? *leaderboardcommand_ : *default_instance_->leaderboardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard* RequestCommand::mutable_leaderboardcommand() {
  set_has_leaderboardcommand();
  if (leaderboardcommand_ == NULL) leaderboardcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard;
  return leaderboardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard* RequestCommand::release_leaderboardcommand() {
  clear_has_leaderboardcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestLeaderboard* temp = leaderboardcommand_;
  leaderboardcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestTournamentNum requestTournamentNum = 48;
inline bool RequestCommand::has_requesttournamentnum() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void RequestCommand::set_has_requesttournamentnum() {
  _has_bits_[1] |= 0x00000100u;
}
inline void RequestCommand::clear_has_requesttournamentnum() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void RequestCommand::clear_requesttournamentnum() {
  if (requesttournamentnum_ != NULL) requesttournamentnum_->::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum::Clear();
  clear_has_requesttournamentnum();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum& RequestCommand::requesttournamentnum() const {
  return requesttournamentnum_ != NULL ? *requesttournamentnum_ : *default_instance_->requesttournamentnum_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum* RequestCommand::mutable_requesttournamentnum() {
  set_has_requesttournamentnum();
  if (requesttournamentnum_ == NULL) requesttournamentnum_ = new ::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum;
  return requesttournamentnum_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum* RequestCommand::release_requesttournamentnum() {
  clear_has_requesttournamentnum();
  ::com::ea::eamobile::nfsmw::protoc::RequestTournamentNum* temp = requesttournamentnum_;
  requesttournamentnum_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestQuickRaceCommand requestQuickRace = 49;
inline bool RequestCommand::has_requestquickrace() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void RequestCommand::set_has_requestquickrace() {
  _has_bits_[1] |= 0x00000200u;
}
inline void RequestCommand::clear_has_requestquickrace() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void RequestCommand::clear_requestquickrace() {
  if (requestquickrace_ != NULL) requestquickrace_->::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand::Clear();
  clear_has_requestquickrace();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand& RequestCommand::requestquickrace() const {
  return requestquickrace_ != NULL ? *requestquickrace_ : *default_instance_->requestquickrace_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand* RequestCommand::mutable_requestquickrace() {
  set_has_requestquickrace();
  if (requestquickrace_ == NULL) requestquickrace_ = new ::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand;
  return requestquickrace_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand* RequestCommand::release_requestquickrace() {
  clear_has_requestquickrace();
  ::com::ea::eamobile::nfsmw::protoc::RequestQuickRaceCommand* temp = requestquickrace_;
  requestquickrace_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestBindingTokenCommand bindingTokenCommand = 50;
inline bool RequestCommand::has_bindingtokencommand() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void RequestCommand::set_has_bindingtokencommand() {
  _has_bits_[1] |= 0x00000400u;
}
inline void RequestCommand::clear_has_bindingtokencommand() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void RequestCommand::clear_bindingtokencommand() {
  if (bindingtokencommand_ != NULL) bindingtokencommand_->::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand::Clear();
  clear_has_bindingtokencommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand& RequestCommand::bindingtokencommand() const {
  return bindingtokencommand_ != NULL ? *bindingtokencommand_ : *default_instance_->bindingtokencommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand* RequestCommand::mutable_bindingtokencommand() {
  set_has_bindingtokencommand();
  if (bindingtokencommand_ == NULL) bindingtokencommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand;
  return bindingtokencommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand* RequestCommand::release_bindingtokencommand() {
  clear_has_bindingtokencommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingTokenCommand* temp = bindingtokencommand_;
  bindingtokencommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestBindingInfoCommand bindingInfoCommand = 51;
inline bool RequestCommand::has_bindinginfocommand() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void RequestCommand::set_has_bindinginfocommand() {
  _has_bits_[1] |= 0x00000800u;
}
inline void RequestCommand::clear_has_bindinginfocommand() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void RequestCommand::clear_bindinginfocommand() {
  if (bindinginfocommand_ != NULL) bindinginfocommand_->::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand::Clear();
  clear_has_bindinginfocommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand& RequestCommand::bindinginfocommand() const {
  return bindinginfocommand_ != NULL ? *bindinginfocommand_ : *default_instance_->bindinginfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand* RequestCommand::mutable_bindinginfocommand() {
  set_has_bindinginfocommand();
  if (bindinginfocommand_ == NULL) bindinginfocommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand;
  return bindinginfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand* RequestCommand::release_bindinginfocommand() {
  clear_has_bindinginfocommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestBindingInfoCommand* temp = bindinginfocommand_;
  bindinginfocommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestCollectEnergyCommand collectEnergyCommand = 52;
inline bool RequestCommand::has_collectenergycommand() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void RequestCommand::set_has_collectenergycommand() {
  _has_bits_[1] |= 0x00001000u;
}
inline void RequestCommand::clear_has_collectenergycommand() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void RequestCommand::clear_collectenergycommand() {
  if (collectenergycommand_ != NULL) collectenergycommand_->::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand::Clear();
  clear_has_collectenergycommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand& RequestCommand::collectenergycommand() const {
  return collectenergycommand_ != NULL ? *collectenergycommand_ : *default_instance_->collectenergycommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand* RequestCommand::mutable_collectenergycommand() {
  set_has_collectenergycommand();
  if (collectenergycommand_ == NULL) collectenergycommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand;
  return collectenergycommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand* RequestCommand::release_collectenergycommand() {
  clear_has_collectenergycommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestCollectEnergyCommand* temp = collectenergycommand_;
  collectenergycommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestEnergyTimeCommand energyTimeCommand = 53;
inline bool RequestCommand::has_energytimecommand() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void RequestCommand::set_has_energytimecommand() {
  _has_bits_[1] |= 0x00002000u;
}
inline void RequestCommand::clear_has_energytimecommand() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void RequestCommand::clear_energytimecommand() {
  if (energytimecommand_ != NULL) energytimecommand_->::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand::Clear();
  clear_has_energytimecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand& RequestCommand::energytimecommand() const {
  return energytimecommand_ != NULL ? *energytimecommand_ : *default_instance_->energytimecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand* RequestCommand::mutable_energytimecommand() {
  set_has_energytimecommand();
  if (energytimecommand_ == NULL) energytimecommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand;
  return energytimecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand* RequestCommand::release_energytimecommand() {
  clear_has_energytimecommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestEnergyTimeCommand* temp = energytimecommand_;
  energytimecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestFansRewardCommand fansRewardCommand = 54;
inline bool RequestCommand::has_fansrewardcommand() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void RequestCommand::set_has_fansrewardcommand() {
  _has_bits_[1] |= 0x00004000u;
}
inline void RequestCommand::clear_has_fansrewardcommand() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void RequestCommand::clear_fansrewardcommand() {
  if (fansrewardcommand_ != NULL) fansrewardcommand_->::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand::Clear();
  clear_has_fansrewardcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand& RequestCommand::fansrewardcommand() const {
  return fansrewardcommand_ != NULL ? *fansrewardcommand_ : *default_instance_->fansrewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand* RequestCommand::mutable_fansrewardcommand() {
  set_has_fansrewardcommand();
  if (fansrewardcommand_ == NULL) fansrewardcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand;
  return fansrewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand* RequestCommand::release_fansrewardcommand() {
  clear_has_fansrewardcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestFansRewardCommand* temp = fansrewardcommand_;
  fansrewardcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestPropPurchaseCommand propPurchaseCommand = 55;
inline bool RequestCommand::has_proppurchasecommand() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void RequestCommand::set_has_proppurchasecommand() {
  _has_bits_[1] |= 0x00008000u;
}
inline void RequestCommand::clear_has_proppurchasecommand() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void RequestCommand::clear_proppurchasecommand() {
  if (proppurchasecommand_ != NULL) proppurchasecommand_->::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand::Clear();
  clear_has_proppurchasecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand& RequestCommand::proppurchasecommand() const {
  return proppurchasecommand_ != NULL ? *proppurchasecommand_ : *default_instance_->proppurchasecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand* RequestCommand::mutable_proppurchasecommand() {
  set_has_proppurchasecommand();
  if (proppurchasecommand_ == NULL) proppurchasecommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand;
  return proppurchasecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand* RequestCommand::release_proppurchasecommand() {
  clear_has_proppurchasecommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestPropPurchaseCommand* temp = proppurchasecommand_;
  proppurchasecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestMissionRewardCommand missionRewardCommand = 56;
inline bool RequestCommand::has_missionrewardcommand() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void RequestCommand::set_has_missionrewardcommand() {
  _has_bits_[1] |= 0x00010000u;
}
inline void RequestCommand::clear_has_missionrewardcommand() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void RequestCommand::clear_missionrewardcommand() {
  if (missionrewardcommand_ != NULL) missionrewardcommand_->::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand::Clear();
  clear_has_missionrewardcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand& RequestCommand::missionrewardcommand() const {
  return missionrewardcommand_ != NULL ? *missionrewardcommand_ : *default_instance_->missionrewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand* RequestCommand::mutable_missionrewardcommand() {
  set_has_missionrewardcommand();
  if (missionrewardcommand_ == NULL) missionrewardcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand;
  return missionrewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand* RequestCommand::release_missionrewardcommand() {
  clear_has_missionrewardcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestMissionRewardCommand* temp = missionrewardcommand_;
  missionrewardcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestMissionFinishCommand missionFinishCommand = 57;
inline bool RequestCommand::has_missionfinishcommand() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void RequestCommand::set_has_missionfinishcommand() {
  _has_bits_[1] |= 0x00020000u;
}
inline void RequestCommand::clear_has_missionfinishcommand() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void RequestCommand::clear_missionfinishcommand() {
  if (missionfinishcommand_ != NULL) missionfinishcommand_->::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand::Clear();
  clear_has_missionfinishcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand& RequestCommand::missionfinishcommand() const {
  return missionfinishcommand_ != NULL ? *missionfinishcommand_ : *default_instance_->missionfinishcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand* RequestCommand::mutable_missionfinishcommand() {
  set_has_missionfinishcommand();
  if (missionfinishcommand_ == NULL) missionfinishcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand;
  return missionfinishcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand* RequestCommand::release_missionfinishcommand() {
  clear_has_missionfinishcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestMissionFinishCommand* temp = missionfinishcommand_;
  missionfinishcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestLotteryCommand lotteryCommand = 58;
inline bool RequestCommand::has_lotterycommand() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void RequestCommand::set_has_lotterycommand() {
  _has_bits_[1] |= 0x00040000u;
}
inline void RequestCommand::clear_has_lotterycommand() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void RequestCommand::clear_lotterycommand() {
  if (lotterycommand_ != NULL) lotterycommand_->::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand::Clear();
  clear_has_lotterycommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand& RequestCommand::lotterycommand() const {
  return lotterycommand_ != NULL ? *lotterycommand_ : *default_instance_->lotterycommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand* RequestCommand::mutable_lotterycommand() {
  set_has_lotterycommand();
  if (lotterycommand_ == NULL) lotterycommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand;
  return lotterycommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand* RequestCommand::release_lotterycommand() {
  clear_has_lotterycommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestLotteryCommand* temp = lotterycommand_;
  lotterycommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestFleetRaceCommand fleetRaceCommand = 59;
inline bool RequestCommand::has_fleetracecommand() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void RequestCommand::set_has_fleetracecommand() {
  _has_bits_[1] |= 0x00080000u;
}
inline void RequestCommand::clear_has_fleetracecommand() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void RequestCommand::clear_fleetracecommand() {
  if (fleetracecommand_ != NULL) fleetracecommand_->::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand::Clear();
  clear_has_fleetracecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand& RequestCommand::fleetracecommand() const {
  return fleetracecommand_ != NULL ? *fleetracecommand_ : *default_instance_->fleetracecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand* RequestCommand::mutable_fleetracecommand() {
  set_has_fleetracecommand();
  if (fleetracecommand_ == NULL) fleetracecommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand;
  return fleetracecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand* RequestCommand::release_fleetracecommand() {
  clear_has_fleetracecommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestFleetRaceCommand* temp = fleetracecommand_;
  fleetracecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestFleetStartCommand fleetStartCommand = 60;
inline bool RequestCommand::has_fleetstartcommand() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void RequestCommand::set_has_fleetstartcommand() {
  _has_bits_[1] |= 0x00100000u;
}
inline void RequestCommand::clear_has_fleetstartcommand() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void RequestCommand::clear_fleetstartcommand() {
  if (fleetstartcommand_ != NULL) fleetstartcommand_->::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand::Clear();
  clear_has_fleetstartcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand& RequestCommand::fleetstartcommand() const {
  return fleetstartcommand_ != NULL ? *fleetstartcommand_ : *default_instance_->fleetstartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand* RequestCommand::mutable_fleetstartcommand() {
  set_has_fleetstartcommand();
  if (fleetstartcommand_ == NULL) fleetstartcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand;
  return fleetstartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand* RequestCommand::release_fleetstartcommand() {
  clear_has_fleetstartcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestFleetStartCommand* temp = fleetstartcommand_;
  fleetstartcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestFleetEndCommand fleetEndCommand = 61;
inline bool RequestCommand::has_fleetendcommand() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void RequestCommand::set_has_fleetendcommand() {
  _has_bits_[1] |= 0x00200000u;
}
inline void RequestCommand::clear_has_fleetendcommand() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void RequestCommand::clear_fleetendcommand() {
  if (fleetendcommand_ != NULL) fleetendcommand_->::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand::Clear();
  clear_has_fleetendcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand& RequestCommand::fleetendcommand() const {
  return fleetendcommand_ != NULL ? *fleetendcommand_ : *default_instance_->fleetendcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand* RequestCommand::mutable_fleetendcommand() {
  set_has_fleetendcommand();
  if (fleetendcommand_ == NULL) fleetendcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand;
  return fleetendcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand* RequestCommand::release_fleetendcommand() {
  clear_has_fleetendcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestFleetEndCommand* temp = fleetendcommand_;
  fleetendcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestFleetDoubleCommand fleetDoubleCommand = 62;
inline bool RequestCommand::has_fleetdoublecommand() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void RequestCommand::set_has_fleetdoublecommand() {
  _has_bits_[1] |= 0x00400000u;
}
inline void RequestCommand::clear_has_fleetdoublecommand() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void RequestCommand::clear_fleetdoublecommand() {
  if (fleetdoublecommand_ != NULL) fleetdoublecommand_->::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand::Clear();
  clear_has_fleetdoublecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand& RequestCommand::fleetdoublecommand() const {
  return fleetdoublecommand_ != NULL ? *fleetdoublecommand_ : *default_instance_->fleetdoublecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand* RequestCommand::mutable_fleetdoublecommand() {
  set_has_fleetdoublecommand();
  if (fleetdoublecommand_ == NULL) fleetdoublecommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand;
  return fleetdoublecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand* RequestCommand::release_fleetdoublecommand() {
  clear_has_fleetdoublecommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestFleetDoubleCommand* temp = fleetdoublecommand_;
  fleetdoublecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.RequestFixCarLimitCommand fixCarLimitCommand = 63;
inline bool RequestCommand::has_fixcarlimitcommand() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void RequestCommand::set_has_fixcarlimitcommand() {
  _has_bits_[1] |= 0x00800000u;
}
inline void RequestCommand::clear_has_fixcarlimitcommand() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void RequestCommand::clear_fixcarlimitcommand() {
  if (fixcarlimitcommand_ != NULL) fixcarlimitcommand_->::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand::Clear();
  clear_has_fixcarlimitcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand& RequestCommand::fixcarlimitcommand() const {
  return fixcarlimitcommand_ != NULL ? *fixcarlimitcommand_ : *default_instance_->fixcarlimitcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand* RequestCommand::mutable_fixcarlimitcommand() {
  set_has_fixcarlimitcommand();
  if (fixcarlimitcommand_ == NULL) fixcarlimitcommand_ = new ::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand;
  return fixcarlimitcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand* RequestCommand::release_fixcarlimitcommand() {
  clear_has_fixcarlimitcommand();
  ::com::ea::eamobile::nfsmw::protoc::RequestFixCarLimitCommand* temp = fixcarlimitcommand_;
  fixcarlimitcommand_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ResponseCommand

// required .com.ea.eamobile.nfsmw.protoc.HeadInfo head = 1;
inline bool ResponseCommand::has_head() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseCommand::set_has_head() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseCommand::clear_has_head() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseCommand::clear_head() {
  if (head_ != NULL) head_->::com::ea::eamobile::nfsmw::protoc::HeadInfo::Clear();
  clear_has_head();
}
inline const ::com::ea::eamobile::nfsmw::protoc::HeadInfo& ResponseCommand::head() const {
  return head_ != NULL ? *head_ : *default_instance_->head_;
}
inline ::com::ea::eamobile::nfsmw::protoc::HeadInfo* ResponseCommand::mutable_head() {
  set_has_head();
  if (head_ == NULL) head_ = new ::com::ea::eamobile::nfsmw::protoc::HeadInfo;
  return head_;
}
inline ::com::ea::eamobile::nfsmw::protoc::HeadInfo* ResponseCommand::release_head() {
  clear_has_head();
  ::com::ea::eamobile::nfsmw::protoc::HeadInfo* temp = head_;
  head_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTrackCommand trackCommand = 2;
inline bool ResponseCommand::has_trackcommand() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseCommand::set_has_trackcommand() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseCommand::clear_has_trackcommand() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseCommand::clear_trackcommand() {
  if (trackcommand_ != NULL) trackcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand::Clear();
  clear_has_trackcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand& ResponseCommand::trackcommand() const {
  return trackcommand_ != NULL ? *trackcommand_ : *default_instance_->trackcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand* ResponseCommand::mutable_trackcommand() {
  set_has_trackcommand();
  if (trackcommand_ == NULL) trackcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand;
  return trackcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand* ResponseCommand::release_trackcommand() {
  clear_has_trackcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTrackCommand* temp = trackcommand_;
  trackcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseUserInfoCommand userInfoCommand = 3;
inline bool ResponseCommand::has_userinfocommand() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseCommand::set_has_userinfocommand() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseCommand::clear_has_userinfocommand() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseCommand::clear_userinfocommand() {
  if (userinfocommand_ != NULL) userinfocommand_->::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand::Clear();
  clear_has_userinfocommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand& ResponseCommand::userinfocommand() const {
  return userinfocommand_ != NULL ? *userinfocommand_ : *default_instance_->userinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand* ResponseCommand::mutable_userinfocommand() {
  set_has_userinfocommand();
  if (userinfocommand_ == NULL) userinfocommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand;
  return userinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand* ResponseCommand::release_userinfocommand() {
  clear_has_userinfocommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseUserInfoCommand* temp = userinfocommand_;
  userinfocommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseRacerForGhostCommand ghostCommand = 4;
inline bool ResponseCommand::has_ghostcommand() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResponseCommand::set_has_ghostcommand() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResponseCommand::clear_has_ghostcommand() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResponseCommand::clear_ghostcommand() {
  if (ghostcommand_ != NULL) ghostcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand::Clear();
  clear_has_ghostcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand& ResponseCommand::ghostcommand() const {
  return ghostcommand_ != NULL ? *ghostcommand_ : *default_instance_->ghostcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand* ResponseCommand::mutable_ghostcommand() {
  set_has_ghostcommand();
  if (ghostcommand_ == NULL) ghostcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand;
  return ghostcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand* ResponseCommand::release_ghostcommand() {
  clear_has_ghostcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseRacerForGhostCommand* temp = ghostcommand_;
  ghostcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseRaceResultCommand raceResultCommand = 5;
inline bool ResponseCommand::has_raceresultcommand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResponseCommand::set_has_raceresultcommand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResponseCommand::clear_has_raceresultcommand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResponseCommand::clear_raceresultcommand() {
  if (raceresultcommand_ != NULL) raceresultcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand::Clear();
  clear_has_raceresultcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand& ResponseCommand::raceresultcommand() const {
  return raceresultcommand_ != NULL ? *raceresultcommand_ : *default_instance_->raceresultcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand* ResponseCommand::mutable_raceresultcommand() {
  set_has_raceresultcommand();
  if (raceresultcommand_ == NULL) raceresultcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand;
  return raceresultcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand* ResponseCommand::release_raceresultcommand() {
  clear_has_raceresultcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseRaceResultCommand* temp = raceresultcommand_;
  raceresultcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentDetailCommand tournamentDetailCommand = 6;
inline bool ResponseCommand::has_tournamentdetailcommand() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResponseCommand::set_has_tournamentdetailcommand() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResponseCommand::clear_has_tournamentdetailcommand() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResponseCommand::clear_tournamentdetailcommand() {
  if (tournamentdetailcommand_ != NULL) tournamentdetailcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand::Clear();
  clear_has_tournamentdetailcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand& ResponseCommand::tournamentdetailcommand() const {
  return tournamentdetailcommand_ != NULL ? *tournamentdetailcommand_ : *default_instance_->tournamentdetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand* ResponseCommand::mutable_tournamentdetailcommand() {
  set_has_tournamentdetailcommand();
  if (tournamentdetailcommand_ == NULL) tournamentdetailcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand;
  return tournamentdetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand* ResponseCommand::release_tournamentdetailcommand() {
  clear_has_tournamentdetailcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentDetailCommand* temp = tournamentdetailcommand_;
  tournamentdetailcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentRewardDetailCommand tournamentRewardDetailCommand = 7;
inline bool ResponseCommand::has_tournamentrewarddetailcommand() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResponseCommand::set_has_tournamentrewarddetailcommand() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResponseCommand::clear_has_tournamentrewarddetailcommand() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResponseCommand::clear_tournamentrewarddetailcommand() {
  if (tournamentrewarddetailcommand_ != NULL) tournamentrewarddetailcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand::Clear();
  clear_has_tournamentrewarddetailcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand& ResponseCommand::tournamentrewarddetailcommand() const {
  return tournamentrewarddetailcommand_ != NULL ? *tournamentrewarddetailcommand_ : *default_instance_->tournamentrewarddetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand* ResponseCommand::mutable_tournamentrewarddetailcommand() {
  set_has_tournamentrewarddetailcommand();
  if (tournamentrewarddetailcommand_ == NULL) tournamentrewarddetailcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand;
  return tournamentrewarddetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand* ResponseCommand::release_tournamentrewarddetailcommand() {
  clear_has_tournamentrewarddetailcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardDetailCommand* temp = tournamentrewarddetailcommand_;
  tournamentrewarddetailcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentCommand tournamentCommand = 9;
inline bool ResponseCommand::has_tournamentcommand() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResponseCommand::set_has_tournamentcommand() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResponseCommand::clear_has_tournamentcommand() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResponseCommand::clear_tournamentcommand() {
  if (tournamentcommand_ != NULL) tournamentcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand::Clear();
  clear_has_tournamentcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand& ResponseCommand::tournamentcommand() const {
  return tournamentcommand_ != NULL ? *tournamentcommand_ : *default_instance_->tournamentcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand* ResponseCommand::mutable_tournamentcommand() {
  set_has_tournamentcommand();
  if (tournamentcommand_ == NULL) tournamentcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand;
  return tournamentcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand* ResponseCommand::release_tournamentcommand() {
  clear_has_tournamentcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentCommand* temp = tournamentcommand_;
  tournamentcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseResourceCommand resourceCommand = 10;
inline bool ResponseCommand::has_resourcecommand() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResponseCommand::set_has_resourcecommand() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResponseCommand::clear_has_resourcecommand() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResponseCommand::clear_resourcecommand() {
  if (resourcecommand_ != NULL) resourcecommand_->::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand::Clear();
  clear_has_resourcecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand& ResponseCommand::resourcecommand() const {
  return resourcecommand_ != NULL ? *resourcecommand_ : *default_instance_->resourcecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand* ResponseCommand::mutable_resourcecommand() {
  set_has_resourcecommand();
  if (resourcecommand_ == NULL) resourcecommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand;
  return resourcecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand* ResponseCommand::release_resourcecommand() {
  clear_has_resourcecommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseResourceCommand* temp = resourcecommand_;
  resourcecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentSignUpCommand tournamentSignUpCommand = 17;
inline bool ResponseCommand::has_tournamentsignupcommand() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResponseCommand::set_has_tournamentsignupcommand() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResponseCommand::clear_has_tournamentsignupcommand() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResponseCommand::clear_tournamentsignupcommand() {
  if (tournamentsignupcommand_ != NULL) tournamentsignupcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand::Clear();
  clear_has_tournamentsignupcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand& ResponseCommand::tournamentsignupcommand() const {
  return tournamentsignupcommand_ != NULL ? *tournamentsignupcommand_ : *default_instance_->tournamentsignupcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand* ResponseCommand::mutable_tournamentsignupcommand() {
  set_has_tournamentsignupcommand();
  if (tournamentsignupcommand_ == NULL) tournamentsignupcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand;
  return tournamentsignupcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand* ResponseCommand::release_tournamentsignupcommand() {
  clear_has_tournamentsignupcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentSignUpCommand* temp = tournamentsignupcommand_;
  tournamentsignupcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseRaceStartCommand raceStartCommand = 19;
inline bool ResponseCommand::has_racestartcommand() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResponseCommand::set_has_racestartcommand() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResponseCommand::clear_has_racestartcommand() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResponseCommand::clear_racestartcommand() {
  if (racestartcommand_ != NULL) racestartcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand::Clear();
  clear_has_racestartcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand& ResponseCommand::racestartcommand() const {
  return racestartcommand_ != NULL ? *racestartcommand_ : *default_instance_->racestartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand* ResponseCommand::mutable_racestartcommand() {
  set_has_racestartcommand();
  if (racestartcommand_ == NULL) racestartcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand;
  return racestartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand* ResponseCommand::release_racestartcommand() {
  clear_has_racestartcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseRaceStartCommand* temp = racestartcommand_;
  racestartcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingStartCommand bindingStartCommand = 20;
inline bool ResponseCommand::has_bindingstartcommand() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResponseCommand::set_has_bindingstartcommand() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResponseCommand::clear_has_bindingstartcommand() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResponseCommand::clear_bindingstartcommand() {
  if (bindingstartcommand_ != NULL) bindingstartcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand::Clear();
  clear_has_bindingstartcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand& ResponseCommand::bindingstartcommand() const {
  return bindingstartcommand_ != NULL ? *bindingstartcommand_ : *default_instance_->bindingstartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand* ResponseCommand::mutable_bindingstartcommand() {
  set_has_bindingstartcommand();
  if (bindingstartcommand_ == NULL) bindingstartcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand;
  return bindingstartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand* ResponseCommand::release_bindingstartcommand() {
  clear_has_bindingstartcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingStartCommand* temp = bindingstartcommand_;
  bindingstartcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingResultCommand bindingResultCommand = 21;
inline bool ResponseCommand::has_bindingresultcommand() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResponseCommand::set_has_bindingresultcommand() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResponseCommand::clear_has_bindingresultcommand() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResponseCommand::clear_bindingresultcommand() {
  if (bindingresultcommand_ != NULL) bindingresultcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand::Clear();
  clear_has_bindingresultcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand& ResponseCommand::bindingresultcommand() const {
  return bindingresultcommand_ != NULL ? *bindingresultcommand_ : *default_instance_->bindingresultcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand* ResponseCommand::mutable_bindingresultcommand() {
  set_has_bindingresultcommand();
  if (bindingresultcommand_ == NULL) bindingresultcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand;
  return bindingresultcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand* ResponseCommand::release_bindingresultcommand() {
  clear_has_bindingresultcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingResultCommand* temp = bindingresultcommand_;
  bindingresultcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingConfirmCommand bindingConfirmCommand = 22;
inline bool ResponseCommand::has_bindingconfirmcommand() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ResponseCommand::set_has_bindingconfirmcommand() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ResponseCommand::clear_has_bindingconfirmcommand() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ResponseCommand::clear_bindingconfirmcommand() {
  if (bindingconfirmcommand_ != NULL) bindingconfirmcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand::Clear();
  clear_has_bindingconfirmcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand& ResponseCommand::bindingconfirmcommand() const {
  return bindingconfirmcommand_ != NULL ? *bindingconfirmcommand_ : *default_instance_->bindingconfirmcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* ResponseCommand::mutable_bindingconfirmcommand() {
  set_has_bindingconfirmcommand();
  if (bindingconfirmcommand_ == NULL) bindingconfirmcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand;
  return bindingconfirmcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* ResponseCommand::release_bindingconfirmcommand() {
  clear_has_bindingconfirmcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingConfirmCommand* temp = bindingconfirmcommand_;
  bindingconfirmcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingPopupCommand bindingPopupCommand = 23;
inline bool ResponseCommand::has_bindingpopupcommand() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ResponseCommand::set_has_bindingpopupcommand() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ResponseCommand::clear_has_bindingpopupcommand() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ResponseCommand::clear_bindingpopupcommand() {
  if (bindingpopupcommand_ != NULL) bindingpopupcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand::Clear();
  clear_has_bindingpopupcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand& ResponseCommand::bindingpopupcommand() const {
  return bindingpopupcommand_ != NULL ? *bindingpopupcommand_ : *default_instance_->bindingpopupcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand* ResponseCommand::mutable_bindingpopupcommand() {
  set_has_bindingpopupcommand();
  if (bindingpopupcommand_ == NULL) bindingpopupcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand;
  return bindingpopupcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand* ResponseCommand::release_bindingpopupcommand() {
  clear_has_bindingpopupcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingPopupCommand* temp = bindingpopupcommand_;
  bindingpopupcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ErrorCommand errorCommand = 24;
inline bool ResponseCommand::has_errorcommand() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ResponseCommand::set_has_errorcommand() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ResponseCommand::clear_has_errorcommand() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ResponseCommand::clear_errorcommand() {
  if (errorcommand_ != NULL) errorcommand_->::com::ea::eamobile::nfsmw::protoc::ErrorCommand::Clear();
  clear_has_errorcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ErrorCommand& ResponseCommand::errorcommand() const {
  return errorcommand_ != NULL ? *errorcommand_ : *default_instance_->errorcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* ResponseCommand::mutable_errorcommand() {
  set_has_errorcommand();
  if (errorcommand_ == NULL) errorcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ErrorCommand;
  return errorcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* ResponseCommand::release_errorcommand() {
  clear_has_errorcommand();
  ::com::ea::eamobile::nfsmw::protoc::ErrorCommand* temp = errorcommand_;
  errorcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseModeInfoCommand modeInfoCommand = 25;
inline bool ResponseCommand::has_modeinfocommand() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ResponseCommand::set_has_modeinfocommand() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ResponseCommand::clear_has_modeinfocommand() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ResponseCommand::clear_modeinfocommand() {
  if (modeinfocommand_ != NULL) modeinfocommand_->::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand::Clear();
  clear_has_modeinfocommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand& ResponseCommand::modeinfocommand() const {
  return modeinfocommand_ != NULL ? *modeinfocommand_ : *default_instance_->modeinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand* ResponseCommand::mutable_modeinfocommand() {
  set_has_modeinfocommand();
  if (modeinfocommand_ == NULL) modeinfocommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand;
  return modeinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand* ResponseCommand::release_modeinfocommand() {
  clear_has_modeinfocommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseModeInfoCommand* temp = modeinfocommand_;
  modeinfocommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.responseTournamentRewardCommand rewardCommand = 26;
inline bool ResponseCommand::has_rewardcommand() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ResponseCommand::set_has_rewardcommand() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ResponseCommand::clear_has_rewardcommand() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ResponseCommand::clear_rewardcommand() {
  if (rewardcommand_ != NULL) rewardcommand_->::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand::Clear();
  clear_has_rewardcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand& ResponseCommand::rewardcommand() const {
  return rewardcommand_ != NULL ? *rewardcommand_ : *default_instance_->rewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand* ResponseCommand::mutable_rewardcommand() {
  set_has_rewardcommand();
  if (rewardcommand_ == NULL) rewardcommand_ = new ::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand;
  return rewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand* ResponseCommand::release_rewardcommand() {
  clear_has_rewardcommand();
  ::com::ea::eamobile::nfsmw::protoc::responseTournamentRewardCommand* temp = rewardcommand_;
  rewardcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseGetRewardCommand getReward = 27;
inline bool ResponseCommand::has_getreward() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ResponseCommand::set_has_getreward() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ResponseCommand::clear_has_getreward() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ResponseCommand::clear_getreward() {
  if (getreward_ != NULL) getreward_->::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand::Clear();
  clear_has_getreward();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand& ResponseCommand::getreward() const {
  return getreward_ != NULL ? *getreward_ : *default_instance_->getreward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand* ResponseCommand::mutable_getreward() {
  set_has_getreward();
  if (getreward_ == NULL) getreward_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand;
  return getreward_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand* ResponseCommand::release_getreward() {
  clear_has_getreward();
  ::com::ea::eamobile::nfsmw::protoc::ResponseGetRewardCommand* temp = getreward_;
  getreward_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentRaceStartCommand tournamentRaceStart = 28;
inline bool ResponseCommand::has_tournamentracestart() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ResponseCommand::set_has_tournamentracestart() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ResponseCommand::clear_has_tournamentracestart() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ResponseCommand::clear_tournamentracestart() {
  if (tournamentracestart_ != NULL) tournamentracestart_->::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand::Clear();
  clear_has_tournamentracestart();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand& ResponseCommand::tournamentracestart() const {
  return tournamentracestart_ != NULL ? *tournamentracestart_ : *default_instance_->tournamentracestart_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand* ResponseCommand::mutable_tournamentracestart() {
  set_has_tournamentracestart();
  if (tournamentracestart_ == NULL) tournamentracestart_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand;
  return tournamentracestart_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand* ResponseCommand::release_tournamentracestart() {
  clear_has_tournamentracestart();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceStartCommand* temp = tournamentracestart_;
  tournamentracestart_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentRaceResultCommand tournamentRaceReault = 29;
inline bool ResponseCommand::has_tournamentracereault() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ResponseCommand::set_has_tournamentracereault() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ResponseCommand::clear_has_tournamentracereault() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ResponseCommand::clear_tournamentracereault() {
  if (tournamentracereault_ != NULL) tournamentracereault_->::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand::Clear();
  clear_has_tournamentracereault();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand& ResponseCommand::tournamentracereault() const {
  return tournamentracereault_ != NULL ? *tournamentracereault_ : *default_instance_->tournamentracereault_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand* ResponseCommand::mutable_tournamentracereault() {
  set_has_tournamentracereault();
  if (tournamentracereault_ == NULL) tournamentracereault_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand;
  return tournamentracereault_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand* ResponseCommand::release_tournamentracereault() {
  clear_has_tournamentracereault();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRaceResultCommand* temp = tournamentracereault_;
  tournamentracereault_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseGarageCommand garageCommand = 30;
inline bool ResponseCommand::has_garagecommand() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ResponseCommand::set_has_garagecommand() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ResponseCommand::clear_has_garagecommand() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ResponseCommand::clear_garagecommand() {
  if (garagecommand_ != NULL) garagecommand_->::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand::Clear();
  clear_has_garagecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand& ResponseCommand::garagecommand() const {
  return garagecommand_ != NULL ? *garagecommand_ : *default_instance_->garagecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand* ResponseCommand::mutable_garagecommand() {
  set_has_garagecommand();
  if (garagecommand_ == NULL) garagecommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand;
  return garagecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand* ResponseCommand::release_garagecommand() {
  clear_has_garagecommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseGarageCommand* temp = garagecommand_;
  garagecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBuyCarCommand buyCarCommand = 31;
inline bool ResponseCommand::has_buycarcommand() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ResponseCommand::set_has_buycarcommand() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ResponseCommand::clear_has_buycarcommand() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ResponseCommand::clear_buycarcommand() {
  if (buycarcommand_ != NULL) buycarcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand::Clear();
  clear_has_buycarcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand& ResponseCommand::buycarcommand() const {
  return buycarcommand_ != NULL ? *buycarcommand_ : *default_instance_->buycarcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand* ResponseCommand::mutable_buycarcommand() {
  set_has_buycarcommand();
  if (buycarcommand_ == NULL) buycarcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand;
  return buycarcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand* ResponseCommand::release_buycarcommand() {
  clear_has_buycarcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBuyCarCommand* temp = buycarcommand_;
  buycarcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseCarDataCommand carDataCommand = 32;
inline bool ResponseCommand::has_cardatacommand() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ResponseCommand::set_has_cardatacommand() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ResponseCommand::clear_has_cardatacommand() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ResponseCommand::clear_cardatacommand() {
  if (cardatacommand_ != NULL) cardatacommand_->::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand::Clear();
  clear_has_cardatacommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand& ResponseCommand::cardatacommand() const {
  return cardatacommand_ != NULL ? *cardatacommand_ : *default_instance_->cardatacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand* ResponseCommand::mutable_cardatacommand() {
  set_has_cardatacommand();
  if (cardatacommand_ == NULL) cardatacommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand;
  return cardatacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand* ResponseCommand::release_cardatacommand() {
  clear_has_cardatacommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseCarDataCommand* temp = cardatacommand_;
  cardatacommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseUpgradeSlotCommand upgradeSlotCommand = 33;
inline bool ResponseCommand::has_upgradeslotcommand() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ResponseCommand::set_has_upgradeslotcommand() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ResponseCommand::clear_has_upgradeslotcommand() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ResponseCommand::clear_upgradeslotcommand() {
  if (upgradeslotcommand_ != NULL) upgradeslotcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand::Clear();
  clear_has_upgradeslotcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand& ResponseCommand::upgradeslotcommand() const {
  return upgradeslotcommand_ != NULL ? *upgradeslotcommand_ : *default_instance_->upgradeslotcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand* ResponseCommand::mutable_upgradeslotcommand() {
  set_has_upgradeslotcommand();
  if (upgradeslotcommand_ == NULL) upgradeslotcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand;
  return upgradeslotcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand* ResponseCommand::release_upgradeslotcommand() {
  clear_has_upgradeslotcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseUpgradeSlotCommand* temp = upgradeslotcommand_;
  upgradeslotcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseUseChartletCommand useChartletCommand = 34;
inline bool ResponseCommand::has_usechartletcommand() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ResponseCommand::set_has_usechartletcommand() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ResponseCommand::clear_has_usechartletcommand() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ResponseCommand::clear_usechartletcommand() {
  if (usechartletcommand_ != NULL) usechartletcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand::Clear();
  clear_has_usechartletcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand& ResponseCommand::usechartletcommand() const {
  return usechartletcommand_ != NULL ? *usechartletcommand_ : *default_instance_->usechartletcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand* ResponseCommand::mutable_usechartletcommand() {
  set_has_usechartletcommand();
  if (usechartletcommand_ == NULL) usechartletcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand;
  return usechartletcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand* ResponseCommand::release_usechartletcommand() {
  clear_has_usechartletcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseUseChartletCommand* temp = usechartletcommand_;
  usechartletcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseModifyUserInfoCommand modifyUserInfoCommand = 35;
inline bool ResponseCommand::has_modifyuserinfocommand() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ResponseCommand::set_has_modifyuserinfocommand() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ResponseCommand::clear_has_modifyuserinfocommand() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ResponseCommand::clear_modifyuserinfocommand() {
  if (modifyuserinfocommand_ != NULL) modifyuserinfocommand_->::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand::Clear();
  clear_has_modifyuserinfocommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand& ResponseCommand::modifyuserinfocommand() const {
  return modifyuserinfocommand_ != NULL ? *modifyuserinfocommand_ : *default_instance_->modifyuserinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand* ResponseCommand::mutable_modifyuserinfocommand() {
  set_has_modifyuserinfocommand();
  if (modifyuserinfocommand_ == NULL) modifyuserinfocommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand;
  return modifyuserinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand* ResponseCommand::release_modifyuserinfocommand() {
  clear_has_modifyuserinfocommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseModifyUserInfoCommand* temp = modifyuserinfocommand_;
  modifyuserinfocommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseChallengeMatchInfoCommand challengeMatchInfoCommand = 36;
inline bool ResponseCommand::has_challengematchinfocommand() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ResponseCommand::set_has_challengematchinfocommand() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ResponseCommand::clear_has_challengematchinfocommand() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ResponseCommand::clear_challengematchinfocommand() {
  if (challengematchinfocommand_ != NULL) challengematchinfocommand_->::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand::Clear();
  clear_has_challengematchinfocommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand& ResponseCommand::challengematchinfocommand() const {
  return challengematchinfocommand_ != NULL ? *challengematchinfocommand_ : *default_instance_->challengematchinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand* ResponseCommand::mutable_challengematchinfocommand() {
  set_has_challengematchinfocommand();
  if (challengematchinfocommand_ == NULL) challengematchinfocommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand;
  return challengematchinfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand* ResponseCommand::release_challengematchinfocommand() {
  clear_has_challengematchinfocommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseChallengeMatchInfoCommand* temp = challengematchinfocommand_;
  challengematchinfocommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseStoreDetailCommand storeDetailCommand = 37;
inline bool ResponseCommand::has_storedetailcommand() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ResponseCommand::set_has_storedetailcommand() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ResponseCommand::clear_has_storedetailcommand() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ResponseCommand::clear_storedetailcommand() {
  if (storedetailcommand_ != NULL) storedetailcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand::Clear();
  clear_has_storedetailcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand& ResponseCommand::storedetailcommand() const {
  return storedetailcommand_ != NULL ? *storedetailcommand_ : *default_instance_->storedetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand* ResponseCommand::mutable_storedetailcommand() {
  set_has_storedetailcommand();
  if (storedetailcommand_ == NULL) storedetailcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand;
  return storedetailcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand* ResponseCommand::release_storedetailcommand() {
  clear_has_storedetailcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseStoreDetailCommand* temp = storedetailcommand_;
  storedetailcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBuyItemCommand buyItemCommand = 38;
inline bool ResponseCommand::has_buyitemcommand() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ResponseCommand::set_has_buyitemcommand() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ResponseCommand::clear_has_buyitemcommand() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ResponseCommand::clear_buyitemcommand() {
  if (buyitemcommand_ != NULL) buyitemcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand::Clear();
  clear_has_buyitemcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand& ResponseCommand::buyitemcommand() const {
  return buyitemcommand_ != NULL ? *buyitemcommand_ : *default_instance_->buyitemcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand* ResponseCommand::mutable_buyitemcommand() {
  set_has_buyitemcommand();
  if (buyitemcommand_ == NULL) buyitemcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand;
  return buyitemcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand* ResponseCommand::release_buyitemcommand() {
  clear_has_buyitemcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBuyItemCommand* temp = buyitemcommand_;
  buyitemcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseSystemCommand systemCommand = 39;
inline bool ResponseCommand::has_systemcommand() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ResponseCommand::set_has_systemcommand() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ResponseCommand::clear_has_systemcommand() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ResponseCommand::clear_systemcommand() {
  if (systemcommand_ != NULL) systemcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand::Clear();
  clear_has_systemcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand& ResponseCommand::systemcommand() const {
  return systemcommand_ != NULL ? *systemcommand_ : *default_instance_->systemcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand* ResponseCommand::mutable_systemcommand() {
  set_has_systemcommand();
  if (systemcommand_ == NULL) systemcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand;
  return systemcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand* ResponseCommand::release_systemcommand() {
  clear_has_systemcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseSystemCommand* temp = systemcommand_;
  systemcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseWeiboShareLocksCommand weiboShareCommand = 40;
inline bool ResponseCommand::has_weibosharecommand() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ResponseCommand::set_has_weibosharecommand() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ResponseCommand::clear_has_weibosharecommand() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ResponseCommand::clear_weibosharecommand() {
  if (weibosharecommand_ != NULL) weibosharecommand_->::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand::Clear();
  clear_has_weibosharecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand& ResponseCommand::weibosharecommand() const {
  return weibosharecommand_ != NULL ? *weibosharecommand_ : *default_instance_->weibosharecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand* ResponseCommand::mutable_weibosharecommand() {
  set_has_weibosharecommand();
  if (weibosharecommand_ == NULL) weibosharecommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand;
  return weibosharecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand* ResponseCommand::release_weibosharecommand() {
  clear_has_weibosharecommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseWeiboShareLocksCommand* temp = weibosharecommand_;
  weibosharecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseRegistJaguarCommand registJaguar = 41;
inline bool ResponseCommand::has_registjaguar() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ResponseCommand::set_has_registjaguar() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ResponseCommand::clear_has_registjaguar() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ResponseCommand::clear_registjaguar() {
  if (registjaguar_ != NULL) registjaguar_->::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand::Clear();
  clear_has_registjaguar();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand& ResponseCommand::registjaguar() const {
  return registjaguar_ != NULL ? *registjaguar_ : *default_instance_->registjaguar_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand* ResponseCommand::mutable_registjaguar() {
  set_has_registjaguar();
  if (registjaguar_ == NULL) registjaguar_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand;
  return registjaguar_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand* ResponseCommand::release_registjaguar() {
  clear_has_registjaguar();
  ::com::ea::eamobile::nfsmw::protoc::ResponseRegistJaguarCommand* temp = registjaguar_;
  registjaguar_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseFeedCommand feedCommand = 42;
inline bool ResponseCommand::has_feedcommand() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ResponseCommand::set_has_feedcommand() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ResponseCommand::clear_has_feedcommand() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ResponseCommand::clear_feedcommand() {
  if (feedcommand_ != NULL) feedcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand::Clear();
  clear_has_feedcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand& ResponseCommand::feedcommand() const {
  return feedcommand_ != NULL ? *feedcommand_ : *default_instance_->feedcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand* ResponseCommand::mutable_feedcommand() {
  set_has_feedcommand();
  if (feedcommand_ == NULL) feedcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand;
  return feedcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand* ResponseCommand::release_feedcommand() {
  clear_has_feedcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseFeedCommand* temp = feedcommand_;
  feedcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseIapCheckCommand IapCheckCommand = 43;
inline bool ResponseCommand::has_iapcheckcommand() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ResponseCommand::set_has_iapcheckcommand() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ResponseCommand::clear_has_iapcheckcommand() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ResponseCommand::clear_iapcheckcommand() {
  if (iapcheckcommand_ != NULL) iapcheckcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand::Clear();
  clear_has_iapcheckcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand& ResponseCommand::iapcheckcommand() const {
  return iapcheckcommand_ != NULL ? *iapcheckcommand_ : *default_instance_->iapcheckcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand* ResponseCommand::mutable_iapcheckcommand() {
  set_has_iapcheckcommand();
  if (iapcheckcommand_ == NULL) iapcheckcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand;
  return iapcheckcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand* ResponseCommand::release_iapcheckcommand() {
  clear_has_iapcheckcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseIapCheckCommand* temp = iapcheckcommand_;
  iapcheckcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentNotificationCommand tournamentNotificationCommand = 44;
inline bool ResponseCommand::has_tournamentnotificationcommand() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ResponseCommand::set_has_tournamentnotificationcommand() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ResponseCommand::clear_has_tournamentnotificationcommand() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ResponseCommand::clear_tournamentnotificationcommand() {
  if (tournamentnotificationcommand_ != NULL) tournamentnotificationcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand::Clear();
  clear_has_tournamentnotificationcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand& ResponseCommand::tournamentnotificationcommand() const {
  return tournamentnotificationcommand_ != NULL ? *tournamentnotificationcommand_ : *default_instance_->tournamentnotificationcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand* ResponseCommand::mutable_tournamentnotificationcommand() {
  set_has_tournamentnotificationcommand();
  if (tournamentnotificationcommand_ == NULL) tournamentnotificationcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand;
  return tournamentnotificationcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand* ResponseCommand::release_tournamentnotificationcommand() {
  clear_has_tournamentnotificationcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNotificationCommand* temp = tournamentnotificationcommand_;
  tournamentnotificationcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTutorialRewardCommand tutorialRewardCommand = 45;
inline bool ResponseCommand::has_tutorialrewardcommand() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ResponseCommand::set_has_tutorialrewardcommand() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ResponseCommand::clear_has_tutorialrewardcommand() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ResponseCommand::clear_tutorialrewardcommand() {
  if (tutorialrewardcommand_ != NULL) tutorialrewardcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand::Clear();
  clear_has_tutorialrewardcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand& ResponseCommand::tutorialrewardcommand() const {
  return tutorialrewardcommand_ != NULL ? *tutorialrewardcommand_ : *default_instance_->tutorialrewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand* ResponseCommand::mutable_tutorialrewardcommand() {
  set_has_tutorialrewardcommand();
  if (tutorialrewardcommand_ == NULL) tutorialrewardcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand;
  return tutorialrewardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand* ResponseCommand::release_tutorialrewardcommand() {
  clear_has_tutorialrewardcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTutorialRewardCommand* temp = tutorialrewardcommand_;
  tutorialrewardcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponsePopupCommand popupCommand = 46;
inline bool ResponseCommand::has_popupcommand() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ResponseCommand::set_has_popupcommand() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ResponseCommand::clear_has_popupcommand() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ResponseCommand::clear_popupcommand() {
  if (popupcommand_ != NULL) popupcommand_->::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand::Clear();
  clear_has_popupcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand& ResponseCommand::popupcommand() const {
  return popupcommand_ != NULL ? *popupcommand_ : *default_instance_->popupcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* ResponseCommand::mutable_popupcommand() {
  set_has_popupcommand();
  if (popupcommand_ == NULL) popupcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand;
  return popupcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* ResponseCommand::release_popupcommand() {
  clear_has_popupcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponsePopupCommand* temp = popupcommand_;
  popupcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseRpLeaderboardCommand rpLeaderboardCommand = 47;
inline bool ResponseCommand::has_rpleaderboardcommand() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ResponseCommand::set_has_rpleaderboardcommand() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ResponseCommand::clear_has_rpleaderboardcommand() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ResponseCommand::clear_rpleaderboardcommand() {
  if (rpleaderboardcommand_ != NULL) rpleaderboardcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand::Clear();
  clear_has_rpleaderboardcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand& ResponseCommand::rpleaderboardcommand() const {
  return rpleaderboardcommand_ != NULL ? *rpleaderboardcommand_ : *default_instance_->rpleaderboardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand* ResponseCommand::mutable_rpleaderboardcommand() {
  set_has_rpleaderboardcommand();
  if (rpleaderboardcommand_ == NULL) rpleaderboardcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand;
  return rpleaderboardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand* ResponseCommand::release_rpleaderboardcommand() {
  clear_has_rpleaderboardcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseRpLeaderboardCommand* temp = rpleaderboardcommand_;
  rpleaderboardcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseNotificationCommand notificationCommand = 48;
inline bool ResponseCommand::has_notificationcommand() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void ResponseCommand::set_has_notificationcommand() {
  _has_bits_[1] |= 0x00000080u;
}
inline void ResponseCommand::clear_has_notificationcommand() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void ResponseCommand::clear_notificationcommand() {
  if (notificationcommand_ != NULL) notificationcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand::Clear();
  clear_has_notificationcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand& ResponseCommand::notificationcommand() const {
  return notificationcommand_ != NULL ? *notificationcommand_ : *default_instance_->notificationcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand* ResponseCommand::mutable_notificationcommand() {
  set_has_notificationcommand();
  if (notificationcommand_ == NULL) notificationcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand;
  return notificationcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand* ResponseCommand::release_notificationcommand() {
  clear_has_notificationcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseNotificationCommand* temp = notificationcommand_;
  notificationcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseGhostRecordCommand ghostRecordCommand = 49;
inline bool ResponseCommand::has_ghostrecordcommand() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void ResponseCommand::set_has_ghostrecordcommand() {
  _has_bits_[1] |= 0x00000100u;
}
inline void ResponseCommand::clear_has_ghostrecordcommand() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void ResponseCommand::clear_ghostrecordcommand() {
  if (ghostrecordcommand_ != NULL) ghostrecordcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand::Clear();
  clear_has_ghostrecordcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand& ResponseCommand::ghostrecordcommand() const {
  return ghostrecordcommand_ != NULL ? *ghostrecordcommand_ : *default_instance_->ghostrecordcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand* ResponseCommand::mutable_ghostrecordcommand() {
  set_has_ghostrecordcommand();
  if (ghostrecordcommand_ == NULL) ghostrecordcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand;
  return ghostrecordcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand* ResponseCommand::release_ghostrecordcommand() {
  clear_has_ghostrecordcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseGhostRecordCommand* temp = ghostrecordcommand_;
  ghostrecordcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentRewardNumCommand tournamentRewardNumCommand = 50;
inline bool ResponseCommand::has_tournamentrewardnumcommand() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void ResponseCommand::set_has_tournamentrewardnumcommand() {
  _has_bits_[1] |= 0x00000200u;
}
inline void ResponseCommand::clear_has_tournamentrewardnumcommand() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void ResponseCommand::clear_tournamentrewardnumcommand() {
  if (tournamentrewardnumcommand_ != NULL) tournamentrewardnumcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand::Clear();
  clear_has_tournamentrewardnumcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand& ResponseCommand::tournamentrewardnumcommand() const {
  return tournamentrewardnumcommand_ != NULL ? *tournamentrewardnumcommand_ : *default_instance_->tournamentrewardnumcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand* ResponseCommand::mutable_tournamentrewardnumcommand() {
  set_has_tournamentrewardnumcommand();
  if (tournamentrewardnumcommand_ == NULL) tournamentrewardnumcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand;
  return tournamentrewardnumcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand* ResponseCommand::release_tournamentrewardnumcommand() {
  clear_has_tournamentrewardnumcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentRewardNumCommand* temp = tournamentrewardnumcommand_;
  tournamentrewardnumcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileUserDataCommand profileUserDataCommand = 51;
inline bool ResponseCommand::has_profileuserdatacommand() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void ResponseCommand::set_has_profileuserdatacommand() {
  _has_bits_[1] |= 0x00000400u;
}
inline void ResponseCommand::clear_has_profileuserdatacommand() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void ResponseCommand::clear_profileuserdatacommand() {
  if (profileuserdatacommand_ != NULL) profileuserdatacommand_->::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand::Clear();
  clear_has_profileuserdatacommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand& ResponseCommand::profileuserdatacommand() const {
  return profileuserdatacommand_ != NULL ? *profileuserdatacommand_ : *default_instance_->profileuserdatacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand* ResponseCommand::mutable_profileuserdatacommand() {
  set_has_profileuserdatacommand();
  if (profileuserdatacommand_ == NULL) profileuserdatacommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand;
  return profileuserdatacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand* ResponseCommand::release_profileuserdatacommand() {
  clear_has_profileuserdatacommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileUserDataCommand* temp = profileuserdatacommand_;
  profileuserdatacommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileNextCarCommand profileNextCarCommand = 52;
inline bool ResponseCommand::has_profilenextcarcommand() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void ResponseCommand::set_has_profilenextcarcommand() {
  _has_bits_[1] |= 0x00000800u;
}
inline void ResponseCommand::clear_has_profilenextcarcommand() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void ResponseCommand::clear_profilenextcarcommand() {
  if (profilenextcarcommand_ != NULL) profilenextcarcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand::Clear();
  clear_has_profilenextcarcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand& ResponseCommand::profilenextcarcommand() const {
  return profilenextcarcommand_ != NULL ? *profilenextcarcommand_ : *default_instance_->profilenextcarcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand* ResponseCommand::mutable_profilenextcarcommand() {
  set_has_profilenextcarcommand();
  if (profilenextcarcommand_ == NULL) profilenextcarcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand;
  return profilenextcarcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand* ResponseCommand::release_profilenextcarcommand() {
  clear_has_profilenextcarcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileNextCarCommand* temp = profilenextcarcommand_;
  profilenextcarcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileLikeCommand profileLikeCommand = 53;
inline bool ResponseCommand::has_profilelikecommand() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void ResponseCommand::set_has_profilelikecommand() {
  _has_bits_[1] |= 0x00001000u;
}
inline void ResponseCommand::clear_has_profilelikecommand() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void ResponseCommand::clear_profilelikecommand() {
  if (profilelikecommand_ != NULL) profilelikecommand_->::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand::Clear();
  clear_has_profilelikecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand& ResponseCommand::profilelikecommand() const {
  return profilelikecommand_ != NULL ? *profilelikecommand_ : *default_instance_->profilelikecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand* ResponseCommand::mutable_profilelikecommand() {
  set_has_profilelikecommand();
  if (profilelikecommand_ == NULL) profilelikecommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand;
  return profilelikecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand* ResponseCommand::release_profilelikecommand() {
  clear_has_profilelikecommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileLikeCommand* temp = profilelikecommand_;
  profilelikecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileReportCommand profileReportCommand = 54;
inline bool ResponseCommand::has_profilereportcommand() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void ResponseCommand::set_has_profilereportcommand() {
  _has_bits_[1] |= 0x00002000u;
}
inline void ResponseCommand::clear_has_profilereportcommand() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void ResponseCommand::clear_profilereportcommand() {
  if (profilereportcommand_ != NULL) profilereportcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand::Clear();
  clear_has_profilereportcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand& ResponseCommand::profilereportcommand() const {
  return profilereportcommand_ != NULL ? *profilereportcommand_ : *default_instance_->profilereportcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand* ResponseCommand::mutable_profilereportcommand() {
  set_has_profilereportcommand();
  if (profilereportcommand_ == NULL) profilereportcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand;
  return profilereportcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand* ResponseCommand::release_profilereportcommand() {
  clear_has_profilereportcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileReportCommand* temp = profilereportcommand_;
  profilereportcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseProfileVSCommand profileVSCommand = 55;
inline bool ResponseCommand::has_profilevscommand() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void ResponseCommand::set_has_profilevscommand() {
  _has_bits_[1] |= 0x00004000u;
}
inline void ResponseCommand::clear_has_profilevscommand() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void ResponseCommand::clear_profilevscommand() {
  if (profilevscommand_ != NULL) profilevscommand_->::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand::Clear();
  clear_has_profilevscommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand& ResponseCommand::profilevscommand() const {
  return profilevscommand_ != NULL ? *profilevscommand_ : *default_instance_->profilevscommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand* ResponseCommand::mutable_profilevscommand() {
  set_has_profilevscommand();
  if (profilevscommand_ == NULL) profilevscommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand;
  return profilevscommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand* ResponseCommand::release_profilevscommand() {
  clear_has_profilevscommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseProfileVSCommand* temp = profilevscommand_;
  profilevscommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseGotchaCommand gotchaCommand = 56;
inline bool ResponseCommand::has_gotchacommand() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void ResponseCommand::set_has_gotchacommand() {
  _has_bits_[1] |= 0x00008000u;
}
inline void ResponseCommand::clear_has_gotchacommand() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void ResponseCommand::clear_gotchacommand() {
  if (gotchacommand_ != NULL) gotchacommand_->::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand::Clear();
  clear_has_gotchacommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand& ResponseCommand::gotchacommand() const {
  return gotchacommand_ != NULL ? *gotchacommand_ : *default_instance_->gotchacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand* ResponseCommand::mutable_gotchacommand() {
  set_has_gotchacommand();
  if (gotchacommand_ == NULL) gotchacommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand;
  return gotchacommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand* ResponseCommand::release_gotchacommand() {
  clear_has_gotchacommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseGotchaCommand* temp = gotchacommand_;
  gotchacommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseLeaderboardClass leaderboardClassCommand = 57;
inline bool ResponseCommand::has_leaderboardclasscommand() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void ResponseCommand::set_has_leaderboardclasscommand() {
  _has_bits_[1] |= 0x00010000u;
}
inline void ResponseCommand::clear_has_leaderboardclasscommand() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void ResponseCommand::clear_leaderboardclasscommand() {
  if (leaderboardclasscommand_ != NULL) leaderboardclasscommand_->::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass::Clear();
  clear_has_leaderboardclasscommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass& ResponseCommand::leaderboardclasscommand() const {
  return leaderboardclasscommand_ != NULL ? *leaderboardclasscommand_ : *default_instance_->leaderboardclasscommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass* ResponseCommand::mutable_leaderboardclasscommand() {
  set_has_leaderboardclasscommand();
  if (leaderboardclasscommand_ == NULL) leaderboardclasscommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass;
  return leaderboardclasscommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass* ResponseCommand::release_leaderboardclasscommand() {
  clear_has_leaderboardclasscommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboardClass* temp = leaderboardclasscommand_;
  leaderboardclasscommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseLeaderboard leaderboardCommand = 58;
inline bool ResponseCommand::has_leaderboardcommand() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void ResponseCommand::set_has_leaderboardcommand() {
  _has_bits_[1] |= 0x00020000u;
}
inline void ResponseCommand::clear_has_leaderboardcommand() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void ResponseCommand::clear_leaderboardcommand() {
  if (leaderboardcommand_ != NULL) leaderboardcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard::Clear();
  clear_has_leaderboardcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard& ResponseCommand::leaderboardcommand() const {
  return leaderboardcommand_ != NULL ? *leaderboardcommand_ : *default_instance_->leaderboardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard* ResponseCommand::mutable_leaderboardcommand() {
  set_has_leaderboardcommand();
  if (leaderboardcommand_ == NULL) leaderboardcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard;
  return leaderboardcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard* ResponseCommand::release_leaderboardcommand() {
  clear_has_leaderboardcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseLeaderboard* temp = leaderboardcommand_;
  leaderboardcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseTournamentNum responseTournamentNum = 59;
inline bool ResponseCommand::has_responsetournamentnum() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void ResponseCommand::set_has_responsetournamentnum() {
  _has_bits_[1] |= 0x00040000u;
}
inline void ResponseCommand::clear_has_responsetournamentnum() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void ResponseCommand::clear_responsetournamentnum() {
  if (responsetournamentnum_ != NULL) responsetournamentnum_->::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum::Clear();
  clear_has_responsetournamentnum();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum& ResponseCommand::responsetournamentnum() const {
  return responsetournamentnum_ != NULL ? *responsetournamentnum_ : *default_instance_->responsetournamentnum_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum* ResponseCommand::mutable_responsetournamentnum() {
  set_has_responsetournamentnum();
  if (responsetournamentnum_ == NULL) responsetournamentnum_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum;
  return responsetournamentnum_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum* ResponseCommand::release_responsetournamentnum() {
  clear_has_responsetournamentnum();
  ::com::ea::eamobile::nfsmw::protoc::ResponseTournamentNum* temp = responsetournamentnum_;
  responsetournamentnum_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseQuickRaceCommand responseQuickRace = 60;
inline bool ResponseCommand::has_responsequickrace() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void ResponseCommand::set_has_responsequickrace() {
  _has_bits_[1] |= 0x00080000u;
}
inline void ResponseCommand::clear_has_responsequickrace() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void ResponseCommand::clear_responsequickrace() {
  if (responsequickrace_ != NULL) responsequickrace_->::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand::Clear();
  clear_has_responsequickrace();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand& ResponseCommand::responsequickrace() const {
  return responsequickrace_ != NULL ? *responsequickrace_ : *default_instance_->responsequickrace_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand* ResponseCommand::mutable_responsequickrace() {
  set_has_responsequickrace();
  if (responsequickrace_ == NULL) responsequickrace_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand;
  return responsequickrace_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand* ResponseCommand::release_responsequickrace() {
  clear_has_responsequickrace();
  ::com::ea::eamobile::nfsmw::protoc::ResponseQuickRaceCommand* temp = responsequickrace_;
  responsequickrace_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingTokenCommand bindingTokenCommand = 61;
inline bool ResponseCommand::has_bindingtokencommand() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void ResponseCommand::set_has_bindingtokencommand() {
  _has_bits_[1] |= 0x00100000u;
}
inline void ResponseCommand::clear_has_bindingtokencommand() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void ResponseCommand::clear_bindingtokencommand() {
  if (bindingtokencommand_ != NULL) bindingtokencommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand::Clear();
  clear_has_bindingtokencommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand& ResponseCommand::bindingtokencommand() const {
  return bindingtokencommand_ != NULL ? *bindingtokencommand_ : *default_instance_->bindingtokencommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand* ResponseCommand::mutable_bindingtokencommand() {
  set_has_bindingtokencommand();
  if (bindingtokencommand_ == NULL) bindingtokencommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand;
  return bindingtokencommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand* ResponseCommand::release_bindingtokencommand() {
  clear_has_bindingtokencommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingTokenCommand* temp = bindingtokencommand_;
  bindingtokencommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseBindingInfoCommand bindingInfoCommand = 62;
inline bool ResponseCommand::has_bindinginfocommand() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void ResponseCommand::set_has_bindinginfocommand() {
  _has_bits_[1] |= 0x00200000u;
}
inline void ResponseCommand::clear_has_bindinginfocommand() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void ResponseCommand::clear_bindinginfocommand() {
  if (bindinginfocommand_ != NULL) bindinginfocommand_->::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand::Clear();
  clear_has_bindinginfocommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand& ResponseCommand::bindinginfocommand() const {
  return bindinginfocommand_ != NULL ? *bindinginfocommand_ : *default_instance_->bindinginfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand* ResponseCommand::mutable_bindinginfocommand() {
  set_has_bindinginfocommand();
  if (bindinginfocommand_ == NULL) bindinginfocommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand;
  return bindinginfocommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand* ResponseCommand::release_bindinginfocommand() {
  clear_has_bindinginfocommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseBindingInfoCommand* temp = bindinginfocommand_;
  bindinginfocommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseEnergyTimeCommand energyTimeCommand = 63;
inline bool ResponseCommand::has_energytimecommand() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void ResponseCommand::set_has_energytimecommand() {
  _has_bits_[1] |= 0x00400000u;
}
inline void ResponseCommand::clear_has_energytimecommand() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void ResponseCommand::clear_energytimecommand() {
  if (energytimecommand_ != NULL) energytimecommand_->::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand::Clear();
  clear_has_energytimecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand& ResponseCommand::energytimecommand() const {
  return energytimecommand_ != NULL ? *energytimecommand_ : *default_instance_->energytimecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand* ResponseCommand::mutable_energytimecommand() {
  set_has_energytimecommand();
  if (energytimecommand_ == NULL) energytimecommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand;
  return energytimecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand* ResponseCommand::release_energytimecommand() {
  clear_has_energytimecommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseEnergyTimeCommand* temp = energytimecommand_;
  energytimecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseFansRewardTimeCommand fansRewardTimeCommand = 64;
inline bool ResponseCommand::has_fansrewardtimecommand() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void ResponseCommand::set_has_fansrewardtimecommand() {
  _has_bits_[1] |= 0x00800000u;
}
inline void ResponseCommand::clear_has_fansrewardtimecommand() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void ResponseCommand::clear_fansrewardtimecommand() {
  if (fansrewardtimecommand_ != NULL) fansrewardtimecommand_->::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand::Clear();
  clear_has_fansrewardtimecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand& ResponseCommand::fansrewardtimecommand() const {
  return fansrewardtimecommand_ != NULL ? *fansrewardtimecommand_ : *default_instance_->fansrewardtimecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand* ResponseCommand::mutable_fansrewardtimecommand() {
  set_has_fansrewardtimecommand();
  if (fansrewardtimecommand_ == NULL) fansrewardtimecommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand;
  return fansrewardtimecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand* ResponseCommand::release_fansrewardtimecommand() {
  clear_has_fansrewardtimecommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseFansRewardTimeCommand* temp = fansrewardtimecommand_;
  fansrewardtimecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseMissionListCommand missionListCommand = 65;
inline bool ResponseCommand::has_missionlistcommand() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void ResponseCommand::set_has_missionlistcommand() {
  _has_bits_[1] |= 0x01000000u;
}
inline void ResponseCommand::clear_has_missionlistcommand() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void ResponseCommand::clear_missionlistcommand() {
  if (missionlistcommand_ != NULL) missionlistcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand::Clear();
  clear_has_missionlistcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand& ResponseCommand::missionlistcommand() const {
  return missionlistcommand_ != NULL ? *missionlistcommand_ : *default_instance_->missionlistcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand* ResponseCommand::mutable_missionlistcommand() {
  set_has_missionlistcommand();
  if (missionlistcommand_ == NULL) missionlistcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand;
  return missionlistcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand* ResponseCommand::release_missionlistcommand() {
  clear_has_missionlistcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseMissionListCommand* temp = missionlistcommand_;
  missionlistcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseLotteryCommand lotteryCommand = 66;
inline bool ResponseCommand::has_lotterycommand() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void ResponseCommand::set_has_lotterycommand() {
  _has_bits_[1] |= 0x02000000u;
}
inline void ResponseCommand::clear_has_lotterycommand() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void ResponseCommand::clear_lotterycommand() {
  if (lotterycommand_ != NULL) lotterycommand_->::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand::Clear();
  clear_has_lotterycommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand& ResponseCommand::lotterycommand() const {
  return lotterycommand_ != NULL ? *lotterycommand_ : *default_instance_->lotterycommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand* ResponseCommand::mutable_lotterycommand() {
  set_has_lotterycommand();
  if (lotterycommand_ == NULL) lotterycommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand;
  return lotterycommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand* ResponseCommand::release_lotterycommand() {
  clear_has_lotterycommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseLotteryCommand* temp = lotterycommand_;
  lotterycommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponsePopupListCommand popuplistCommand = 67;
inline bool ResponseCommand::has_popuplistcommand() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void ResponseCommand::set_has_popuplistcommand() {
  _has_bits_[1] |= 0x04000000u;
}
inline void ResponseCommand::clear_has_popuplistcommand() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void ResponseCommand::clear_popuplistcommand() {
  if (popuplistcommand_ != NULL) popuplistcommand_->::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand::Clear();
  clear_has_popuplistcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand& ResponseCommand::popuplistcommand() const {
  return popuplistcommand_ != NULL ? *popuplistcommand_ : *default_instance_->popuplistcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand* ResponseCommand::mutable_popuplistcommand() {
  set_has_popuplistcommand();
  if (popuplistcommand_ == NULL) popuplistcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand;
  return popuplistcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand* ResponseCommand::release_popuplistcommand() {
  clear_has_popuplistcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponsePopupListCommand* temp = popuplistcommand_;
  popuplistcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseFleetRaceCommand fleetRaceCommand = 68;
inline bool ResponseCommand::has_fleetracecommand() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void ResponseCommand::set_has_fleetracecommand() {
  _has_bits_[1] |= 0x08000000u;
}
inline void ResponseCommand::clear_has_fleetracecommand() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void ResponseCommand::clear_fleetracecommand() {
  if (fleetracecommand_ != NULL) fleetracecommand_->::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand::Clear();
  clear_has_fleetracecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand& ResponseCommand::fleetracecommand() const {
  return fleetracecommand_ != NULL ? *fleetracecommand_ : *default_instance_->fleetracecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand* ResponseCommand::mutable_fleetracecommand() {
  set_has_fleetracecommand();
  if (fleetracecommand_ == NULL) fleetracecommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand;
  return fleetracecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand* ResponseCommand::release_fleetracecommand() {
  clear_has_fleetracecommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseFleetRaceCommand* temp = fleetracecommand_;
  fleetracecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseFleetStartCommand fleetStartCommand = 69;
inline bool ResponseCommand::has_fleetstartcommand() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void ResponseCommand::set_has_fleetstartcommand() {
  _has_bits_[1] |= 0x10000000u;
}
inline void ResponseCommand::clear_has_fleetstartcommand() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void ResponseCommand::clear_fleetstartcommand() {
  if (fleetstartcommand_ != NULL) fleetstartcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand::Clear();
  clear_has_fleetstartcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand& ResponseCommand::fleetstartcommand() const {
  return fleetstartcommand_ != NULL ? *fleetstartcommand_ : *default_instance_->fleetstartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand* ResponseCommand::mutable_fleetstartcommand() {
  set_has_fleetstartcommand();
  if (fleetstartcommand_ == NULL) fleetstartcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand;
  return fleetstartcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand* ResponseCommand::release_fleetstartcommand() {
  clear_has_fleetstartcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseFleetStartCommand* temp = fleetstartcommand_;
  fleetstartcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseFleetEndCommand fleetEndCommand = 70;
inline bool ResponseCommand::has_fleetendcommand() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void ResponseCommand::set_has_fleetendcommand() {
  _has_bits_[1] |= 0x20000000u;
}
inline void ResponseCommand::clear_has_fleetendcommand() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void ResponseCommand::clear_fleetendcommand() {
  if (fleetendcommand_ != NULL) fleetendcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand::Clear();
  clear_has_fleetendcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand& ResponseCommand::fleetendcommand() const {
  return fleetendcommand_ != NULL ? *fleetendcommand_ : *default_instance_->fleetendcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand* ResponseCommand::mutable_fleetendcommand() {
  set_has_fleetendcommand();
  if (fleetendcommand_ == NULL) fleetendcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand;
  return fleetendcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand* ResponseCommand::release_fleetendcommand() {
  clear_has_fleetendcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseFleetEndCommand* temp = fleetendcommand_;
  fleetendcommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseFleetDoubleCommand fleetDoubleCommand = 71;
inline bool ResponseCommand::has_fleetdoublecommand() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void ResponseCommand::set_has_fleetdoublecommand() {
  _has_bits_[1] |= 0x40000000u;
}
inline void ResponseCommand::clear_has_fleetdoublecommand() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void ResponseCommand::clear_fleetdoublecommand() {
  if (fleetdoublecommand_ != NULL) fleetdoublecommand_->::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand::Clear();
  clear_has_fleetdoublecommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand& ResponseCommand::fleetdoublecommand() const {
  return fleetdoublecommand_ != NULL ? *fleetdoublecommand_ : *default_instance_->fleetdoublecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand* ResponseCommand::mutable_fleetdoublecommand() {
  set_has_fleetdoublecommand();
  if (fleetdoublecommand_ == NULL) fleetdoublecommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand;
  return fleetdoublecommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand* ResponseCommand::release_fleetdoublecommand() {
  clear_has_fleetdoublecommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseFleetDoubleCommand* temp = fleetdoublecommand_;
  fleetdoublecommand_ = NULL;
  return temp;
}

// optional .com.ea.eamobile.nfsmw.protoc.ResponseFixCarLimitCommand fixCarLimitCommand = 72;
inline bool ResponseCommand::has_fixcarlimitcommand() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void ResponseCommand::set_has_fixcarlimitcommand() {
  _has_bits_[1] |= 0x80000000u;
}
inline void ResponseCommand::clear_has_fixcarlimitcommand() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void ResponseCommand::clear_fixcarlimitcommand() {
  if (fixcarlimitcommand_ != NULL) fixcarlimitcommand_->::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand::Clear();
  clear_has_fixcarlimitcommand();
}
inline const ::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand& ResponseCommand::fixcarlimitcommand() const {
  return fixcarlimitcommand_ != NULL ? *fixcarlimitcommand_ : *default_instance_->fixcarlimitcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand* ResponseCommand::mutable_fixcarlimitcommand() {
  set_has_fixcarlimitcommand();
  if (fixcarlimitcommand_ == NULL) fixcarlimitcommand_ = new ::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand;
  return fixcarlimitcommand_;
}
inline ::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand* ResponseCommand::release_fixcarlimitcommand() {
  clear_has_fixcarlimitcommand();
  ::com::ea::eamobile::nfsmw::protoc::ResponseFixCarLimitCommand* temp = fixcarlimitcommand_;
  fixcarlimitcommand_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LocalUserinfo

// required int32 snsFlag = 1;
inline bool LocalUserinfo::has_snsflag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocalUserinfo::set_has_snsflag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocalUserinfo::clear_has_snsflag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocalUserinfo::clear_snsflag() {
  snsflag_ = 0;
  clear_has_snsflag();
}
inline ::google::protobuf::int32 LocalUserinfo::snsflag() const {
  return snsflag_;
}
inline void LocalUserinfo::set_snsflag(::google::protobuf::int32 value) {
  set_has_snsflag();
  snsflag_ = value;
}

// optional string session = 2;
inline bool LocalUserinfo::has_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocalUserinfo::set_has_session() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocalUserinfo::clear_has_session() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocalUserinfo::clear_session() {
  if (session_ != &::google::protobuf::internal::kEmptyString) {
    session_->clear();
  }
  clear_has_session();
}
inline const ::std::string& LocalUserinfo::session() const {
  return *session_;
}
inline void LocalUserinfo::set_session(const ::std::string& value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void LocalUserinfo::set_session(const char* value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(value);
}
inline void LocalUserinfo::set_session(const char* value, size_t size) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  session_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalUserinfo::mutable_session() {
  set_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    session_ = new ::std::string;
  }
  return session_;
}
inline ::std::string* LocalUserinfo::release_session() {
  clear_has_session();
  if (session_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = session_;
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string token = 3;
inline bool LocalUserinfo::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocalUserinfo::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocalUserinfo::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocalUserinfo::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& LocalUserinfo::token() const {
  return *token_;
}
inline void LocalUserinfo::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LocalUserinfo::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void LocalUserinfo::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalUserinfo::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* LocalUserinfo::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string serverUrl = 4;
inline int LocalUserinfo::serverurl_size() const {
  return serverurl_.size();
}
inline void LocalUserinfo::clear_serverurl() {
  serverurl_.Clear();
}
inline const ::std::string& LocalUserinfo::serverurl(int index) const {
  return serverurl_.Get(index);
}
inline ::std::string* LocalUserinfo::mutable_serverurl(int index) {
  return serverurl_.Mutable(index);
}
inline void LocalUserinfo::set_serverurl(int index, const ::std::string& value) {
  serverurl_.Mutable(index)->assign(value);
}
inline void LocalUserinfo::set_serverurl(int index, const char* value) {
  serverurl_.Mutable(index)->assign(value);
}
inline void LocalUserinfo::set_serverurl(int index, const char* value, size_t size) {
  serverurl_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalUserinfo::add_serverurl() {
  return serverurl_.Add();
}
inline void LocalUserinfo::add_serverurl(const ::std::string& value) {
  serverurl_.Add()->assign(value);
}
inline void LocalUserinfo::add_serverurl(const char* value) {
  serverurl_.Add()->assign(value);
}
inline void LocalUserinfo::add_serverurl(const char* value, size_t size) {
  serverurl_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LocalUserinfo::serverurl() const {
  return serverurl_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LocalUserinfo::mutable_serverurl() {
  return &serverurl_;
}

// optional string access_token = 5;
inline bool LocalUserinfo::has_access_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LocalUserinfo::set_has_access_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LocalUserinfo::clear_has_access_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LocalUserinfo::clear_access_token() {
  if (access_token_ != &::google::protobuf::internal::kEmptyString) {
    access_token_->clear();
  }
  clear_has_access_token();
}
inline const ::std::string& LocalUserinfo::access_token() const {
  return *access_token_;
}
inline void LocalUserinfo::set_access_token(const ::std::string& value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void LocalUserinfo::set_access_token(const char* value) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(value);
}
inline void LocalUserinfo::set_access_token(const char* value, size_t size) {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  access_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalUserinfo::mutable_access_token() {
  set_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    access_token_ = new ::std::string;
  }
  return access_token_;
}
inline ::std::string* LocalUserinfo::release_access_token() {
  clear_has_access_token();
  if (access_token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = access_token_;
    access_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string uid = 6;
inline bool LocalUserinfo::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LocalUserinfo::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LocalUserinfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LocalUserinfo::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& LocalUserinfo::uid() const {
  return *uid_;
}
inline void LocalUserinfo::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void LocalUserinfo::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void LocalUserinfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LocalUserinfo::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* LocalUserinfo::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protoc
}  // namespace nfsmw
}  // namespace eamobile
}  // namespace ea
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand_SystemConfigType>() {
  return ::com::ea::eamobile::nfsmw::protoc::RequestSystemCommand_SystemConfigType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Commands_2eproto__INCLUDED
